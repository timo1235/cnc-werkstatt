
AVRASM ver. 2.2.8  D:\AVR64DB\Public\Bootloader\Source\main.asm Sun Jul 14 00:15:08 2024

[builtin](3): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\AVR-Dx_DFP\1.10.114\avrasm\inc\AVR64DB64def.inc'
D:\AVR64DB\Public\Bootloader\Source\main.asm(30): Including file 'D:\AVR64DB\Public\Bootloader\Source\Macros.asm'
[builtin](3): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\AVR-Dx_DFP\1.10.114\avrasm\inc\AVR64DB64def.inc'
D:\AVR64DB\Public\Bootloader\Source\main.asm(30): Including file 'D:\AVR64DB\Public\Bootloader\Source\Macros.asm'
                                 
                                 ;##########################################################################################################################
                                 ;Select the "LPT Adapter" or "Terminal Adapter" Solution configuration depending on hardware
                                 
                                 
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;*
                                 ;* Number            : AVR000
                                 ;* File Name         : AVR64DB64def.inc
                                 ;* Title             : Register/Bit Definitions for the AVR64DB64
                                 ;* Created           : 2021-10-25 12:44
                                 ;* Version           : 1.00
                                 ;* Support e-mail    : avr@atmel.com
                                 ;* Target MCU        : AVR64DB64
                                 ;*
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal
                                 ;* SRAM is also defined
                                 ;*
                                 ;*************************************************************************
                                 
                                 #ifndef _AVR64DB64DEF_INC_
                                 #define _AVR64DB64DEF_INC_
                                 
                                 
                                 #pragma partinc 0
                                 
                                 ; ***** SPECIFY DEVICE ***************************************************
                                 .device	AVR64DB64
                                 
                                 #pragma AVRPART ADMIN PART_NAME AVR64DB64
                                 
                                 .equ	SIGNATURE_000	= 0x1E
                                 .equ	SIGNATURE_001	= 0x96
                                 .equ	SIGNATURE_002	= 0x16
                                 
                                 #pragma AVRPART CORE CORE_VERSION V4S
                                 
                                 
                                 ; ***** ABSOLUTE I/O REGISTER LOCATIONS **********************************
                                 
                                 
                                 ;*************************************************************************
                                 ;** AC0 - Analog Comparator
                                 ;*************************************************************************
                                 
                                 .equ AC0_CTRLA = 0x0680                  ; Control A
                                 .equ AC0_CTRLB = 0x0681                  ; Control B
                                 .equ AC0_MUXCTRL = 0x0682                ; Mux Control A
                                 .equ AC0_DACREF = 0x0685                 ; DAC Voltage Reference
                                 .equ AC0_INTCTRL = 0x0686                ; Interrupt Control
                                 .equ AC0_STATUS = 0x0687                 ; Status
                                 
                                 ;*************************************************************************
                                 ;** AC1 - Analog Comparator
                                 ;*************************************************************************
                                 
                                 .equ AC1_CTRLA = 0x0688                  ; Control A
                                 .equ AC1_CTRLB = 0x0689                  ; Control B
                                 .equ AC1_MUXCTRL = 0x068A                ; Mux Control A
                                 .equ AC1_DACREF = 0x068D                 ; DAC Voltage Reference
                                 .equ AC1_INTCTRL = 0x068E                ; Interrupt Control
                                 .equ AC1_STATUS = 0x068F                 ; Status
                                 
                                 ;*************************************************************************
                                 ;** AC2 - Analog Comparator
                                 ;*************************************************************************
                                 
                                 .equ AC2_CTRLA = 0x0690                  ; Control A
                                 .equ AC2_CTRLB = 0x0691                  ; Control B
                                 .equ AC2_MUXCTRL = 0x0692                ; Mux Control A
                                 .equ AC2_DACREF = 0x0695                 ; DAC Voltage Reference
                                 .equ AC2_INTCTRL = 0x0696                ; Interrupt Control
                                 .equ AC2_STATUS = 0x0697                 ; Status
                                 
                                 ;*************************************************************************
                                 ;** ADC0 - Analog to Digital Converter
                                 ;*************************************************************************
                                 
                                 .equ ADC0_CTRLA = 0x0600                 ; Control A
                                 .equ ADC0_CTRLB = 0x0601                 ; Control B
                                 .equ ADC0_CTRLC = 0x0602                 ; Control C
                                 .equ ADC0_CTRLD = 0x0603                 ; Control D
                                 .equ ADC0_CTRLE = 0x0604                 ; Control E
                                 .equ ADC0_SAMPCTRL = 0x0605              ; Sample Control
                                 .equ ADC0_MUXPOS = 0x0608                ; Positive mux input
                                 .equ ADC0_MUXNEG = 0x0609                ; Negative mux input
                                 .equ ADC0_COMMAND = 0x060A               ; Command
                                 .equ ADC0_EVCTRL = 0x060B                ; Event Control
                                 .equ ADC0_INTCTRL = 0x060C               ; Interrupt Control
                                 .equ ADC0_INTFLAGS = 0x060D              ; Interrupt Flags
                                 .equ ADC0_DBGCTRL = 0x060E               ; Debug Control
                                 .equ ADC0_TEMP = 0x060F                  ; Temporary Data
                                 .equ ADC0_RES = 0x0610                   ; ADC Accumulator Result
                                 .equ ADC0_RESL = 0x0610                  ; ADC Accumulator Result low byte
                                 .equ ADC0_RESH = 0x0611                  ; ADC Accumulator Result hi byte
                                 .equ ADC0_WINLT = 0x0612                 ; Window comparator low threshold
                                 .equ ADC0_WINLTL = 0x0612                ; Window comparator low threshold low byte
                                 .equ ADC0_WINLTH = 0x0613                ; Window comparator low threshold hi byte
                                 .equ ADC0_WINHT = 0x0614                 ; Window comparator high threshold
                                 .equ ADC0_WINHTL = 0x0614                ; Window comparator high threshold low byte
                                 .equ ADC0_WINHTH = 0x0615                ; Window comparator high threshold hi byte
                                 
                                 ;*************************************************************************
                                 ;** BOD - Bod interface
                                 ;*************************************************************************
                                 
                                 .equ BOD_CTRLA = 0x00A0                  ; Control A
                                 .equ BOD_CTRLB = 0x00A1                  ; Control B
                                 .equ BOD_VLMCTRLA = 0x00A8               ; Voltage level monitor Control
                                 .equ BOD_INTCTRL = 0x00A9                ; Voltage level monitor interrupt Control
                                 .equ BOD_INTFLAGS = 0x00AA               ; Voltage level monitor interrupt Flags
                                 .equ BOD_STATUS = 0x00AB                 ; Voltage level monitor status
                                 
                                 ;*************************************************************************
                                 ;** CCL - Configurable Custom Logic
                                 ;*************************************************************************
                                 
                                 .equ CCL_CTRLA = 0x01C0                  ; Control Register A
                                 .equ CCL_SEQCTRL0 = 0x01C1               ; Sequential Control 0
                                 .equ CCL_SEQCTRL1 = 0x01C2               ; Sequential Control 1
                                 .equ CCL_SEQCTRL2 = 0x01C3               ; Sequential Control 2
                                 .equ CCL_INTCTRL0 = 0x01C5               ; Interrupt Control 0
                                 .equ CCL_INTCTRL1 = 0x01C6               ; Interrupt Control 1
                                 .equ CCL_INTFLAGS = 0x01C7               ; Interrupt Flags
                                 .equ CCL_LUT0CTRLA = 0x01C8              ; LUT 0 Control A
                                 .equ CCL_LUT0CTRLB = 0x01C9              ; LUT 0 Control B
                                 .equ CCL_LUT0CTRLC = 0x01CA              ; LUT 0 Control C
                                 .equ CCL_TRUTH0 = 0x01CB                 ; Truth 0
                                 .equ CCL_LUT1CTRLA = 0x01CC              ; LUT 1 Control A
                                 .equ CCL_LUT1CTRLB = 0x01CD              ; LUT 1 Control B
                                 .equ CCL_LUT1CTRLC = 0x01CE              ; LUT 1 Control C
                                 .equ CCL_TRUTH1 = 0x01CF                 ; Truth 1
                                 .equ CCL_LUT2CTRLA = 0x01D0              ; LUT 2 Control A
                                 .equ CCL_LUT2CTRLB = 0x01D1              ; LUT 2 Control B
                                 .equ CCL_LUT2CTRLC = 0x01D2              ; LUT 2 Control C
                                 .equ CCL_TRUTH2 = 0x01D3                 ; Truth 2
                                 .equ CCL_LUT3CTRLA = 0x01D4              ; LUT 3 Control A
                                 .equ CCL_LUT3CTRLB = 0x01D5              ; LUT 3 Control B
                                 .equ CCL_LUT3CTRLC = 0x01D6              ; LUT 3 Control C
                                 .equ CCL_TRUTH3 = 0x01D7                 ; Truth 3
                                 .equ CCL_LUT4CTRLA = 0x01D8              ; LUT 4 Control A
                                 .equ CCL_LUT4CTRLB = 0x01D9              ; LUT 4 Control B
                                 .equ CCL_LUT4CTRLC = 0x01DA              ; LUT 4 Control C
                                 .equ CCL_TRUTH4 = 0x01DB                 ; Truth 4
                                 .equ CCL_LUT5CTRLA = 0x01DC              ; LUT 5 Control A
                                 .equ CCL_LUT5CTRLB = 0x01DD              ; LUT 5 Control B
                                 .equ CCL_LUT5CTRLC = 0x01DE              ; LUT 5 Control C
                                 .equ CCL_TRUTH5 = 0x01DF                 ; Truth 5
                                 
                                 ;*************************************************************************
                                 ;** CLKCTRL - Clock controller
                                 ;*************************************************************************
                                 
                                 .equ CLKCTRL_MCLKCTRLA = 0x0060          ; MCLK Control A
                                 .equ CLKCTRL_MCLKCTRLB = 0x0061          ; MCLK Control B
                                 .equ CLKCTRL_MCLKCTRLC = 0x0062          ; MCLK Control C
                                 .equ CLKCTRL_MCLKINTCTRL = 0x0063        ; MCLK Interrupt Control
                                 .equ CLKCTRL_MCLKINTFLAGS = 0x0064       ; MCLK Interrupt Flags
                                 .equ CLKCTRL_MCLKSTATUS = 0x0065         ; MCLK Status
                                 .equ CLKCTRL_OSCHFCTRLA = 0x0068         ; OSCHF Control A
                                 .equ CLKCTRL_OSCHFTUNE = 0x0069          ; OSCHF Tune
                                 .equ CLKCTRL_PLLCTRLA = 0x0070           ; PLL Control A
                                 .equ CLKCTRL_OSC32KCTRLA = 0x0078        ; OSC32K Control A
                                 .equ CLKCTRL_XOSC32KCTRLA = 0x007C       ; XOSC32K Control A
                                 .equ CLKCTRL_XOSCHFCTRLA = 0x0080        ; 
                                 
                                 ;*************************************************************************
                                 ;** CPU - CPU
                                 ;*************************************************************************
                                 
                                 .equ CPU_CCP = 0x0034                    ; Configuration Change Protection
                                 .equ CPU_RAMPZ = 0x003B                  ; Extended Z-pointer Register
                                 .equ CPU_SPL = 0x003D                    ; Stack Pointer Low
                                 .equ CPU_SPH = 0x003E                    ; Stack Pointer High
                                 .equ CPU_SREG = 0x003F                   ; Status Register
                                 
                                 ;*************************************************************************
                                 ;** CPUINT - Interrupt Controller
                                 ;*************************************************************************
                                 
                                 .equ CPUINT_CTRLA = 0x0110               ; Control A
                                 .equ CPUINT_STATUS = 0x0111              ; Status
                                 .equ CPUINT_LVL0PRI = 0x0112             ; Interrupt Level 0 Priority
                                 .equ CPUINT_LVL1VEC = 0x0113             ; Interrupt Level 1 Priority Vector
                                 
                                 ;*************************************************************************
                                 ;** CRCSCAN - CRCSCAN
                                 ;*************************************************************************
                                 
                                 .equ CRCSCAN_CTRLA = 0x0120              ; Control A
                                 .equ CRCSCAN_CTRLB = 0x0121              ; Control B
                                 .equ CRCSCAN_STATUS = 0x0122             ; Status
                                 
                                 ;*************************************************************************
                                 ;** DAC0 - Digital to Analog Converter
                                 ;*************************************************************************
                                 
                                 .equ DAC0_CTRLA = 0x06A0                 ; Control Register A
                                 .equ DAC0_DATA = 0x06A2                  ; DATA Register
                                 .equ DAC0_DATAL = 0x06A2                 ; DATA Register low byte
                                 .equ DAC0_DATAH = 0x06A3                 ; DATA Register hi byte
                                 
                                 ;*************************************************************************
                                 ;** EVSYS - Event System
                                 ;*************************************************************************
                                 
                                 .equ EVSYS_SWEVENTA = 0x0200             ; Software Event A
                                 .equ EVSYS_SWEVENTB = 0x0201             ; Software Event B
                                 .equ EVSYS_CHANNEL0 = 0x0210             ; Multiplexer Channel 0
                                 .equ EVSYS_CHANNEL1 = 0x0211             ; Multiplexer Channel 1
                                 .equ EVSYS_CHANNEL2 = 0x0212             ; Multiplexer Channel 2
                                 .equ EVSYS_CHANNEL3 = 0x0213             ; Multiplexer Channel 3
                                 .equ EVSYS_CHANNEL4 = 0x0214             ; Multiplexer Channel 4
                                 .equ EVSYS_CHANNEL5 = 0x0215             ; Multiplexer Channel 5
                                 .equ EVSYS_CHANNEL6 = 0x0216             ; Multiplexer Channel 6
                                 .equ EVSYS_CHANNEL7 = 0x0217             ; Multiplexer Channel 7
                                 .equ EVSYS_CHANNEL8 = 0x0218             ; Multiplexer Channel 8
                                 .equ EVSYS_CHANNEL9 = 0x0219             ; Multiplexer Channel 9
                                 .equ EVSYS_USERCCLLUT0A = 0x0220         ; User 0 - CCL0 Event A
                                 .equ EVSYS_USERCCLLUT0B = 0x0221         ; User 1 - CCL0 Event B
                                 .equ EVSYS_USERCCLLUT1A = 0x0222         ; User 2 - CCL1 Event A
                                 .equ EVSYS_USERCCLLUT1B = 0x0223         ; User 3 - CCL1 Event B
                                 .equ EVSYS_USERCCLLUT2A = 0x0224         ; User 4 - CCL2 Event A
                                 .equ EVSYS_USERCCLLUT2B = 0x0225         ; User 5 - CCL2 Event B
                                 .equ EVSYS_USERCCLLUT3A = 0x0226         ; User 6 - CCL3 Event A
                                 .equ EVSYS_USERCCLLUT3B = 0x0227         ; User 7 - CCL3 Event B
                                 .equ EVSYS_USERCCLLUT4A = 0x0228         ; User 8 - CCL4 Event A
                                 .equ EVSYS_USERCCLLUT4B = 0x0229         ; User 9 - CCL4 Event B
                                 .equ EVSYS_USERCCLLUT5A = 0x022A         ; User 10 - CCL5 Event A
                                 .equ EVSYS_USERCCLLUT5B = 0x022B         ; User 11 - CCL5 Event B
                                 .equ EVSYS_USERADC0START = 0x022C        ; User 12 - ADC0
                                 .equ EVSYS_USEREVSYSEVOUTA = 0x022D      ; User 13 - EVOUTA
                                 .equ EVSYS_USEREVSYSEVOUTB = 0x022E      ; User 14 - EVOUTB
                                 .equ EVSYS_USEREVSYSEVOUTC = 0x022F      ; User 15 - EVOUTC
                                 .equ EVSYS_USEREVSYSEVOUTD = 0x0230      ; User 16 - EVOUTD
                                 .equ EVSYS_USEREVSYSEVOUTE = 0x0231      ; User 17 - EVOUTE
                                 .equ EVSYS_USEREVSYSEVOUTF = 0x0232      ; User 18 - EVOUTF
                                 .equ EVSYS_USEREVSYSEVOUTG = 0x0233      ; User 19 - EVOUTG
                                 .equ EVSYS_USERUSART0IRDA = 0x0234       ; User 20 - USART0
                                 .equ EVSYS_USERUSART1IRDA = 0x0235       ; User 21 - USART1
                                 .equ EVSYS_USERUSART2IRDA = 0x0236       ; User 22 - USART2
                                 .equ EVSYS_USERUSART3IRDA = 0x0237       ; User 23 - USART3
                                 .equ EVSYS_USERUSART4IRDA = 0x0238       ; User 24 - USART4
                                 .equ EVSYS_USERUSART5IRDA = 0x0239       ; User 25 - USART5
                                 .equ EVSYS_USERTCA0CNTA = 0x023A         ; User 26 - TCA0 Event A
                                 .equ EVSYS_USERTCA0CNTB = 0x023B         ; User 27 - TCA0 Event B
                                 .equ EVSYS_USERTCA1CNTA = 0x023C         ; User 28 - TCA1 Event A
                                 .equ EVSYS_USERTCA1CNTB = 0x023D         ; User 29 - TCA1 Event B
                                 .equ EVSYS_USERTCB0CAPT = 0x023E         ; User 30 - TCB0 Event A
                                 .equ EVSYS_USERTCB0COUNT = 0x023F        ; User 31 - TCB0 Event B
                                 .equ EVSYS_USERTCB1CAPT = 0x0240         ; User 32 - TCB1 Event A
                                 .equ EVSYS_USERTCB1COUNT = 0x0241        ; User 33 - TCB1 Event B
                                 .equ EVSYS_USERTCB2CAPT = 0x0242         ; User 34 - TCB2 Event A
                                 .equ EVSYS_USERTCB2COUNT = 0x0243        ; User 35 - TCB2 Event B
                                 .equ EVSYS_USERTCB3CAPT = 0x0244         ; User 36 - TCB3 Event A
                                 .equ EVSYS_USERTCB3COUNT = 0x0245        ; User 37 - TCB3 Event B
                                 .equ EVSYS_USERTCB4CAPT = 0x0246         ; User 38 - TCB4 Event A
                                 .equ EVSYS_USERTCB4COUNT = 0x0247        ; User 39 - TCB4 Event B
                                 .equ EVSYS_USERTCD0INPUTA = 0x0248       ; User 40 - TCD0 Event A
                                 .equ EVSYS_USERTCD0INPUTB = 0x0249       ; User 41 - TCD0 Event B
                                 .equ EVSYS_USEROPAMP0ENABLE = 0x024A     ; User 42 - OPAMP0 Enable
                                 .equ EVSYS_USEROPAMP0DISABLE = 0x024B    ; User 43 - OPAMP0 Disable
                                 .equ EVSYS_USEROPAMP0DUMP = 0x024C       ; User 44 - OPAMP0 Dump
                                 .equ EVSYS_USEROPAMP0DRIVE = 0x024D      ; User 45 - OPAMP0 Drive
                                 .equ EVSYS_USEROPAMP1ENABLE = 0x024E     ; User 46 - OPAMP1 Enable
                                 .equ EVSYS_USEROPAMP1DISABLE = 0x024F    ; User 47 - OPAMP1 Disable
                                 .equ EVSYS_USEROPAMP1DUMP = 0x0250       ; User 48 - OPAMP1 Dump
                                 .equ EVSYS_USEROPAMP1DRIVE = 0x0251      ; User 49 - OPAMP1 Drive
                                 .equ EVSYS_USEROPAMP2ENABLE = 0x0252     ; User 50 - OPAMP2 Enable
                                 .equ EVSYS_USEROPAMP2DISABLE = 0x0253    ; User 51 - OPAMP2 Disable
                                 .equ EVSYS_USEROPAMP2DUMP = 0x0254       ; User 52 - OPAMP2 Dump
                                 .equ EVSYS_USEROPAMP2DRIVE = 0x0255      ; User 53 - OPAMP2 Drive
                                 
                                 ;*************************************************************************
                                 ;** FUSE - Fuses
                                 ;*************************************************************************
                                 
                                 .equ FUSE_WDTCFG = 0x1050                ; Watchdog Configuration
                                 .equ FUSE_BODCFG = 0x1051                ; BOD Configuration
                                 .equ FUSE_OSCCFG = 0x1052                ; Oscillator Configuration
                                 .equ FUSE_SYSCFG0 = 0x1055               ; System Configuration 0
                                 .equ FUSE_SYSCFG1 = 0x1056               ; System Configuration 1
                                 .equ FUSE_CODESIZE = 0x1057              ; Code Section Size
                                 .equ FUSE_BOOTSIZE = 0x1058              ; Boot Section Size
                                 
                                 ;*************************************************************************
                                 ;** GPR - General Purpose Registers
                                 ;*************************************************************************
                                 
                                 .equ GPR_GPR0 = 0x001C                   ; General Purpose Register 0
                                 .equ GPR_GPR1 = 0x001D                   ; General Purpose Register 1
                                 .equ GPR_GPR2 = 0x001E                   ; General Purpose Register 2
                                 .equ GPR_GPR3 = 0x001F                   ; General Purpose Register 3
                                 
                                 ;*************************************************************************
                                 ;** LOCK - Lockbits
                                 ;*************************************************************************
                                 
                                 .equ LOCK_KEY = 0x1040                   ; Lock Key Bits
                                 .equ LOCK_KEY0 = 0x1040                  ; Lock Key Bits 0
                                 .equ LOCK_KEY1 = 0x1041                  ; Lock Key Bits 1
                                 .equ LOCK_KEY2 = 0x1042                  ; Lock Key Bits 2
                                 .equ LOCK_KEY3 = 0x1043                  ; Lock Key Bits 3
                                 
                                 ;*************************************************************************
                                 ;** MVIO - Multi-Voltage I/O
                                 ;*************************************************************************
                                 
                                 .equ MVIO_INTCTRL = 0x00C0               ; Interrupt Control
                                 .equ MVIO_INTFLAGS = 0x00C1              ; Interrupt Flags
                                 .equ MVIO_STATUS = 0x00C2                ; Status
                                 
                                 ;*************************************************************************
                                 ;** NVMCTRL - Non-volatile Memory Controller
                                 ;*************************************************************************
                                 
                                 .equ NVMCTRL_CTRLA = 0x1000              ; Control A
                                 .equ NVMCTRL_CTRLB = 0x1001              ; Control B
                                 .equ NVMCTRL_STATUS = 0x1002             ; Status
                                 .equ NVMCTRL_INTCTRL = 0x1003            ; Interrupt Control
                                 .equ NVMCTRL_INTFLAGS = 0x1004           ; Interrupt Flags
                                 .equ NVMCTRL_DATA = 0x1006               ; Data
                                 .equ NVMCTRL_DATAL = 0x1006              ; Data low byte
                                 .equ NVMCTRL_DATAH = 0x1007              ; Data hi byte
                                 .equ NVMCTRL_ADDR = 0x1008               ; Address
                                 .equ NVMCTRL_ADDR0 = 0x1008              ; Address 0
                                 .equ NVMCTRL_ADDR1 = 0x1009              ; Address 1
                                 .equ NVMCTRL_ADDR2 = 0x100A              ; Address 2
                                 .equ NVMCTRL_ADDR3 = 0x100B              ; Address 3
                                 
                                 ;*************************************************************************
                                 ;** OPAMP - Operational Amplifier System
                                 ;*************************************************************************
                                 
                                 .equ OPAMP_CTRLA = 0x0700                ; Control A
                                 .equ OPAMP_DBGCTRL = 0x0701              ; Debug Control
                                 .equ OPAMP_TIMEBASE = 0x0702             ; Timebase Value
                                 .equ OPAMP_PWRCTRL = 0x070F              ; Power Control
                                 .equ OPAMP_OP0CTRLA = 0x0710             ; Op Amp 0 Control A
                                 .equ OPAMP_OP0STATUS = 0x0711            ; Op Amp 0 Status
                                 .equ OPAMP_OP0RESMUX = 0x0712            ; Op Amp 0 Resistor Ladder Multiplexer
                                 .equ OPAMP_OP0INMUX = 0x0713             ; Op Amp 0 Input Multiplexer
                                 .equ OPAMP_OP0SETTLE = 0x0714            ; Op Amp 0 Settle
                                 .equ OPAMP_OP0CAL = 0x0715               ; Op Amp 0 Calibration
                                 .equ OPAMP_OP1CTRLA = 0x0718             ; Op Amp 1 Control A
                                 .equ OPAMP_OP1STATUS = 0x0719            ; Op Amp 1 Status
                                 .equ OPAMP_OP1RESMUX = 0x071A            ; Op Amp 1 Resistor Ladder Multiplexer
                                 .equ OPAMP_OP1INMUX = 0x071B             ; Op Amp 1 Input Multiplexer
                                 .equ OPAMP_OP1SETTLE = 0x071C            ; Op Amp 1 Settle
                                 .equ OPAMP_OP1CAL = 0x071D               ; Op Amp 1 Calibration
                                 .equ OPAMP_OP2CTRLA = 0x0720             ; Op Amp 2 Control A
                                 .equ OPAMP_OP2STATUS = 0x0721            ; Op Amp 2 Status
                                 .equ OPAMP_OP2RESMUX = 0x0722            ; Op Amp 2 Resistor Ladder Multiplexer
                                 .equ OPAMP_OP2INMUX = 0x0723             ; Op Amp 2 Input Multiplexer
                                 .equ OPAMP_OP2SETTLE = 0x0724            ; Op Amp 2 Settle
                                 .equ OPAMP_OP2CAL = 0x0725               ; Op Amp 2 Calibration
                                 
                                 ;*************************************************************************
                                 ;** PORTA - I/O Ports
                                 ;*************************************************************************
                                 
                                 .equ PORTA_DIR = 0x0400                  ; Data Direction
                                 .equ PORTA_DIRSET = 0x0401               ; Data Direction Set
                                 .equ PORTA_DIRCLR = 0x0402               ; Data Direction Clear
                                 .equ PORTA_DIRTGL = 0x0403               ; Data Direction Toggle
                                 .equ PORTA_OUT = 0x0404                  ; Output Value
                                 .equ PORTA_OUTSET = 0x0405               ; Output Value Set
                                 .equ PORTA_OUTCLR = 0x0406               ; Output Value Clear
                                 .equ PORTA_OUTTGL = 0x0407               ; Output Value Toggle
                                 .equ PORTA_IN = 0x0408                   ; Input Value
                                 .equ PORTA_INTFLAGS = 0x0409             ; Interrupt Flags
                                 .equ PORTA_PORTCTRL = 0x040A             ; Port Control
                                 .equ PORTA_PINCONFIG = 0x040B            ; Pin Control Config
                                 .equ PORTA_PINCTRLUPD = 0x040C           ; Pin Control Update
                                 .equ PORTA_PINCTRLSET = 0x040D           ; Pin Control Set
                                 .equ PORTA_PINCTRLCLR = 0x040E           ; Pin Control Clear
                                 .equ PORTA_PIN0CTRL = 0x0410             ; Pin 0 Control
                                 .equ PORTA_PIN1CTRL = 0x0411             ; Pin 1 Control
                                 .equ PORTA_PIN2CTRL = 0x0412             ; Pin 2 Control
                                 .equ PORTA_PIN3CTRL = 0x0413             ; Pin 3 Control
                                 .equ PORTA_PIN4CTRL = 0x0414             ; Pin 4 Control
                                 .equ PORTA_PIN5CTRL = 0x0415             ; Pin 5 Control
                                 .equ PORTA_PIN6CTRL = 0x0416             ; Pin 6 Control
                                 .equ PORTA_PIN7CTRL = 0x0417             ; Pin 7 Control
                                 
                                 ;*************************************************************************
                                 ;** PORTB - I/O Ports
                                 ;*************************************************************************
                                 
                                 .equ PORTB_DIR = 0x0420                  ; Data Direction
                                 .equ PORTB_DIRSET = 0x0421               ; Data Direction Set
                                 .equ PORTB_DIRCLR = 0x0422               ; Data Direction Clear
                                 .equ PORTB_DIRTGL = 0x0423               ; Data Direction Toggle
                                 .equ PORTB_OUT = 0x0424                  ; Output Value
                                 .equ PORTB_OUTSET = 0x0425               ; Output Value Set
                                 .equ PORTB_OUTCLR = 0x0426               ; Output Value Clear
                                 .equ PORTB_OUTTGL = 0x0427               ; Output Value Toggle
                                 .equ PORTB_IN = 0x0428                   ; Input Value
                                 .equ PORTB_INTFLAGS = 0x0429             ; Interrupt Flags
                                 .equ PORTB_PORTCTRL = 0x042A             ; Port Control
                                 .equ PORTB_PINCONFIG = 0x042B            ; Pin Control Config
                                 .equ PORTB_PINCTRLUPD = 0x042C           ; Pin Control Update
                                 .equ PORTB_PINCTRLSET = 0x042D           ; Pin Control Set
                                 .equ PORTB_PINCTRLCLR = 0x042E           ; Pin Control Clear
                                 .equ PORTB_PIN0CTRL = 0x0430             ; Pin 0 Control
                                 .equ PORTB_PIN1CTRL = 0x0431             ; Pin 1 Control
                                 .equ PORTB_PIN2CTRL = 0x0432             ; Pin 2 Control
                                 .equ PORTB_PIN3CTRL = 0x0433             ; Pin 3 Control
                                 .equ PORTB_PIN4CTRL = 0x0434             ; Pin 4 Control
                                 .equ PORTB_PIN5CTRL = 0x0435             ; Pin 5 Control
                                 .equ PORTB_PIN6CTRL = 0x0436             ; Pin 6 Control
                                 .equ PORTB_PIN7CTRL = 0x0437             ; Pin 7 Control
                                 
                                 ;*************************************************************************
                                 ;** PORTC - I/O Ports
                                 ;*************************************************************************
                                 
                                 .equ PORTC_DIR = 0x0440                  ; Data Direction
                                 .equ PORTC_DIRSET = 0x0441               ; Data Direction Set
                                 .equ PORTC_DIRCLR = 0x0442               ; Data Direction Clear
                                 .equ PORTC_DIRTGL = 0x0443               ; Data Direction Toggle
                                 .equ PORTC_OUT = 0x0444                  ; Output Value
                                 .equ PORTC_OUTSET = 0x0445               ; Output Value Set
                                 .equ PORTC_OUTCLR = 0x0446               ; Output Value Clear
                                 .equ PORTC_OUTTGL = 0x0447               ; Output Value Toggle
                                 .equ PORTC_IN = 0x0448                   ; Input Value
                                 .equ PORTC_INTFLAGS = 0x0449             ; Interrupt Flags
                                 .equ PORTC_PORTCTRL = 0x044A             ; Port Control
                                 .equ PORTC_PINCONFIG = 0x044B            ; Pin Control Config
                                 .equ PORTC_PINCTRLUPD = 0x044C           ; Pin Control Update
                                 .equ PORTC_PINCTRLSET = 0x044D           ; Pin Control Set
                                 .equ PORTC_PINCTRLCLR = 0x044E           ; Pin Control Clear
                                 .equ PORTC_PIN0CTRL = 0x0450             ; Pin 0 Control
                                 .equ PORTC_PIN1CTRL = 0x0451             ; Pin 1 Control
                                 .equ PORTC_PIN2CTRL = 0x0452             ; Pin 2 Control
                                 .equ PORTC_PIN3CTRL = 0x0453             ; Pin 3 Control
                                 .equ PORTC_PIN4CTRL = 0x0454             ; Pin 4 Control
                                 .equ PORTC_PIN5CTRL = 0x0455             ; Pin 5 Control
                                 .equ PORTC_PIN6CTRL = 0x0456             ; Pin 6 Control
                                 .equ PORTC_PIN7CTRL = 0x0457             ; Pin 7 Control
                                 
                                 ;*************************************************************************
                                 ;** PORTD - I/O Ports
                                 ;*************************************************************************
                                 
                                 .equ PORTD_DIR = 0x0460                  ; Data Direction
                                 .equ PORTD_DIRSET = 0x0461               ; Data Direction Set
                                 .equ PORTD_DIRCLR = 0x0462               ; Data Direction Clear
                                 .equ PORTD_DIRTGL = 0x0463               ; Data Direction Toggle
                                 .equ PORTD_OUT = 0x0464                  ; Output Value
                                 .equ PORTD_OUTSET = 0x0465               ; Output Value Set
                                 .equ PORTD_OUTCLR = 0x0466               ; Output Value Clear
                                 .equ PORTD_OUTTGL = 0x0467               ; Output Value Toggle
                                 .equ PORTD_IN = 0x0468                   ; Input Value
                                 .equ PORTD_INTFLAGS = 0x0469             ; Interrupt Flags
                                 .equ PORTD_PORTCTRL = 0x046A             ; Port Control
                                 .equ PORTD_PINCONFIG = 0x046B            ; Pin Control Config
                                 .equ PORTD_PINCTRLUPD = 0x046C           ; Pin Control Update
                                 .equ PORTD_PINCTRLSET = 0x046D           ; Pin Control Set
                                 .equ PORTD_PINCTRLCLR = 0x046E           ; Pin Control Clear
                                 .equ PORTD_PIN0CTRL = 0x0470             ; Pin 0 Control
                                 .equ PORTD_PIN1CTRL = 0x0471             ; Pin 1 Control
                                 .equ PORTD_PIN2CTRL = 0x0472             ; Pin 2 Control
                                 .equ PORTD_PIN3CTRL = 0x0473             ; Pin 3 Control
                                 .equ PORTD_PIN4CTRL = 0x0474             ; Pin 4 Control
                                 .equ PORTD_PIN5CTRL = 0x0475             ; Pin 5 Control
                                 .equ PORTD_PIN6CTRL = 0x0476             ; Pin 6 Control
                                 .equ PORTD_PIN7CTRL = 0x0477             ; Pin 7 Control
                                 
                                 ;*************************************************************************
                                 ;** PORTE - I/O Ports
                                 ;*************************************************************************
                                 
                                 .equ PORTE_DIR = 0x0480                  ; Data Direction
                                 .equ PORTE_DIRSET = 0x0481               ; Data Direction Set
                                 .equ PORTE_DIRCLR = 0x0482               ; Data Direction Clear
                                 .equ PORTE_DIRTGL = 0x0483               ; Data Direction Toggle
                                 .equ PORTE_OUT = 0x0484                  ; Output Value
                                 .equ PORTE_OUTSET = 0x0485               ; Output Value Set
                                 .equ PORTE_OUTCLR = 0x0486               ; Output Value Clear
                                 .equ PORTE_OUTTGL = 0x0487               ; Output Value Toggle
                                 .equ PORTE_IN = 0x0488                   ; Input Value
                                 .equ PORTE_INTFLAGS = 0x0489             ; Interrupt Flags
                                 .equ PORTE_PORTCTRL = 0x048A             ; Port Control
                                 .equ PORTE_PINCONFIG = 0x048B            ; Pin Control Config
                                 .equ PORTE_PINCTRLUPD = 0x048C           ; Pin Control Update
                                 .equ PORTE_PINCTRLSET = 0x048D           ; Pin Control Set
                                 .equ PORTE_PINCTRLCLR = 0x048E           ; Pin Control Clear
                                 .equ PORTE_PIN0CTRL = 0x0490             ; Pin 0 Control
                                 .equ PORTE_PIN1CTRL = 0x0491             ; Pin 1 Control
                                 .equ PORTE_PIN2CTRL = 0x0492             ; Pin 2 Control
                                 .equ PORTE_PIN3CTRL = 0x0493             ; Pin 3 Control
                                 .equ PORTE_PIN4CTRL = 0x0494             ; Pin 4 Control
                                 .equ PORTE_PIN5CTRL = 0x0495             ; Pin 5 Control
                                 .equ PORTE_PIN6CTRL = 0x0496             ; Pin 6 Control
                                 .equ PORTE_PIN7CTRL = 0x0497             ; Pin 7 Control
                                 
                                 ;*************************************************************************
                                 ;** PORTF - I/O Ports
                                 ;*************************************************************************
                                 
                                 .equ PORTF_DIR = 0x04A0                  ; Data Direction
                                 .equ PORTF_DIRSET = 0x04A1               ; Data Direction Set
                                 .equ PORTF_DIRCLR = 0x04A2               ; Data Direction Clear
                                 .equ PORTF_DIRTGL = 0x04A3               ; Data Direction Toggle
                                 .equ PORTF_OUT = 0x04A4                  ; Output Value
                                 .equ PORTF_OUTSET = 0x04A5               ; Output Value Set
                                 .equ PORTF_OUTCLR = 0x04A6               ; Output Value Clear
                                 .equ PORTF_OUTTGL = 0x04A7               ; Output Value Toggle
                                 .equ PORTF_IN = 0x04A8                   ; Input Value
                                 .equ PORTF_INTFLAGS = 0x04A9             ; Interrupt Flags
                                 .equ PORTF_PORTCTRL = 0x04AA             ; Port Control
                                 .equ PORTF_PINCONFIG = 0x04AB            ; Pin Control Config
                                 .equ PORTF_PINCTRLUPD = 0x04AC           ; Pin Control Update
                                 .equ PORTF_PINCTRLSET = 0x04AD           ; Pin Control Set
                                 .equ PORTF_PINCTRLCLR = 0x04AE           ; Pin Control Clear
                                 .equ PORTF_PIN0CTRL = 0x04B0             ; Pin 0 Control
                                 .equ PORTF_PIN1CTRL = 0x04B1             ; Pin 1 Control
                                 .equ PORTF_PIN2CTRL = 0x04B2             ; Pin 2 Control
                                 .equ PORTF_PIN3CTRL = 0x04B3             ; Pin 3 Control
                                 .equ PORTF_PIN4CTRL = 0x04B4             ; Pin 4 Control
                                 .equ PORTF_PIN5CTRL = 0x04B5             ; Pin 5 Control
                                 .equ PORTF_PIN6CTRL = 0x04B6             ; Pin 6 Control
                                 .equ PORTF_PIN7CTRL = 0x04B7             ; Pin 7 Control
                                 
                                 ;*************************************************************************
                                 ;** PORTG - I/O Ports
                                 ;*************************************************************************
                                 
                                 .equ PORTG_DIR = 0x04C0                  ; Data Direction
                                 .equ PORTG_DIRSET = 0x04C1               ; Data Direction Set
                                 .equ PORTG_DIRCLR = 0x04C2               ; Data Direction Clear
                                 .equ PORTG_DIRTGL = 0x04C3               ; Data Direction Toggle
                                 .equ PORTG_OUT = 0x04C4                  ; Output Value
                                 .equ PORTG_OUTSET = 0x04C5               ; Output Value Set
                                 .equ PORTG_OUTCLR = 0x04C6               ; Output Value Clear
                                 .equ PORTG_OUTTGL = 0x04C7               ; Output Value Toggle
                                 .equ PORTG_IN = 0x04C8                   ; Input Value
                                 .equ PORTG_INTFLAGS = 0x04C9             ; Interrupt Flags
                                 .equ PORTG_PORTCTRL = 0x04CA             ; Port Control
                                 .equ PORTG_PINCONFIG = 0x04CB            ; Pin Control Config
                                 .equ PORTG_PINCTRLUPD = 0x04CC           ; Pin Control Update
                                 .equ PORTG_PINCTRLSET = 0x04CD           ; Pin Control Set
                                 .equ PORTG_PINCTRLCLR = 0x04CE           ; Pin Control Clear
                                 .equ PORTG_PIN0CTRL = 0x04D0             ; Pin 0 Control
                                 .equ PORTG_PIN1CTRL = 0x04D1             ; Pin 1 Control
                                 .equ PORTG_PIN2CTRL = 0x04D2             ; Pin 2 Control
                                 .equ PORTG_PIN3CTRL = 0x04D3             ; Pin 3 Control
                                 .equ PORTG_PIN4CTRL = 0x04D4             ; Pin 4 Control
                                 .equ PORTG_PIN5CTRL = 0x04D5             ; Pin 5 Control
                                 .equ PORTG_PIN6CTRL = 0x04D6             ; Pin 6 Control
                                 .equ PORTG_PIN7CTRL = 0x04D7             ; Pin 7 Control
                                 
                                 ;*************************************************************************
                                 ;** PORTMUX - Port Multiplexer
                                 ;*************************************************************************
                                 
                                 .equ PORTMUX_EVSYSROUTEA = 0x05E0        ; EVSYS route A
                                 .equ PORTMUX_CCLROUTEA = 0x05E1          ; CCL route A
                                 .equ PORTMUX_USARTROUTEA = 0x05E2        ; USART route A
                                 .equ PORTMUX_USARTROUTEB = 0x05E3        ; USART route B
                                 .equ PORTMUX_SPIROUTEA = 0x05E4          ; SPI route A
                                 .equ PORTMUX_TWIROUTEA = 0x05E5          ; TWI route A
                                 .equ PORTMUX_TCAROUTEA = 0x05E6          ; TCA route A
                                 .equ PORTMUX_TCBROUTEA = 0x05E7          ; TCB route A
                                 .equ PORTMUX_TCDROUTEA = 0x05E8          ; TCD route A
                                 .equ PORTMUX_ACROUTEA = 0x05E9           ; AC route A
                                 .equ PORTMUX_ZCDROUTEA = 0x05EA          ; ZCD route A
                                 
                                 ;*************************************************************************
                                 ;** RSTCTRL - Reset controller
                                 ;*************************************************************************
                                 
                                 .equ RSTCTRL_RSTFR = 0x0040              ; Reset Flags
                                 .equ RSTCTRL_SWRR = 0x0041               ; Software Reset
                                 
                                 ;*************************************************************************
                                 ;** RTC - Real-Time Counter
                                 ;*************************************************************************
                                 
                                 .equ RTC_CTRLA = 0x0140                  ; Control A
                                 .equ RTC_STATUS = 0x0141                 ; Status
                                 .equ RTC_INTCTRL = 0x0142                ; Interrupt Control
                                 .equ RTC_INTFLAGS = 0x0143               ; Interrupt Flags
                                 .equ RTC_TEMP = 0x0144                   ; Temporary
                                 .equ RTC_DBGCTRL = 0x0145                ; Debug control
                                 .equ RTC_CALIB = 0x0146                  ; Calibration
                                 .equ RTC_CLKSEL = 0x0147                 ; Clock Select
                                 .equ RTC_CNT = 0x0148                    ; Counter
                                 .equ RTC_CNTL = 0x0148                   ; Counter low byte
                                 .equ RTC_CNTH = 0x0149                   ; Counter hi byte
                                 .equ RTC_PER = 0x014A                    ; Period
                                 .equ RTC_PERL = 0x014A                   ; Period low byte
                                 .equ RTC_PERH = 0x014B                   ; Period hi byte
                                 .equ RTC_CMP = 0x014C                    ; Compare
                                 .equ RTC_CMPL = 0x014C                   ; Compare low byte
                                 .equ RTC_CMPH = 0x014D                   ; Compare hi byte
                                 .equ RTC_PITCTRLA = 0x0150               ; PIT Control A
                                 .equ RTC_PITSTATUS = 0x0151              ; PIT Status
                                 .equ RTC_PITINTCTRL = 0x0152             ; PIT Interrupt Control
                                 .equ RTC_PITINTFLAGS = 0x0153            ; PIT Interrupt Flags
                                 .equ RTC_PITDBGCTRL = 0x0155             ; PIT Debug control
                                 
                                 ;*************************************************************************
                                 ;** SIGROW - Signature row
                                 ;*************************************************************************
                                 
                                 .equ SIGROW_DEVICEID0 = 0x1100           ; Device ID Byte 0
                                 .equ SIGROW_DEVICEID1 = 0x1101           ; Device ID Byte 1
                                 .equ SIGROW_DEVICEID2 = 0x1102           ; Device ID Byte 2
                                 .equ SIGROW_TEMPSENSE0 = 0x1104          ; Temperature Calibration 0
                                 .equ SIGROW_TEMPSENSE0L = 0x1104         ; Temperature Calibration 0 low byte
                                 .equ SIGROW_TEMPSENSE0H = 0x1105         ; Temperature Calibration 0 hi byte
                                 .equ SIGROW_TEMPSENSE1 = 0x1106          ; Temperature Calibration 1
                                 .equ SIGROW_TEMPSENSE1L = 0x1106         ; Temperature Calibration 1 low byte
                                 .equ SIGROW_TEMPSENSE1H = 0x1107         ; Temperature Calibration 1 hi byte
                                 .equ SIGROW_SERNUM0 = 0x1110             ; LOTNUM0
                                 .equ SIGROW_SERNUM1 = 0x1111             ; LOTNUM1
                                 .equ SIGROW_SERNUM2 = 0x1112             ; LOTNUM2
                                 .equ SIGROW_SERNUM3 = 0x1113             ; LOTNUM3
                                 .equ SIGROW_SERNUM4 = 0x1114             ; LOTNUM4
                                 .equ SIGROW_SERNUM5 = 0x1115             ; LOTNUM5
                                 .equ SIGROW_SERNUM6 = 0x1116             ; RANDOM
                                 .equ SIGROW_SERNUM7 = 0x1117             ; SCRIBE
                                 .equ SIGROW_SERNUM8 = 0x1118             ; XPOS0
                                 .equ SIGROW_SERNUM9 = 0x1119             ; XPOS1
                                 .equ SIGROW_SERNUM10 = 0x111A            ; YPOS0
                                 .equ SIGROW_SERNUM11 = 0x111B            ; YPOS1
                                 .equ SIGROW_SERNUM12 = 0x111C            ; RES0
                                 .equ SIGROW_SERNUM13 = 0x111D            ; RES1
                                 .equ SIGROW_SERNUM14 = 0x111E            ; RES2
                                 .equ SIGROW_SERNUM15 = 0x111F            ; RES3
                                 
                                 ;*************************************************************************
                                 ;** SLPCTRL - Sleep Controller
                                 ;*************************************************************************
                                 
                                 .equ SLPCTRL_CTRLA = 0x0050              ; Control A
                                 .equ SLPCTRL_VREGCTRL = 0x0051           ; Control B
                                 
                                 ;*************************************************************************
                                 ;** SPI0 - Serial Peripheral Interface
                                 ;*************************************************************************
                                 
                                 .equ SPI0_CTRLA = 0x0940                 ; Control A
                                 .equ SPI0_CTRLB = 0x0941                 ; Control B
                                 .equ SPI0_INTCTRL = 0x0942               ; Interrupt Control
                                 .equ SPI0_INTFLAGS = 0x0943              ; Interrupt Flags
                                 .equ SPI0_DATA = 0x0944                  ; Data
                                 
                                 ;*************************************************************************
                                 ;** SPI1 - Serial Peripheral Interface
                                 ;*************************************************************************
                                 
                                 .equ SPI1_CTRLA = 0x0960                 ; Control A
                                 .equ SPI1_CTRLB = 0x0961                 ; Control B
                                 .equ SPI1_INTCTRL = 0x0962               ; Interrupt Control
                                 .equ SPI1_INTFLAGS = 0x0963              ; Interrupt Flags
                                 .equ SPI1_DATA = 0x0964                  ; Data
                                 
                                 ;*************************************************************************
                                 ;** SYSCFG - System Configuration Registers
                                 ;*************************************************************************
                                 
                                 .equ SYSCFG_REVID = 0x0F01               ; Revision ID
                                 .equ SYSCFG_OCDMCTRL = 0x0F18            ; OCD Message Control
                                 .equ SYSCFG_OCDMSTATUS = 0x0F19          ; OCD Message Status
                                 
                                 ;*************************************************************************
                                 ;** TCA0 - 16-bit Timer/Counter Type A
                                 ;*************************************************************************
                                 
                                 .equ TCA0_SINGLE_CTRLA = 0x0A00          ; Control A
                                 .equ TCA0_SINGLE_CTRLB = 0x0A01          ; Control B
                                 .equ TCA0_SINGLE_CTRLC = 0x0A02          ; Control C
                                 .equ TCA0_SINGLE_CTRLD = 0x0A03          ; Control D
                                 .equ TCA0_SINGLE_CTRLECLR = 0x0A04       ; Control E Clear
                                 .equ TCA0_SINGLE_CTRLESET = 0x0A05       ; Control E Set
                                 .equ TCA0_SINGLE_CTRLFCLR = 0x0A06       ; Control F Clear
                                 .equ TCA0_SINGLE_CTRLFSET = 0x0A07       ; Control F Set
                                 .equ TCA0_SINGLE_EVCTRL = 0x0A09         ; Event Control
                                 .equ TCA0_SINGLE_INTCTRL = 0x0A0A        ; Interrupt Control
                                 .equ TCA0_SINGLE_INTFLAGS = 0x0A0B       ; Interrupt Flags
                                 .equ TCA0_SINGLE_DBGCTRL = 0x0A0E        ; Degbug Control
                                 .equ TCA0_SINGLE_TEMP = 0x0A0F           ; Temporary data for 16-bit Access
                                 .equ TCA0_SINGLE_CNT = 0x0A20            ; Count
                                 .equ TCA0_SINGLE_CNTL = 0x0A20           ; Count low byte
                                 .equ TCA0_SINGLE_CNTH = 0x0A21           ; Count hi byte
                                 .equ TCA0_SINGLE_PER = 0x0A26            ; Period
                                 .equ TCA0_SINGLE_PERL = 0x0A26           ; Period low byte
                                 .equ TCA0_SINGLE_PERH = 0x0A27           ; Period hi byte
                                 .equ TCA0_SINGLE_CMP0 = 0x0A28           ; Compare 0
                                 .equ TCA0_SINGLE_CMP0L = 0x0A28          ; Compare 0 low byte
                                 .equ TCA0_SINGLE_CMP0H = 0x0A29          ; Compare 0 hi byte
                                 .equ TCA0_SINGLE_CMP1 = 0x0A2A           ; Compare 1
                                 .equ TCA0_SINGLE_CMP1L = 0x0A2A          ; Compare 1 low byte
                                 .equ TCA0_SINGLE_CMP1H = 0x0A2B          ; Compare 1 hi byte
                                 .equ TCA0_SINGLE_CMP2 = 0x0A2C           ; Compare 2
                                 .equ TCA0_SINGLE_CMP2L = 0x0A2C          ; Compare 2 low byte
                                 .equ TCA0_SINGLE_CMP2H = 0x0A2D          ; Compare 2 hi byte
                                 .equ TCA0_SINGLE_PERBUF = 0x0A36         ; Period Buffer
                                 .equ TCA0_SINGLE_PERBUFL = 0x0A36        ; Period Buffer low byte
                                 .equ TCA0_SINGLE_PERBUFH = 0x0A37        ; Period Buffer hi byte
                                 .equ TCA0_SINGLE_CMP0BUF = 0x0A38        ; Compare 0 Buffer
                                 .equ TCA0_SINGLE_CMP0BUFL = 0x0A38       ; Compare 0 Buffer low byte
                                 .equ TCA0_SINGLE_CMP0BUFH = 0x0A39       ; Compare 0 Buffer hi byte
                                 .equ TCA0_SINGLE_CMP1BUF = 0x0A3A        ; Compare 1 Buffer
                                 .equ TCA0_SINGLE_CMP1BUFL = 0x0A3A       ; Compare 1 Buffer low byte
                                 .equ TCA0_SINGLE_CMP1BUFH = 0x0A3B       ; Compare 1 Buffer hi byte
                                 .equ TCA0_SINGLE_CMP2BUF = 0x0A3C        ; Compare 2 Buffer
                                 .equ TCA0_SINGLE_CMP2BUFL = 0x0A3C       ; Compare 2 Buffer low byte
                                 .equ TCA0_SINGLE_CMP2BUFH = 0x0A3D       ; Compare 2 Buffer hi byte
                                 .equ TCA0_SPLIT_CTRLA = 0x0A00           ; Control A
                                 .equ TCA0_SPLIT_CTRLB = 0x0A01           ; Control B
                                 .equ TCA0_SPLIT_CTRLC = 0x0A02           ; Control C
                                 .equ TCA0_SPLIT_CTRLD = 0x0A03           ; Control D
                                 .equ TCA0_SPLIT_CTRLECLR = 0x0A04        ; Control E Clear
                                 .equ TCA0_SPLIT_CTRLESET = 0x0A05        ; Control E Set
                                 .equ TCA0_SPLIT_INTCTRL = 0x0A0A         ; Interrupt Control
                                 .equ TCA0_SPLIT_INTFLAGS = 0x0A0B        ; Interrupt Flags
                                 .equ TCA0_SPLIT_DBGCTRL = 0x0A0E         ; Degbug Control
                                 .equ TCA0_SPLIT_LCNT = 0x0A20            ; Low Count
                                 .equ TCA0_SPLIT_HCNT = 0x0A21            ; High Count
                                 .equ TCA0_SPLIT_LPER = 0x0A26            ; Low Period
                                 .equ TCA0_SPLIT_HPER = 0x0A27            ; High Period
                                 .equ TCA0_SPLIT_LCMP0 = 0x0A28           ; Low Compare
                                 .equ TCA0_SPLIT_HCMP0 = 0x0A29           ; High Compare
                                 .equ TCA0_SPLIT_LCMP1 = 0x0A2A           ; Low Compare
                                 .equ TCA0_SPLIT_HCMP1 = 0x0A2B           ; High Compare
                                 .equ TCA0_SPLIT_LCMP2 = 0x0A2C           ; Low Compare
                                 .equ TCA0_SPLIT_HCMP2 = 0x0A2D           ; High Compare
                                 
                                 ;*************************************************************************
                                 ;** TCA1 - 16-bit Timer/Counter Type A
                                 ;*************************************************************************
                                 
                                 .equ TCA1_SINGLE_CTRLA = 0x0A40          ; Control A
                                 .equ TCA1_SINGLE_CTRLB = 0x0A41          ; Control B
                                 .equ TCA1_SINGLE_CTRLC = 0x0A42          ; Control C
                                 .equ TCA1_SINGLE_CTRLD = 0x0A43          ; Control D
                                 .equ TCA1_SINGLE_CTRLECLR = 0x0A44       ; Control E Clear
                                 .equ TCA1_SINGLE_CTRLESET = 0x0A45       ; Control E Set
                                 .equ TCA1_SINGLE_CTRLFCLR = 0x0A46       ; Control F Clear
                                 .equ TCA1_SINGLE_CTRLFSET = 0x0A47       ; Control F Set
                                 .equ TCA1_SINGLE_EVCTRL = 0x0A49         ; Event Control
                                 .equ TCA1_SINGLE_INTCTRL = 0x0A4A        ; Interrupt Control
                                 .equ TCA1_SINGLE_INTFLAGS = 0x0A4B       ; Interrupt Flags
                                 .equ TCA1_SINGLE_DBGCTRL = 0x0A4E        ; Degbug Control
                                 .equ TCA1_SINGLE_TEMP = 0x0A4F           ; Temporary data for 16-bit Access
                                 .equ TCA1_SINGLE_CNT = 0x0A60            ; Count
                                 .equ TCA1_SINGLE_CNTL = 0x0A60           ; Count low byte
                                 .equ TCA1_SINGLE_CNTH = 0x0A61           ; Count hi byte
                                 .equ TCA1_SINGLE_PER = 0x0A66            ; Period
                                 .equ TCA1_SINGLE_PERL = 0x0A66           ; Period low byte
                                 .equ TCA1_SINGLE_PERH = 0x0A67           ; Period hi byte
                                 .equ TCA1_SINGLE_CMP0 = 0x0A68           ; Compare 0
                                 .equ TCA1_SINGLE_CMP0L = 0x0A68          ; Compare 0 low byte
                                 .equ TCA1_SINGLE_CMP0H = 0x0A69          ; Compare 0 hi byte
                                 .equ TCA1_SINGLE_CMP1 = 0x0A6A           ; Compare 1
                                 .equ TCA1_SINGLE_CMP1L = 0x0A6A          ; Compare 1 low byte
                                 .equ TCA1_SINGLE_CMP1H = 0x0A6B          ; Compare 1 hi byte
                                 .equ TCA1_SINGLE_CMP2 = 0x0A6C           ; Compare 2
                                 .equ TCA1_SINGLE_CMP2L = 0x0A6C          ; Compare 2 low byte
                                 .equ TCA1_SINGLE_CMP2H = 0x0A6D          ; Compare 2 hi byte
                                 .equ TCA1_SINGLE_PERBUF = 0x0A76         ; Period Buffer
                                 .equ TCA1_SINGLE_PERBUFL = 0x0A76        ; Period Buffer low byte
                                 .equ TCA1_SINGLE_PERBUFH = 0x0A77        ; Period Buffer hi byte
                                 .equ TCA1_SINGLE_CMP0BUF = 0x0A78        ; Compare 0 Buffer
                                 .equ TCA1_SINGLE_CMP0BUFL = 0x0A78       ; Compare 0 Buffer low byte
                                 .equ TCA1_SINGLE_CMP0BUFH = 0x0A79       ; Compare 0 Buffer hi byte
                                 .equ TCA1_SINGLE_CMP1BUF = 0x0A7A        ; Compare 1 Buffer
                                 .equ TCA1_SINGLE_CMP1BUFL = 0x0A7A       ; Compare 1 Buffer low byte
                                 .equ TCA1_SINGLE_CMP1BUFH = 0x0A7B       ; Compare 1 Buffer hi byte
                                 .equ TCA1_SINGLE_CMP2BUF = 0x0A7C        ; Compare 2 Buffer
                                 .equ TCA1_SINGLE_CMP2BUFL = 0x0A7C       ; Compare 2 Buffer low byte
                                 .equ TCA1_SINGLE_CMP2BUFH = 0x0A7D       ; Compare 2 Buffer hi byte
                                 .equ TCA1_SPLIT_CTRLA = 0x0A40           ; Control A
                                 .equ TCA1_SPLIT_CTRLB = 0x0A41           ; Control B
                                 .equ TCA1_SPLIT_CTRLC = 0x0A42           ; Control C
                                 .equ TCA1_SPLIT_CTRLD = 0x0A43           ; Control D
                                 .equ TCA1_SPLIT_CTRLECLR = 0x0A44        ; Control E Clear
                                 .equ TCA1_SPLIT_CTRLESET = 0x0A45        ; Control E Set
                                 .equ TCA1_SPLIT_INTCTRL = 0x0A4A         ; Interrupt Control
                                 .equ TCA1_SPLIT_INTFLAGS = 0x0A4B        ; Interrupt Flags
                                 .equ TCA1_SPLIT_DBGCTRL = 0x0A4E         ; Degbug Control
                                 .equ TCA1_SPLIT_LCNT = 0x0A60            ; Low Count
                                 .equ TCA1_SPLIT_HCNT = 0x0A61            ; High Count
                                 .equ TCA1_SPLIT_LPER = 0x0A66            ; Low Period
                                 .equ TCA1_SPLIT_HPER = 0x0A67            ; High Period
                                 .equ TCA1_SPLIT_LCMP0 = 0x0A68           ; Low Compare
                                 .equ TCA1_SPLIT_HCMP0 = 0x0A69           ; High Compare
                                 .equ TCA1_SPLIT_LCMP1 = 0x0A6A           ; Low Compare
                                 .equ TCA1_SPLIT_HCMP1 = 0x0A6B           ; High Compare
                                 .equ TCA1_SPLIT_LCMP2 = 0x0A6C           ; Low Compare
                                 .equ TCA1_SPLIT_HCMP2 = 0x0A6D           ; High Compare
                                 
                                 ;*************************************************************************
                                 ;** TCB0 - 16-bit Timer Type B
                                 ;*************************************************************************
                                 
                                 .equ TCB0_CTRLA = 0x0B00                 ; Control A
                                 .equ TCB0_CTRLB = 0x0B01                 ; Control Register B
                                 .equ TCB0_EVCTRL = 0x0B04                ; Event Control
                                 .equ TCB0_INTCTRL = 0x0B05               ; Interrupt Control
                                 .equ TCB0_INTFLAGS = 0x0B06              ; Interrupt Flags
                                 .equ TCB0_STATUS = 0x0B07                ; Status
                                 .equ TCB0_DBGCTRL = 0x0B08               ; Debug Control
                                 .equ TCB0_TEMP = 0x0B09                  ; Temporary Value
                                 .equ TCB0_CNT = 0x0B0A                   ; Count
                                 .equ TCB0_CNTL = 0x0B0A                  ; Count low byte
                                 .equ TCB0_CNTH = 0x0B0B                  ; Count hi byte
                                 .equ TCB0_CCMP = 0x0B0C                  ; Compare or Capture
                                 .equ TCB0_CCMPL = 0x0B0C                 ; Compare or Capture low byte
                                 .equ TCB0_CCMPH = 0x0B0D                 ; Compare or Capture hi byte
                                 
                                 ;*************************************************************************
                                 ;** TCB1 - 16-bit Timer Type B
                                 ;*************************************************************************
                                 
                                 .equ TCB1_CTRLA = 0x0B10                 ; Control A
                                 .equ TCB1_CTRLB = 0x0B11                 ; Control Register B
                                 .equ TCB1_EVCTRL = 0x0B14                ; Event Control
                                 .equ TCB1_INTCTRL = 0x0B15               ; Interrupt Control
                                 .equ TCB1_INTFLAGS = 0x0B16              ; Interrupt Flags
                                 .equ TCB1_STATUS = 0x0B17                ; Status
                                 .equ TCB1_DBGCTRL = 0x0B18               ; Debug Control
                                 .equ TCB1_TEMP = 0x0B19                  ; Temporary Value
                                 .equ TCB1_CNT = 0x0B1A                   ; Count
                                 .equ TCB1_CNTL = 0x0B1A                  ; Count low byte
                                 .equ TCB1_CNTH = 0x0B1B                  ; Count hi byte
                                 .equ TCB1_CCMP = 0x0B1C                  ; Compare or Capture
                                 .equ TCB1_CCMPL = 0x0B1C                 ; Compare or Capture low byte
                                 .equ TCB1_CCMPH = 0x0B1D                 ; Compare or Capture hi byte
                                 
                                 ;*************************************************************************
                                 ;** TCB2 - 16-bit Timer Type B
                                 ;*************************************************************************
                                 
                                 .equ TCB2_CTRLA = 0x0B20                 ; Control A
                                 .equ TCB2_CTRLB = 0x0B21                 ; Control Register B
                                 .equ TCB2_EVCTRL = 0x0B24                ; Event Control
                                 .equ TCB2_INTCTRL = 0x0B25               ; Interrupt Control
                                 .equ TCB2_INTFLAGS = 0x0B26              ; Interrupt Flags
                                 .equ TCB2_STATUS = 0x0B27                ; Status
                                 .equ TCB2_DBGCTRL = 0x0B28               ; Debug Control
                                 .equ TCB2_TEMP = 0x0B29                  ; Temporary Value
                                 .equ TCB2_CNT = 0x0B2A                   ; Count
                                 .equ TCB2_CNTL = 0x0B2A                  ; Count low byte
                                 .equ TCB2_CNTH = 0x0B2B                  ; Count hi byte
                                 .equ TCB2_CCMP = 0x0B2C                  ; Compare or Capture
                                 .equ TCB2_CCMPL = 0x0B2C                 ; Compare or Capture low byte
                                 .equ TCB2_CCMPH = 0x0B2D                 ; Compare or Capture hi byte
                                 
                                 ;*************************************************************************
                                 ;** TCB3 - 16-bit Timer Type B
                                 ;*************************************************************************
                                 
                                 .equ TCB3_CTRLA = 0x0B30                 ; Control A
                                 .equ TCB3_CTRLB = 0x0B31                 ; Control Register B
                                 .equ TCB3_EVCTRL = 0x0B34                ; Event Control
                                 .equ TCB3_INTCTRL = 0x0B35               ; Interrupt Control
                                 .equ TCB3_INTFLAGS = 0x0B36              ; Interrupt Flags
                                 .equ TCB3_STATUS = 0x0B37                ; Status
                                 .equ TCB3_DBGCTRL = 0x0B38               ; Debug Control
                                 .equ TCB3_TEMP = 0x0B39                  ; Temporary Value
                                 .equ TCB3_CNT = 0x0B3A                   ; Count
                                 .equ TCB3_CNTL = 0x0B3A                  ; Count low byte
                                 .equ TCB3_CNTH = 0x0B3B                  ; Count hi byte
                                 .equ TCB3_CCMP = 0x0B3C                  ; Compare or Capture
                                 .equ TCB3_CCMPL = 0x0B3C                 ; Compare or Capture low byte
                                 .equ TCB3_CCMPH = 0x0B3D                 ; Compare or Capture hi byte
                                 
                                 ;*************************************************************************
                                 ;** TCB4 - 16-bit Timer Type B
                                 ;*************************************************************************
                                 
                                 .equ TCB4_CTRLA = 0x0B40                 ; Control A
                                 .equ TCB4_CTRLB = 0x0B41                 ; Control Register B
                                 .equ TCB4_EVCTRL = 0x0B44                ; Event Control
                                 .equ TCB4_INTCTRL = 0x0B45               ; Interrupt Control
                                 .equ TCB4_INTFLAGS = 0x0B46              ; Interrupt Flags
                                 .equ TCB4_STATUS = 0x0B47                ; Status
                                 .equ TCB4_DBGCTRL = 0x0B48               ; Debug Control
                                 .equ TCB4_TEMP = 0x0B49                  ; Temporary Value
                                 .equ TCB4_CNT = 0x0B4A                   ; Count
                                 .equ TCB4_CNTL = 0x0B4A                  ; Count low byte
                                 .equ TCB4_CNTH = 0x0B4B                  ; Count hi byte
                                 .equ TCB4_CCMP = 0x0B4C                  ; Compare or Capture
                                 .equ TCB4_CCMPL = 0x0B4C                 ; Compare or Capture low byte
                                 .equ TCB4_CCMPH = 0x0B4D                 ; Compare or Capture hi byte
                                 
                                 ;*************************************************************************
                                 ;** TCD0 - Timer Counter D
                                 ;*************************************************************************
                                 
                                 .equ TCD0_CTRLA = 0x0B80                 ; Control A
                                 .equ TCD0_CTRLB = 0x0B81                 ; Control B
                                 .equ TCD0_CTRLC = 0x0B82                 ; Control C
                                 .equ TCD0_CTRLD = 0x0B83                 ; Control D
                                 .equ TCD0_CTRLE = 0x0B84                 ; Control E
                                 .equ TCD0_EVCTRLA = 0x0B88               ; EVCTRLA
                                 .equ TCD0_EVCTRLB = 0x0B89               ; EVCTRLB
                                 .equ TCD0_INTCTRL = 0x0B8C               ; Interrupt Control
                                 .equ TCD0_INTFLAGS = 0x0B8D              ; Interrupt Flags
                                 .equ TCD0_STATUS = 0x0B8E                ; Status
                                 .equ TCD0_INPUTCTRLA = 0x0B90            ; Input Control A
                                 .equ TCD0_INPUTCTRLB = 0x0B91            ; Input Control B
                                 .equ TCD0_FAULTCTRL = 0x0B92             ; Fault Control
                                 .equ TCD0_DLYCTRL = 0x0B94               ; Delay Control
                                 .equ TCD0_DLYVAL = 0x0B95                ; Delay value
                                 .equ TCD0_DITCTRL = 0x0B98               ; Dither Control A
                                 .equ TCD0_DITVAL = 0x0B99                ; Dither value
                                 .equ TCD0_DBGCTRL = 0x0B9E               ; Debug Control
                                 .equ TCD0_CAPTUREA = 0x0BA2              ; Capture A
                                 .equ TCD0_CAPTUREAL = 0x0BA2             ; Capture A low byte
                                 .equ TCD0_CAPTUREAH = 0x0BA3             ; Capture A hi byte
                                 .equ TCD0_CAPTUREB = 0x0BA4              ; Capture B
                                 .equ TCD0_CAPTUREBL = 0x0BA4             ; Capture B low byte
                                 .equ TCD0_CAPTUREBH = 0x0BA5             ; Capture B hi byte
                                 .equ TCD0_CMPASET = 0x0BA8               ; Compare A Set
                                 .equ TCD0_CMPASETL = 0x0BA8              ; Compare A Set low byte
                                 .equ TCD0_CMPASETH = 0x0BA9              ; Compare A Set hi byte
                                 .equ TCD0_CMPACLR = 0x0BAA               ; Compare A Clear
                                 .equ TCD0_CMPACLRL = 0x0BAA              ; Compare A Clear low byte
                                 .equ TCD0_CMPACLRH = 0x0BAB              ; Compare A Clear hi byte
                                 .equ TCD0_CMPBSET = 0x0BAC               ; Compare B Set
                                 .equ TCD0_CMPBSETL = 0x0BAC              ; Compare B Set low byte
                                 .equ TCD0_CMPBSETH = 0x0BAD              ; Compare B Set hi byte
                                 .equ TCD0_CMPBCLR = 0x0BAE               ; Compare B Clear
                                 .equ TCD0_CMPBCLRL = 0x0BAE              ; Compare B Clear low byte
                                 .equ TCD0_CMPBCLRH = 0x0BAF              ; Compare B Clear hi byte
                                 
                                 ;*************************************************************************
                                 ;** TWI0 - Two-Wire Interface
                                 ;*************************************************************************
                                 
                                 .equ TWI0_CTRLA = 0x0900                 ; Control A
                                 .equ TWI0_DUALCTRL = 0x0901              ; Dual Control
                                 .equ TWI0_DBGCTRL = 0x0902               ; Debug Control Register
                                 .equ TWI0_MCTRLA = 0x0903                ; Host Control A
                                 .equ TWI0_MCTRLB = 0x0904                ; Host Control B
                                 .equ TWI0_MSTATUS = 0x0905               ; Host Status
                                 .equ TWI0_MBAUD = 0x0906                 ; Host Baud Rate Control
                                 .equ TWI0_MADDR = 0x0907                 ; Host Address
                                 .equ TWI0_MDATA = 0x0908                 ; Host Data
                                 .equ TWI0_SCTRLA = 0x0909                ; Client Control A
                                 .equ TWI0_SCTRLB = 0x090A                ; Client Control B
                                 .equ TWI0_SSTATUS = 0x090B               ; Client Status
                                 .equ TWI0_SADDR = 0x090C                 ; Client Address
                                 .equ TWI0_SDATA = 0x090D                 ; Client Data
                                 .equ TWI0_SADDRMASK = 0x090E             ; Client Address Mask
                                 
                                 ;*************************************************************************
                                 ;** TWI1 - Two-Wire Interface
                                 ;*************************************************************************
                                 
                                 .equ TWI1_CTRLA = 0x0920                 ; Control A
                                 .equ TWI1_DUALCTRL = 0x0921              ; Dual Control
                                 .equ TWI1_DBGCTRL = 0x0922               ; Debug Control Register
                                 .equ TWI1_MCTRLA = 0x0923                ; Host Control A
                                 .equ TWI1_MCTRLB = 0x0924                ; Host Control B
                                 .equ TWI1_MSTATUS = 0x0925               ; Host Status
                                 .equ TWI1_MBAUD = 0x0926                 ; Host Baud Rate Control
                                 .equ TWI1_MADDR = 0x0927                 ; Host Address
                                 .equ TWI1_MDATA = 0x0928                 ; Host Data
                                 .equ TWI1_SCTRLA = 0x0929                ; Client Control A
                                 .equ TWI1_SCTRLB = 0x092A                ; Client Control B
                                 .equ TWI1_SSTATUS = 0x092B               ; Client Status
                                 .equ TWI1_SADDR = 0x092C                 ; Client Address
                                 .equ TWI1_SDATA = 0x092D                 ; Client Data
                                 .equ TWI1_SADDRMASK = 0x092E             ; Client Address Mask
                                 
                                 ;*************************************************************************
                                 ;** USART0 - Universal Synchronous and Asynchronous Receiver and Transmitter
                                 ;*************************************************************************
                                 
                                 .equ USART0_RXDATAL = 0x0800             ; Receive Data Low Byte
                                 .equ USART0_RXDATAH = 0x0801             ; Receive Data High Byte
                                 .equ USART0_TXDATAL = 0x0802             ; Transmit Data Low Byte
                                 .equ USART0_TXDATAH = 0x0803             ; Transmit Data High Byte
                                 .equ USART0_STATUS = 0x0804              ; Status
                                 .equ USART0_CTRLA = 0x0805               ; Control A
                                 .equ USART0_CTRLB = 0x0806               ; Control B
                                 .equ USART0_CTRLC = 0x0807               ; Control C
                                 .equ USART0_BAUD = 0x0808                ; Baud Rate
                                 .equ USART0_BAUDL = 0x0808               ; Baud Rate low byte
                                 .equ USART0_BAUDH = 0x0809               ; Baud Rate hi byte
                                 .equ USART0_CTRLD = 0x080A               ; Control D
                                 .equ USART0_DBGCTRL = 0x080B             ; Debug Control
                                 .equ USART0_EVCTRL = 0x080C              ; Event Control
                                 .equ USART0_TXPLCTRL = 0x080D            ; IRCOM Transmitter Pulse Length Control
                                 .equ USART0_RXPLCTRL = 0x080E            ; IRCOM Receiver Pulse Length Control
                                 
                                 ;*************************************************************************
                                 ;** USART1 - Universal Synchronous and Asynchronous Receiver and Transmitter
                                 ;*************************************************************************
                                 
                                 .equ USART1_RXDATAL = 0x0820             ; Receive Data Low Byte
                                 .equ USART1_RXDATAH = 0x0821             ; Receive Data High Byte
                                 .equ USART1_TXDATAL = 0x0822             ; Transmit Data Low Byte
                                 .equ USART1_TXDATAH = 0x0823             ; Transmit Data High Byte
                                 .equ USART1_STATUS = 0x0824              ; Status
                                 .equ USART1_CTRLA = 0x0825               ; Control A
                                 .equ USART1_CTRLB = 0x0826               ; Control B
                                 .equ USART1_CTRLC = 0x0827               ; Control C
                                 .equ USART1_BAUD = 0x0828                ; Baud Rate
                                 .equ USART1_BAUDL = 0x0828               ; Baud Rate low byte
                                 .equ USART1_BAUDH = 0x0829               ; Baud Rate hi byte
                                 .equ USART1_CTRLD = 0x082A               ; Control D
                                 .equ USART1_DBGCTRL = 0x082B             ; Debug Control
                                 .equ USART1_EVCTRL = 0x082C              ; Event Control
                                 .equ USART1_TXPLCTRL = 0x082D            ; IRCOM Transmitter Pulse Length Control
                                 .equ USART1_RXPLCTRL = 0x082E            ; IRCOM Receiver Pulse Length Control
                                 
                                 ;*************************************************************************
                                 ;** USART2 - Universal Synchronous and Asynchronous Receiver and Transmitter
                                 ;*************************************************************************
                                 
                                 .equ USART2_RXDATAL = 0x0840             ; Receive Data Low Byte
                                 .equ USART2_RXDATAH = 0x0841             ; Receive Data High Byte
                                 .equ USART2_TXDATAL = 0x0842             ; Transmit Data Low Byte
                                 .equ USART2_TXDATAH = 0x0843             ; Transmit Data High Byte
                                 .equ USART2_STATUS = 0x0844              ; Status
                                 .equ USART2_CTRLA = 0x0845               ; Control A
                                 .equ USART2_CTRLB = 0x0846               ; Control B
                                 .equ USART2_CTRLC = 0x0847               ; Control C
                                 .equ USART2_BAUD = 0x0848                ; Baud Rate
                                 .equ USART2_BAUDL = 0x0848               ; Baud Rate low byte
                                 .equ USART2_BAUDH = 0x0849               ; Baud Rate hi byte
                                 .equ USART2_CTRLD = 0x084A               ; Control D
                                 .equ USART2_DBGCTRL = 0x084B             ; Debug Control
                                 .equ USART2_EVCTRL = 0x084C              ; Event Control
                                 .equ USART2_TXPLCTRL = 0x084D            ; IRCOM Transmitter Pulse Length Control
                                 .equ USART2_RXPLCTRL = 0x084E            ; IRCOM Receiver Pulse Length Control
                                 
                                 ;*************************************************************************
                                 ;** USART3 - Universal Synchronous and Asynchronous Receiver and Transmitter
                                 ;*************************************************************************
                                 
                                 .equ USART3_RXDATAL = 0x0860             ; Receive Data Low Byte
                                 .equ USART3_RXDATAH = 0x0861             ; Receive Data High Byte
                                 .equ USART3_TXDATAL = 0x0862             ; Transmit Data Low Byte
                                 .equ USART3_TXDATAH = 0x0863             ; Transmit Data High Byte
                                 .equ USART3_STATUS = 0x0864              ; Status
                                 .equ USART3_CTRLA = 0x0865               ; Control A
                                 .equ USART3_CTRLB = 0x0866               ; Control B
                                 .equ USART3_CTRLC = 0x0867               ; Control C
                                 .equ USART3_BAUD = 0x0868                ; Baud Rate
                                 .equ USART3_BAUDL = 0x0868               ; Baud Rate low byte
                                 .equ USART3_BAUDH = 0x0869               ; Baud Rate hi byte
                                 .equ USART3_CTRLD = 0x086A               ; Control D
                                 .equ USART3_DBGCTRL = 0x086B             ; Debug Control
                                 .equ USART3_EVCTRL = 0x086C              ; Event Control
                                 .equ USART3_TXPLCTRL = 0x086D            ; IRCOM Transmitter Pulse Length Control
                                 .equ USART3_RXPLCTRL = 0x086E            ; IRCOM Receiver Pulse Length Control
                                 
                                 ;*************************************************************************
                                 ;** USART4 - Universal Synchronous and Asynchronous Receiver and Transmitter
                                 ;*************************************************************************
                                 
                                 .equ USART4_RXDATAL = 0x0880             ; Receive Data Low Byte
                                 .equ USART4_RXDATAH = 0x0881             ; Receive Data High Byte
                                 .equ USART4_TXDATAL = 0x0882             ; Transmit Data Low Byte
                                 .equ USART4_TXDATAH = 0x0883             ; Transmit Data High Byte
                                 .equ USART4_STATUS = 0x0884              ; Status
                                 .equ USART4_CTRLA = 0x0885               ; Control A
                                 .equ USART4_CTRLB = 0x0886               ; Control B
                                 .equ USART4_CTRLC = 0x0887               ; Control C
                                 .equ USART4_BAUD = 0x0888                ; Baud Rate
                                 .equ USART4_BAUDL = 0x0888               ; Baud Rate low byte
                                 .equ USART4_BAUDH = 0x0889               ; Baud Rate hi byte
                                 .equ USART4_CTRLD = 0x088A               ; Control D
                                 .equ USART4_DBGCTRL = 0x088B             ; Debug Control
                                 .equ USART4_EVCTRL = 0x088C              ; Event Control
                                 .equ USART4_TXPLCTRL = 0x088D            ; IRCOM Transmitter Pulse Length Control
                                 .equ USART4_RXPLCTRL = 0x088E            ; IRCOM Receiver Pulse Length Control
                                 
                                 ;*************************************************************************
                                 ;** USART5 - Universal Synchronous and Asynchronous Receiver and Transmitter
                                 ;*************************************************************************
                                 
                                 .equ USART5_RXDATAL = 0x08A0             ; Receive Data Low Byte
                                 .equ USART5_RXDATAH = 0x08A1             ; Receive Data High Byte
                                 .equ USART5_TXDATAL = 0x08A2             ; Transmit Data Low Byte
                                 .equ USART5_TXDATAH = 0x08A3             ; Transmit Data High Byte
                                 .equ USART5_STATUS = 0x08A4              ; Status
                                 .equ USART5_CTRLA = 0x08A5               ; Control A
                                 .equ USART5_CTRLB = 0x08A6               ; Control B
                                 .equ USART5_CTRLC = 0x08A7               ; Control C
                                 .equ USART5_BAUD = 0x08A8                ; Baud Rate
                                 .equ USART5_BAUDL = 0x08A8               ; Baud Rate low byte
                                 .equ USART5_BAUDH = 0x08A9               ; Baud Rate hi byte
                                 .equ USART5_CTRLD = 0x08AA               ; Control D
                                 .equ USART5_DBGCTRL = 0x08AB             ; Debug Control
                                 .equ USART5_EVCTRL = 0x08AC              ; Event Control
                                 .equ USART5_TXPLCTRL = 0x08AD            ; IRCOM Transmitter Pulse Length Control
                                 .equ USART5_RXPLCTRL = 0x08AE            ; IRCOM Receiver Pulse Length Control
                                 
                                 ;*************************************************************************
                                 ;** USERROW - User Row
                                 ;*************************************************************************
                                 
                                 .equ USERROW_USERROW0 = 0x1080           ; User Row Byte 0
                                 .equ USERROW_USERROW1 = 0x1081           ; User Row Byte 1
                                 .equ USERROW_USERROW2 = 0x1082           ; User Row Byte 2
                                 .equ USERROW_USERROW3 = 0x1083           ; User Row Byte 3
                                 .equ USERROW_USERROW4 = 0x1084           ; User Row Byte 4
                                 .equ USERROW_USERROW5 = 0x1085           ; User Row Byte 5
                                 .equ USERROW_USERROW6 = 0x1086           ; User Row Byte 6
                                 .equ USERROW_USERROW7 = 0x1087           ; User Row Byte 7
                                 .equ USERROW_USERROW8 = 0x1088           ; User Row Byte 8
                                 .equ USERROW_USERROW9 = 0x1089           ; User Row Byte 9
                                 .equ USERROW_USERROW10 = 0x108A          ; User Row Byte 10
                                 .equ USERROW_USERROW11 = 0x108B          ; User Row Byte 11
                                 .equ USERROW_USERROW12 = 0x108C          ; User Row Byte 12
                                 .equ USERROW_USERROW13 = 0x108D          ; User Row Byte 13
                                 .equ USERROW_USERROW14 = 0x108E          ; User Row Byte 14
                                 .equ USERROW_USERROW15 = 0x108F          ; User Row Byte 15
                                 .equ USERROW_USERROW16 = 0x1090          ; User Row Byte 16
                                 .equ USERROW_USERROW17 = 0x1091          ; User Row Byte 17
                                 .equ USERROW_USERROW18 = 0x1092          ; User Row Byte 18
                                 .equ USERROW_USERROW19 = 0x1093          ; User Row Byte 19
                                 .equ USERROW_USERROW20 = 0x1094          ; User Row Byte 20
                                 .equ USERROW_USERROW21 = 0x1095          ; User Row Byte 21
                                 .equ USERROW_USERROW22 = 0x1096          ; User Row Byte 22
                                 .equ USERROW_USERROW23 = 0x1097          ; User Row Byte 23
                                 .equ USERROW_USERROW24 = 0x1098          ; User Row Byte 24
                                 .equ USERROW_USERROW25 = 0x1099          ; User Row Byte 25
                                 .equ USERROW_USERROW26 = 0x109A          ; User Row Byte 26
                                 .equ USERROW_USERROW27 = 0x109B          ; User Row Byte 27
                                 .equ USERROW_USERROW28 = 0x109C          ; User Row Byte 28
                                 .equ USERROW_USERROW29 = 0x109D          ; User Row Byte 29
                                 .equ USERROW_USERROW30 = 0x109E          ; User Row Byte 30
                                 .equ USERROW_USERROW31 = 0x109F          ; User Row Byte 31
                                 
                                 ;*************************************************************************
                                 ;** VPORTA - Virtual Ports
                                 ;*************************************************************************
                                 
                                 .equ VPORTA_DIR = 0x0000                 ; Data Direction
                                 .equ VPORTA_OUT = 0x0001                 ; Output Value
                                 .equ VPORTA_IN = 0x0002                  ; Input Value
                                 .equ VPORTA_INTFLAGS = 0x0003            ; Interrupt Flags
                                 
                                 ;*************************************************************************
                                 ;** VPORTB - Virtual Ports
                                 ;*************************************************************************
                                 
                                 .equ VPORTB_DIR = 0x0004                 ; Data Direction
                                 .equ VPORTB_OUT = 0x0005                 ; Output Value
                                 .equ VPORTB_IN = 0x0006                  ; Input Value
                                 .equ VPORTB_INTFLAGS = 0x0007            ; Interrupt Flags
                                 
                                 ;*************************************************************************
                                 ;** VPORTC - Virtual Ports
                                 ;*************************************************************************
                                 
                                 .equ VPORTC_DIR = 0x0008                 ; Data Direction
                                 .equ VPORTC_OUT = 0x0009                 ; Output Value
                                 .equ VPORTC_IN = 0x000A                  ; Input Value
                                 .equ VPORTC_INTFLAGS = 0x000B            ; Interrupt Flags
                                 
                                 ;*************************************************************************
                                 ;** VPORTD - Virtual Ports
                                 ;*************************************************************************
                                 
                                 .equ VPORTD_DIR = 0x000C                 ; Data Direction
                                 .equ VPORTD_OUT = 0x000D                 ; Output Value
                                 .equ VPORTD_IN = 0x000E                  ; Input Value
                                 .equ VPORTD_INTFLAGS = 0x000F            ; Interrupt Flags
                                 
                                 ;*************************************************************************
                                 ;** VPORTE - Virtual Ports
                                 ;*************************************************************************
                                 
                                 .equ VPORTE_DIR = 0x0010                 ; Data Direction
                                 .equ VPORTE_OUT = 0x0011                 ; Output Value
                                 .equ VPORTE_IN = 0x0012                  ; Input Value
                                 .equ VPORTE_INTFLAGS = 0x0013            ; Interrupt Flags
                                 
                                 ;*************************************************************************
                                 ;** VPORTF - Virtual Ports
                                 ;*************************************************************************
                                 
                                 .equ VPORTF_DIR = 0x0014                 ; Data Direction
                                 .equ VPORTF_OUT = 0x0015                 ; Output Value
                                 .equ VPORTF_IN = 0x0016                  ; Input Value
                                 .equ VPORTF_INTFLAGS = 0x0017            ; Interrupt Flags
                                 
                                 ;*************************************************************************
                                 ;** VPORTG - Virtual Ports
                                 ;*************************************************************************
                                 
                                 .equ VPORTG_DIR = 0x0018                 ; Data Direction
                                 .equ VPORTG_OUT = 0x0019                 ; Output Value
                                 .equ VPORTG_IN = 0x001A                  ; Input Value
                                 .equ VPORTG_INTFLAGS = 0x001B            ; Interrupt Flags
                                 
                                 ;*************************************************************************
                                 ;** VREF - Voltage reference
                                 ;*************************************************************************
                                 
                                 .equ VREF_ADC0REF = 0x00B0               ; ADC0 Reference
                                 .equ VREF_DAC0REF = 0x00B2               ; DAC0 Reference
                                 .equ VREF_ACREF = 0x00B4                 ; AC Reference
                                 
                                 ;*************************************************************************
                                 ;** WDT - Watch-Dog Timer
                                 ;*************************************************************************
                                 
                                 .equ WDT_CTRLA = 0x0100                  ; Control A
                                 .equ WDT_STATUS = 0x0101                 ; Status
                                 
                                 ;*************************************************************************
                                 ;** ZCD0 - Zero Cross Detect
                                 ;*************************************************************************
                                 
                                 .equ ZCD0_CTRLA = 0x06C0                 ; Control A
                                 .equ ZCD0_INTCTRL = 0x06C2               ; Interrupt Control
                                 .equ ZCD0_STATUS = 0x06C3                ; Status
                                 
                                 ;*************************************************************************
                                 ;** ZCD1 - Zero Cross Detect
                                 ;*************************************************************************
                                 
                                 .equ ZCD1_CTRLA = 0x06C8                 ; Control A
                                 .equ ZCD1_INTCTRL = 0x06CA               ; Interrupt Control
                                 .equ ZCD1_STATUS = 0x06CB                ; Status
                                 
                                 ;*************************************************************************
                                 ;** ZCD2 - Zero Cross Detect
                                 ;*************************************************************************
                                 
                                 .equ ZCD2_CTRLA = 0x06D0                 ; Control A
                                 .equ ZCD2_INTCTRL = 0x06D2               ; Interrupt Control
                                 .equ ZCD2_STATUS = 0x06D3                ; Status
                                 
                                 
                                 ; ***** ALL MODULE BASE ADRESSES *****************************************
                                 
                                 .equ AC0_base = 0x0680                   ; Analog Comparator
                                 .equ AC1_base = 0x0688                   ; Analog Comparator
                                 .equ AC2_base = 0x0690                   ; Analog Comparator
                                 .equ ADC0_base = 0x0600                  ; Analog to Digital Converter
                                 .equ BOD_base = 0x00A0                   ; Bod interface
                                 .equ CCL_base = 0x01C0                   ; Configurable Custom Logic
                                 .equ CLKCTRL_base = 0x0060               ; Clock controller
                                 .equ CPU_base = 0x0030                   ; CPU
                                 .equ CPUINT_base = 0x0110                ; Interrupt Controller
                                 .equ CRCSCAN_base = 0x0120               ; CRCSCAN
                                 .equ DAC0_base = 0x06A0                  ; Digital to Analog Converter
                                 .equ EVSYS_base = 0x0200                 ; Event System
                                 .equ FUSE_base = 0x1050                  ; Fuses
                                 .equ GPR_base = 0x001C                   ; General Purpose Registers
                                 .equ LOCK_base = 0x1040                  ; Lockbits
                                 .equ MVIO_base = 0x00C0                  ; Multi-Voltage I/O
                                 .equ NVMCTRL_base = 0x1000               ; Non-volatile Memory Controller
                                 .equ OPAMP_base = 0x0700                 ; Operational Amplifier System
                                 .equ PORTA_base = 0x0400                 ; I/O Ports
                                 .equ PORTB_base = 0x0420                 ; I/O Ports
                                 .equ PORTC_base = 0x0440                 ; I/O Ports
                                 .equ PORTD_base = 0x0460                 ; I/O Ports
                                 .equ PORTE_base = 0x0480                 ; I/O Ports
                                 .equ PORTF_base = 0x04A0                 ; I/O Ports
                                 .equ PORTG_base = 0x04C0                 ; I/O Ports
                                 .equ PORTMUX_base = 0x05E0               ; Port Multiplexer
                                 .equ RSTCTRL_base = 0x0040               ; Reset controller
                                 .equ RTC_base = 0x0140                   ; Real-Time Counter
                                 .equ SIGROW_base = 0x1100                ; Signature row
                                 .equ SLPCTRL_base = 0x0050               ; Sleep Controller
                                 .equ SPI0_base = 0x0940                  ; Serial Peripheral Interface
                                 .equ SPI1_base = 0x0960                  ; Serial Peripheral Interface
                                 .equ SYSCFG_base = 0x0F00                ; System Configuration Registers
                                 .equ TCA0_base = 0x0A00                  ; 16-bit Timer/Counter Type A
                                 .equ TCA1_base = 0x0A40                  ; 16-bit Timer/Counter Type A
                                 .equ TCB0_base = 0x0B00                  ; 16-bit Timer Type B
                                 .equ TCB1_base = 0x0B10                  ; 16-bit Timer Type B
                                 .equ TCB2_base = 0x0B20                  ; 16-bit Timer Type B
                                 .equ TCB3_base = 0x0B30                  ; 16-bit Timer Type B
                                 .equ TCB4_base = 0x0B40                  ; 16-bit Timer Type B
                                 .equ TCD0_base = 0x0B80                  ; Timer Counter D
                                 .equ TWI0_base = 0x0900                  ; Two-Wire Interface
                                 .equ TWI1_base = 0x0920                  ; Two-Wire Interface
                                 .equ USART0_base = 0x0800                ; Universal Synchronous and Asynchronous Receiver and Transmitter
                                 .equ USART1_base = 0x0820                ; Universal Synchronous and Asynchronous Receiver and Transmitter
                                 .equ USART2_base = 0x0840                ; Universal Synchronous and Asynchronous Receiver and Transmitter
                                 .equ USART3_base = 0x0860                ; Universal Synchronous and Asynchronous Receiver and Transmitter
                                 .equ USART4_base = 0x0880                ; Universal Synchronous and Asynchronous Receiver and Transmitter
                                 .equ USART5_base = 0x08A0                ; Universal Synchronous and Asynchronous Receiver and Transmitter
                                 .equ USERROW_base = 0x1080               ; User Row
                                 .equ VPORTA_base = 0x0000                ; Virtual Ports
                                 .equ VPORTB_base = 0x0004                ; Virtual Ports
                                 .equ VPORTC_base = 0x0008                ; Virtual Ports
                                 .equ VPORTD_base = 0x000C                ; Virtual Ports
                                 .equ VPORTE_base = 0x0010                ; Virtual Ports
                                 .equ VPORTF_base = 0x0014                ; Virtual Ports
                                 .equ VPORTG_base = 0x0018                ; Virtual Ports
                                 .equ VREF_base = 0x00B0                  ; Voltage reference
                                 .equ WDT_base = 0x0100                   ; Watch-Dog Timer
                                 .equ ZCD0_base = 0x06C0                  ; Zero Cross Detect
                                 .equ ZCD1_base = 0x06C8                  ; Zero Cross Detect
                                 .equ ZCD2_base = 0x06D0                  ; Zero Cross Detect
                                 
                                 
                                 ; ***** IO REGISTER OFFSETS **********************************************
                                 
                                 
                                 ;*************************************************************************
                                 ;** AC - Analog Comparator
                                 ;*************************************************************************
                                 .equ AC_CTRLA_offset = 0x00              ; Control A
                                 .equ AC_CTRLB_offset = 0x01              ; Control B
                                 .equ AC_MUXCTRL_offset = 0x02            ; Mux Control A
                                 .equ AC_DACREF_offset = 0x05             ; DAC Voltage Reference
                                 .equ AC_INTCTRL_offset = 0x06            ; Interrupt Control
                                 .equ AC_STATUS_offset = 0x07             ; Status
                                 
                                 ;*************************************************************************
                                 ;** ADC - Analog to Digital Converter
                                 ;*************************************************************************
                                 .equ ADC_CTRLA_offset = 0x00             ; Control A
                                 .equ ADC_CTRLB_offset = 0x01             ; Control B
                                 .equ ADC_CTRLC_offset = 0x02             ; Control C
                                 .equ ADC_CTRLD_offset = 0x03             ; Control D
                                 .equ ADC_CTRLE_offset = 0x04             ; Control E
                                 .equ ADC_SAMPCTRL_offset = 0x05          ; Sample Control
                                 .equ ADC_MUXPOS_offset = 0x08            ; Positive mux input
                                 .equ ADC_MUXNEG_offset = 0x09            ; Negative mux input
                                 .equ ADC_COMMAND_offset = 0x0A           ; Command
                                 .equ ADC_EVCTRL_offset = 0x0B            ; Event Control
                                 .equ ADC_INTCTRL_offset = 0x0C           ; Interrupt Control
                                 .equ ADC_INTFLAGS_offset = 0x0D          ; Interrupt Flags
                                 .equ ADC_DBGCTRL_offset = 0x0E           ; Debug Control
                                 .equ ADC_TEMP_offset = 0x0F              ; Temporary Data
                                 .equ ADC_RES_offset = 0x10               ; ADC Accumulator Result
                                 .equ ADC_WINLT_offset = 0x12             ; Window comparator low threshold
                                 .equ ADC_WINHT_offset = 0x14             ; Window comparator high threshold
                                 
                                 ;*************************************************************************
                                 ;** BOD - Bod interface
                                 ;*************************************************************************
                                 .equ BOD_CTRLA_offset = 0x00             ; Control A
                                 .equ BOD_CTRLB_offset = 0x01             ; Control B
                                 .equ BOD_VLMCTRLA_offset = 0x08          ; Voltage level monitor Control
                                 .equ BOD_INTCTRL_offset = 0x09           ; Voltage level monitor interrupt Control
                                 .equ BOD_INTFLAGS_offset = 0x0A          ; Voltage level monitor interrupt Flags
                                 .equ BOD_STATUS_offset = 0x0B            ; Voltage level monitor status
                                 
                                 ;*************************************************************************
                                 ;** CCL - Configurable Custom Logic
                                 ;*************************************************************************
                                 .equ CCL_CTRLA_offset = 0x00             ; Control Register A
                                 .equ CCL_SEQCTRL0_offset = 0x01          ; Sequential Control 0
                                 .equ CCL_SEQCTRL1_offset = 0x02          ; Sequential Control 1
                                 .equ CCL_SEQCTRL2_offset = 0x03          ; Sequential Control 2
                                 .equ CCL_INTCTRL0_offset = 0x05          ; Interrupt Control 0
                                 .equ CCL_INTCTRL1_offset = 0x06          ; Interrupt Control 1
                                 .equ CCL_INTFLAGS_offset = 0x07          ; Interrupt Flags
                                 .equ CCL_LUT0CTRLA_offset = 0x08         ; LUT 0 Control A
                                 .equ CCL_LUT0CTRLB_offset = 0x09         ; LUT 0 Control B
                                 .equ CCL_LUT0CTRLC_offset = 0x0A         ; LUT 0 Control C
                                 .equ CCL_TRUTH0_offset = 0x0B            ; Truth 0
                                 .equ CCL_LUT1CTRLA_offset = 0x0C         ; LUT 1 Control A
                                 .equ CCL_LUT1CTRLB_offset = 0x0D         ; LUT 1 Control B
                                 .equ CCL_LUT1CTRLC_offset = 0x0E         ; LUT 1 Control C
                                 .equ CCL_TRUTH1_offset = 0x0F            ; Truth 1
                                 .equ CCL_LUT2CTRLA_offset = 0x10         ; LUT 2 Control A
                                 .equ CCL_LUT2CTRLB_offset = 0x11         ; LUT 2 Control B
                                 .equ CCL_LUT2CTRLC_offset = 0x12         ; LUT 2 Control C
                                 .equ CCL_TRUTH2_offset = 0x13            ; Truth 2
                                 .equ CCL_LUT3CTRLA_offset = 0x14         ; LUT 3 Control A
                                 .equ CCL_LUT3CTRLB_offset = 0x15         ; LUT 3 Control B
                                 .equ CCL_LUT3CTRLC_offset = 0x16         ; LUT 3 Control C
                                 .equ CCL_TRUTH3_offset = 0x17            ; Truth 3
                                 .equ CCL_LUT4CTRLA_offset = 0x18         ; LUT 4 Control A
                                 .equ CCL_LUT4CTRLB_offset = 0x19         ; LUT 4 Control B
                                 .equ CCL_LUT4CTRLC_offset = 0x1A         ; LUT 4 Control C
                                 .equ CCL_TRUTH4_offset = 0x1B            ; Truth 4
                                 .equ CCL_LUT5CTRLA_offset = 0x1C         ; LUT 5 Control A
                                 .equ CCL_LUT5CTRLB_offset = 0x1D         ; LUT 5 Control B
                                 .equ CCL_LUT5CTRLC_offset = 0x1E         ; LUT 5 Control C
                                 .equ CCL_TRUTH5_offset = 0x1F            ; Truth 5
                                 
                                 ;*************************************************************************
                                 ;** CLKCTRL - Clock controller
                                 ;*************************************************************************
                                 .equ CLKCTRL_MCLKCTRLA_offset = 0x00     ; MCLK Control A
                                 .equ CLKCTRL_MCLKCTRLB_offset = 0x01     ; MCLK Control B
                                 .equ CLKCTRL_MCLKCTRLC_offset = 0x02     ; MCLK Control C
                                 .equ CLKCTRL_MCLKINTCTRL_offset = 0x03   ; MCLK Interrupt Control
                                 .equ CLKCTRL_MCLKINTFLAGS_offset = 0x04  ; MCLK Interrupt Flags
                                 .equ CLKCTRL_MCLKSTATUS_offset = 0x05    ; MCLK Status
                                 .equ CLKCTRL_OSCHFCTRLA_offset = 0x08    ; OSCHF Control A
                                 .equ CLKCTRL_OSCHFTUNE_offset = 0x09     ; OSCHF Tune
                                 .equ CLKCTRL_PLLCTRLA_offset = 0x10      ; PLL Control A
                                 .equ CLKCTRL_OSC32KCTRLA_offset = 0x18   ; OSC32K Control A
                                 .equ CLKCTRL_XOSC32KCTRLA_offset = 0x1C  ; XOSC32K Control A
                                 .equ CLKCTRL_XOSCHFCTRLA_offset = 0x20   ; 
                                 
                                 ;*************************************************************************
                                 ;** CPU - CPU
                                 ;*************************************************************************
                                 .equ CPU_CCP_offset = 0x04               ; Configuration Change Protection
                                 .equ CPU_RAMPZ_offset = 0x0B             ; Extended Z-pointer Register
                                 .equ CPU_SPL_offset = 0x0D               ; Stack Pointer Low
                                 .equ CPU_SPH_offset = 0x0E               ; Stack Pointer High
                                 .equ CPU_SREG_offset = 0x0F              ; Status Register
                                 
                                 ;*************************************************************************
                                 ;** CPUINT - Interrupt Controller
                                 ;*************************************************************************
                                 .equ CPUINT_CTRLA_offset = 0x00          ; Control A
                                 .equ CPUINT_STATUS_offset = 0x01         ; Status
                                 .equ CPUINT_LVL0PRI_offset = 0x02        ; Interrupt Level 0 Priority
                                 .equ CPUINT_LVL1VEC_offset = 0x03        ; Interrupt Level 1 Priority Vector
                                 
                                 ;*************************************************************************
                                 ;** CRCSCAN - CRCSCAN
                                 ;*************************************************************************
                                 .equ CRCSCAN_CTRLA_offset = 0x00         ; Control A
                                 .equ CRCSCAN_CTRLB_offset = 0x01         ; Control B
                                 .equ CRCSCAN_STATUS_offset = 0x02        ; Status
                                 
                                 ;*************************************************************************
                                 ;** DAC - Digital to Analog Converter
                                 ;*************************************************************************
                                 .equ DAC_CTRLA_offset = 0x00             ; Control Register A
                                 .equ DAC_DATA_offset = 0x02              ; DATA Register
                                 
                                 ;*************************************************************************
                                 ;** EVSYS - Event System
                                 ;*************************************************************************
                                 .equ EVSYS_SWEVENTA_offset = 0x00        ; Software Event A
                                 .equ EVSYS_SWEVENTB_offset = 0x01        ; Software Event B
                                 .equ EVSYS_CHANNEL0_offset = 0x10        ; Multiplexer Channel 0
                                 .equ EVSYS_CHANNEL1_offset = 0x11        ; Multiplexer Channel 1
                                 .equ EVSYS_CHANNEL2_offset = 0x12        ; Multiplexer Channel 2
                                 .equ EVSYS_CHANNEL3_offset = 0x13        ; Multiplexer Channel 3
                                 .equ EVSYS_CHANNEL4_offset = 0x14        ; Multiplexer Channel 4
                                 .equ EVSYS_CHANNEL5_offset = 0x15        ; Multiplexer Channel 5
                                 .equ EVSYS_CHANNEL6_offset = 0x16        ; Multiplexer Channel 6
                                 .equ EVSYS_CHANNEL7_offset = 0x17        ; Multiplexer Channel 7
                                 .equ EVSYS_CHANNEL8_offset = 0x18        ; Multiplexer Channel 8
                                 .equ EVSYS_CHANNEL9_offset = 0x19        ; Multiplexer Channel 9
                                 .equ EVSYS_USERCCLLUT0A_offset = 0x20    ; User 0 - CCL0 Event A
                                 .equ EVSYS_USERCCLLUT0B_offset = 0x21    ; User 1 - CCL0 Event B
                                 .equ EVSYS_USERCCLLUT1A_offset = 0x22    ; User 2 - CCL1 Event A
                                 .equ EVSYS_USERCCLLUT1B_offset = 0x23    ; User 3 - CCL1 Event B
                                 .equ EVSYS_USERCCLLUT2A_offset = 0x24    ; User 4 - CCL2 Event A
                                 .equ EVSYS_USERCCLLUT2B_offset = 0x25    ; User 5 - CCL2 Event B
                                 .equ EVSYS_USERCCLLUT3A_offset = 0x26    ; User 6 - CCL3 Event A
                                 .equ EVSYS_USERCCLLUT3B_offset = 0x27    ; User 7 - CCL3 Event B
                                 .equ EVSYS_USERCCLLUT4A_offset = 0x28    ; User 8 - CCL4 Event A
                                 .equ EVSYS_USERCCLLUT4B_offset = 0x29    ; User 9 - CCL4 Event B
                                 .equ EVSYS_USERCCLLUT5A_offset = 0x2A    ; User 10 - CCL5 Event A
                                 .equ EVSYS_USERCCLLUT5B_offset = 0x2B    ; User 11 - CCL5 Event B
                                 .equ EVSYS_USERADC0START_offset = 0x2C   ; User 12 - ADC0
                                 .equ EVSYS_USEREVSYSEVOUTA_offset = 0x2D ; User 13 - EVOUTA
                                 .equ EVSYS_USEREVSYSEVOUTB_offset = 0x2E ; User 14 - EVOUTB
                                 .equ EVSYS_USEREVSYSEVOUTC_offset = 0x2F ; User 15 - EVOUTC
                                 .equ EVSYS_USEREVSYSEVOUTD_offset = 0x30 ; User 16 - EVOUTD
                                 .equ EVSYS_USEREVSYSEVOUTE_offset = 0x31 ; User 17 - EVOUTE
                                 .equ EVSYS_USEREVSYSEVOUTF_offset = 0x32 ; User 18 - EVOUTF
                                 .equ EVSYS_USEREVSYSEVOUTG_offset = 0x33 ; User 19 - EVOUTG
                                 .equ EVSYS_USERUSART0IRDA_offset = 0x34  ; User 20 - USART0
                                 .equ EVSYS_USERUSART1IRDA_offset = 0x35  ; User 21 - USART1
                                 .equ EVSYS_USERUSART2IRDA_offset = 0x36  ; User 22 - USART2
                                 .equ EVSYS_USERUSART3IRDA_offset = 0x37  ; User 23 - USART3
                                 .equ EVSYS_USERUSART4IRDA_offset = 0x38  ; User 24 - USART4
                                 .equ EVSYS_USERUSART5IRDA_offset = 0x39  ; User 25 - USART5
                                 .equ EVSYS_USERTCA0CNTA_offset = 0x3A    ; User 26 - TCA0 Event A
                                 .equ EVSYS_USERTCA0CNTB_offset = 0x3B    ; User 27 - TCA0 Event B
                                 .equ EVSYS_USERTCA1CNTA_offset = 0x3C    ; User 28 - TCA1 Event A
                                 .equ EVSYS_USERTCA1CNTB_offset = 0x3D    ; User 29 - TCA1 Event B
                                 .equ EVSYS_USERTCB0CAPT_offset = 0x3E    ; User 30 - TCB0 Event A
                                 .equ EVSYS_USERTCB0COUNT_offset = 0x3F   ; User 31 - TCB0 Event B
                                 .equ EVSYS_USERTCB1CAPT_offset = 0x40    ; User 32 - TCB1 Event A
                                 .equ EVSYS_USERTCB1COUNT_offset = 0x41   ; User 33 - TCB1 Event B
                                 .equ EVSYS_USERTCB2CAPT_offset = 0x42    ; User 34 - TCB2 Event A
                                 .equ EVSYS_USERTCB2COUNT_offset = 0x43   ; User 35 - TCB2 Event B
                                 .equ EVSYS_USERTCB3CAPT_offset = 0x44    ; User 36 - TCB3 Event A
                                 .equ EVSYS_USERTCB3COUNT_offset = 0x45   ; User 37 - TCB3 Event B
                                 .equ EVSYS_USERTCB4CAPT_offset = 0x46    ; User 38 - TCB4 Event A
                                 .equ EVSYS_USERTCB4COUNT_offset = 0x47   ; User 39 - TCB4 Event B
                                 .equ EVSYS_USERTCD0INPUTA_offset = 0x48  ; User 40 - TCD0 Event A
                                 .equ EVSYS_USERTCD0INPUTB_offset = 0x49  ; User 41 - TCD0 Event B
                                 .equ EVSYS_USEROPAMP0ENABLE_offset = 0x4A ; User 42 - OPAMP0 Enable
                                 .equ EVSYS_USEROPAMP0DISABLE_offset = 0x4B ; User 43 - OPAMP0 Disable
                                 .equ EVSYS_USEROPAMP0DUMP_offset = 0x4C  ; User 44 - OPAMP0 Dump
                                 .equ EVSYS_USEROPAMP0DRIVE_offset = 0x4D ; User 45 - OPAMP0 Drive
                                 .equ EVSYS_USEROPAMP1ENABLE_offset = 0x4E ; User 46 - OPAMP1 Enable
                                 .equ EVSYS_USEROPAMP1DISABLE_offset = 0x4F ; User 47 - OPAMP1 Disable
                                 .equ EVSYS_USEROPAMP1DUMP_offset = 0x50  ; User 48 - OPAMP1 Dump
                                 .equ EVSYS_USEROPAMP1DRIVE_offset = 0x51 ; User 49 - OPAMP1 Drive
                                 .equ EVSYS_USEROPAMP2ENABLE_offset = 0x52 ; User 50 - OPAMP2 Enable
                                 .equ EVSYS_USEROPAMP2DISABLE_offset = 0x53 ; User 51 - OPAMP2 Disable
                                 .equ EVSYS_USEROPAMP2DUMP_offset = 0x54  ; User 52 - OPAMP2 Dump
                                 .equ EVSYS_USEROPAMP2DRIVE_offset = 0x55 ; User 53 - OPAMP2 Drive
                                 
                                 ;*************************************************************************
                                 ;** FUSE - Fuses
                                 ;*************************************************************************
                                 .equ FUSE_WDTCFG_offset = 0x00           ; Watchdog Configuration
                                 .equ FUSE_BODCFG_offset = 0x01           ; BOD Configuration
                                 .equ FUSE_OSCCFG_offset = 0x02           ; Oscillator Configuration
                                 .equ FUSE_SYSCFG0_offset = 0x05          ; System Configuration 0
                                 .equ FUSE_SYSCFG1_offset = 0x06          ; System Configuration 1
                                 .equ FUSE_CODESIZE_offset = 0x07         ; Code Section Size
                                 .equ FUSE_BOOTSIZE_offset = 0x08         ; Boot Section Size
                                 
                                 ;*************************************************************************
                                 ;** GPR - General Purpose Registers
                                 ;*************************************************************************
                                 .equ GPR_GPR0_offset = 0x00              ; General Purpose Register 0
                                 .equ GPR_GPR1_offset = 0x01              ; General Purpose Register 1
                                 .equ GPR_GPR2_offset = 0x02              ; General Purpose Register 2
                                 .equ GPR_GPR3_offset = 0x03              ; General Purpose Register 3
                                 
                                 ;*************************************************************************
                                 ;** LOCK - Lockbits
                                 ;*************************************************************************
                                 .equ LOCK_KEY_offset = 0x00              ; Lock Key Bits
                                 
                                 ;*************************************************************************
                                 ;** MVIO - Multi-Voltage I/O
                                 ;*************************************************************************
                                 .equ MVIO_INTCTRL_offset = 0x00          ; Interrupt Control
                                 .equ MVIO_INTFLAGS_offset = 0x01         ; Interrupt Flags
                                 .equ MVIO_STATUS_offset = 0x02           ; Status
                                 
                                 ;*************************************************************************
                                 ;** NVMCTRL - Non-volatile Memory Controller
                                 ;*************************************************************************
                                 .equ NVMCTRL_CTRLA_offset = 0x00         ; Control A
                                 .equ NVMCTRL_CTRLB_offset = 0x01         ; Control B
                                 .equ NVMCTRL_STATUS_offset = 0x02        ; Status
                                 .equ NVMCTRL_INTCTRL_offset = 0x03       ; Interrupt Control
                                 .equ NVMCTRL_INTFLAGS_offset = 0x04      ; Interrupt Flags
                                 .equ NVMCTRL_DATA_offset = 0x06          ; Data
                                 .equ NVMCTRL_ADDR_offset = 0x08          ; Address
                                 
                                 ;*************************************************************************
                                 ;** OPAMP - Operational Amplifier System
                                 ;*************************************************************************
                                 .equ OPAMP_CTRLA_offset = 0x00           ; Control A
                                 .equ OPAMP_DBGCTRL_offset = 0x01         ; Debug Control
                                 .equ OPAMP_TIMEBASE_offset = 0x02        ; Timebase Value
                                 .equ OPAMP_PWRCTRL_offset = 0x0F         ; Power Control
                                 .equ OPAMP_OP0CTRLA_offset = 0x10        ; Op Amp 0 Control A
                                 .equ OPAMP_OP0STATUS_offset = 0x11       ; Op Amp 0 Status
                                 .equ OPAMP_OP0RESMUX_offset = 0x12       ; Op Amp 0 Resistor Ladder Multiplexer
                                 .equ OPAMP_OP0INMUX_offset = 0x13        ; Op Amp 0 Input Multiplexer
                                 .equ OPAMP_OP0SETTLE_offset = 0x14       ; Op Amp 0 Settle
                                 .equ OPAMP_OP0CAL_offset = 0x15          ; Op Amp 0 Calibration
                                 .equ OPAMP_OP1CTRLA_offset = 0x18        ; Op Amp 1 Control A
                                 .equ OPAMP_OP1STATUS_offset = 0x19       ; Op Amp 1 Status
                                 .equ OPAMP_OP1RESMUX_offset = 0x1A       ; Op Amp 1 Resistor Ladder Multiplexer
                                 .equ OPAMP_OP1INMUX_offset = 0x1B        ; Op Amp 1 Input Multiplexer
                                 .equ OPAMP_OP1SETTLE_offset = 0x1C       ; Op Amp 1 Settle
                                 .equ OPAMP_OP1CAL_offset = 0x1D          ; Op Amp 1 Calibration
                                 .equ OPAMP_OP2CTRLA_offset = 0x20        ; Op Amp 2 Control A
                                 .equ OPAMP_OP2STATUS_offset = 0x21       ; Op Amp 2 Status
                                 .equ OPAMP_OP2RESMUX_offset = 0x22       ; Op Amp 2 Resistor Ladder Multiplexer
                                 .equ OPAMP_OP2INMUX_offset = 0x23        ; Op Amp 2 Input Multiplexer
                                 .equ OPAMP_OP2SETTLE_offset = 0x24       ; Op Amp 2 Settle
                                 .equ OPAMP_OP2CAL_offset = 0x25          ; Op Amp 2 Calibration
                                 
                                 ;*************************************************************************
                                 ;** PORT - I/O Ports
                                 ;*************************************************************************
                                 .equ PORT_DIR_offset = 0x00              ; Data Direction
                                 .equ PORT_DIRSET_offset = 0x01           ; Data Direction Set
                                 .equ PORT_DIRCLR_offset = 0x02           ; Data Direction Clear
                                 .equ PORT_DIRTGL_offset = 0x03           ; Data Direction Toggle
                                 .equ PORT_OUT_offset = 0x04              ; Output Value
                                 .equ PORT_OUTSET_offset = 0x05           ; Output Value Set
                                 .equ PORT_OUTCLR_offset = 0x06           ; Output Value Clear
                                 .equ PORT_OUTTGL_offset = 0x07           ; Output Value Toggle
                                 .equ PORT_IN_offset = 0x08               ; Input Value
                                 .equ PORT_INTFLAGS_offset = 0x09         ; Interrupt Flags
                                 .equ PORT_PORTCTRL_offset = 0x0A         ; Port Control
                                 .equ PORT_PINCONFIG_offset = 0x0B        ; Pin Control Config
                                 .equ PORT_PINCTRLUPD_offset = 0x0C       ; Pin Control Update
                                 .equ PORT_PINCTRLSET_offset = 0x0D       ; Pin Control Set
                                 .equ PORT_PINCTRLCLR_offset = 0x0E       ; Pin Control Clear
                                 .equ PORT_PIN0CTRL_offset = 0x10         ; Pin 0 Control
                                 .equ PORT_PIN1CTRL_offset = 0x11         ; Pin 1 Control
                                 .equ PORT_PIN2CTRL_offset = 0x12         ; Pin 2 Control
                                 .equ PORT_PIN3CTRL_offset = 0x13         ; Pin 3 Control
                                 .equ PORT_PIN4CTRL_offset = 0x14         ; Pin 4 Control
                                 .equ PORT_PIN5CTRL_offset = 0x15         ; Pin 5 Control
                                 .equ PORT_PIN6CTRL_offset = 0x16         ; Pin 6 Control
                                 .equ PORT_PIN7CTRL_offset = 0x17         ; Pin 7 Control
                                 
                                 ;*************************************************************************
                                 ;** PORTMUX - Port Multiplexer
                                 ;*************************************************************************
                                 .equ PORTMUX_EVSYSROUTEA_offset = 0x00   ; EVSYS route A
                                 .equ PORTMUX_CCLROUTEA_offset = 0x01     ; CCL route A
                                 .equ PORTMUX_USARTROUTEA_offset = 0x02   ; USART route A
                                 .equ PORTMUX_USARTROUTEB_offset = 0x03   ; USART route B
                                 .equ PORTMUX_SPIROUTEA_offset = 0x04     ; SPI route A
                                 .equ PORTMUX_TWIROUTEA_offset = 0x05     ; TWI route A
                                 .equ PORTMUX_TCAROUTEA_offset = 0x06     ; TCA route A
                                 .equ PORTMUX_TCBROUTEA_offset = 0x07     ; TCB route A
                                 .equ PORTMUX_TCDROUTEA_offset = 0x08     ; TCD route A
                                 .equ PORTMUX_ACROUTEA_offset = 0x09      ; AC route A
                                 .equ PORTMUX_ZCDROUTEA_offset = 0x0A     ; ZCD route A
                                 
                                 ;*************************************************************************
                                 ;** RSTCTRL - Reset controller
                                 ;*************************************************************************
                                 .equ RSTCTRL_RSTFR_offset = 0x00         ; Reset Flags
                                 .equ RSTCTRL_SWRR_offset = 0x01          ; Software Reset
                                 
                                 ;*************************************************************************
                                 ;** RTC - Real-Time Counter
                                 ;*************************************************************************
                                 .equ RTC_CTRLA_offset = 0x00             ; Control A
                                 .equ RTC_STATUS_offset = 0x01            ; Status
                                 .equ RTC_INTCTRL_offset = 0x02           ; Interrupt Control
                                 .equ RTC_INTFLAGS_offset = 0x03          ; Interrupt Flags
                                 .equ RTC_TEMP_offset = 0x04              ; Temporary
                                 .equ RTC_DBGCTRL_offset = 0x05           ; Debug control
                                 .equ RTC_CALIB_offset = 0x06             ; Calibration
                                 .equ RTC_CLKSEL_offset = 0x07            ; Clock Select
                                 .equ RTC_CNT_offset = 0x08               ; Counter
                                 .equ RTC_PER_offset = 0x0A               ; Period
                                 .equ RTC_CMP_offset = 0x0C               ; Compare
                                 .equ RTC_PITCTRLA_offset = 0x10          ; PIT Control A
                                 .equ RTC_PITSTATUS_offset = 0x11         ; PIT Status
                                 .equ RTC_PITINTCTRL_offset = 0x12        ; PIT Interrupt Control
                                 .equ RTC_PITINTFLAGS_offset = 0x13       ; PIT Interrupt Flags
                                 .equ RTC_PITDBGCTRL_offset = 0x15        ; PIT Debug control
                                 
                                 ;*************************************************************************
                                 ;** SIGROW - Signature row
                                 ;*************************************************************************
                                 .equ SIGROW_DEVICEID0_offset = 0x00      ; Device ID Byte 0
                                 .equ SIGROW_DEVICEID1_offset = 0x01      ; Device ID Byte 1
                                 .equ SIGROW_DEVICEID2_offset = 0x02      ; Device ID Byte 2
                                 .equ SIGROW_TEMPSENSE0_offset = 0x04     ; Temperature Calibration 0
                                 .equ SIGROW_TEMPSENSE1_offset = 0x06     ; Temperature Calibration 1
                                 .equ SIGROW_SERNUM0_offset = 0x10        ; LOTNUM0
                                 .equ SIGROW_SERNUM1_offset = 0x11        ; LOTNUM1
                                 .equ SIGROW_SERNUM2_offset = 0x12        ; LOTNUM2
                                 .equ SIGROW_SERNUM3_offset = 0x13        ; LOTNUM3
                                 .equ SIGROW_SERNUM4_offset = 0x14        ; LOTNUM4
                                 .equ SIGROW_SERNUM5_offset = 0x15        ; LOTNUM5
                                 .equ SIGROW_SERNUM6_offset = 0x16        ; RANDOM
                                 .equ SIGROW_SERNUM7_offset = 0x17        ; SCRIBE
                                 .equ SIGROW_SERNUM8_offset = 0x18        ; XPOS0
                                 .equ SIGROW_SERNUM9_offset = 0x19        ; XPOS1
                                 .equ SIGROW_SERNUM10_offset = 0x1A       ; YPOS0
                                 .equ SIGROW_SERNUM11_offset = 0x1B       ; YPOS1
                                 .equ SIGROW_SERNUM12_offset = 0x1C       ; RES0
                                 .equ SIGROW_SERNUM13_offset = 0x1D       ; RES1
                                 .equ SIGROW_SERNUM14_offset = 0x1E       ; RES2
                                 .equ SIGROW_SERNUM15_offset = 0x1F       ; RES3
                                 
                                 ;*************************************************************************
                                 ;** SLPCTRL - Sleep Controller
                                 ;*************************************************************************
                                 .equ SLPCTRL_CTRLA_offset = 0x00         ; Control A
                                 .equ SLPCTRL_VREGCTRL_offset = 0x01      ; Control B
                                 
                                 ;*************************************************************************
                                 ;** SPI - Serial Peripheral Interface
                                 ;*************************************************************************
                                 .equ SPI_CTRLA_offset = 0x00             ; Control A
                                 .equ SPI_CTRLB_offset = 0x01             ; Control B
                                 .equ SPI_INTCTRL_offset = 0x02           ; Interrupt Control
                                 .equ SPI_INTFLAGS_offset = 0x03          ; Interrupt Flags
                                 .equ SPI_DATA_offset = 0x04              ; Data
                                 
                                 ;*************************************************************************
                                 ;** SYSCFG - System Configuration Registers
                                 ;*************************************************************************
                                 .equ SYSCFG_REVID_offset = 0x01          ; Revision ID
                                 .equ SYSCFG_OCDMCTRL_offset = 0x18       ; OCD Message Control
                                 .equ SYSCFG_OCDMSTATUS_offset = 0x19     ; OCD Message Status
                                 
                                 ;*************************************************************************
                                 ;** TCA - 16-bit Timer/Counter Type A
                                 ;*************************************************************************
                                 .equ TCA_SINGLE_CTRLA_offset = 0x00      ; Control A
                                 .equ TCA_SINGLE_CTRLB_offset = 0x01      ; Control B
                                 .equ TCA_SINGLE_CTRLC_offset = 0x02      ; Control C
                                 .equ TCA_SINGLE_CTRLD_offset = 0x03      ; Control D
                                 .equ TCA_SINGLE_CTRLECLR_offset = 0x04   ; Control E Clear
                                 .equ TCA_SINGLE_CTRLESET_offset = 0x05   ; Control E Set
                                 .equ TCA_SINGLE_CTRLFCLR_offset = 0x06   ; Control F Clear
                                 .equ TCA_SINGLE_CTRLFSET_offset = 0x07   ; Control F Set
                                 .equ TCA_SINGLE_EVCTRL_offset = 0x09     ; Event Control
                                 .equ TCA_SINGLE_INTCTRL_offset = 0x0A    ; Interrupt Control
                                 .equ TCA_SINGLE_INTFLAGS_offset = 0x0B   ; Interrupt Flags
                                 .equ TCA_SINGLE_DBGCTRL_offset = 0x0E    ; Degbug Control
                                 .equ TCA_SINGLE_TEMP_offset = 0x0F       ; Temporary data for 16-bit Access
                                 .equ TCA_SINGLE_CNT_offset = 0x20        ; Count
                                 .equ TCA_SINGLE_PER_offset = 0x26        ; Period
                                 .equ TCA_SINGLE_CMP0_offset = 0x28       ; Compare 0
                                 .equ TCA_SINGLE_CMP1_offset = 0x2A       ; Compare 1
                                 .equ TCA_SINGLE_CMP2_offset = 0x2C       ; Compare 2
                                 .equ TCA_SINGLE_PERBUF_offset = 0x36     ; Period Buffer
                                 .equ TCA_SINGLE_CMP0BUF_offset = 0x38    ; Compare 0 Buffer
                                 .equ TCA_SINGLE_CMP1BUF_offset = 0x3A    ; Compare 1 Buffer
                                 .equ TCA_SINGLE_CMP2BUF_offset = 0x3C    ; Compare 2 Buffer
                                 .equ TCA_SPLIT_CTRLA_offset = 0x00       ; Control A
                                 .equ TCA_SPLIT_CTRLB_offset = 0x01       ; Control B
                                 .equ TCA_SPLIT_CTRLC_offset = 0x02       ; Control C
                                 .equ TCA_SPLIT_CTRLD_offset = 0x03       ; Control D
                                 .equ TCA_SPLIT_CTRLECLR_offset = 0x04    ; Control E Clear
                                 .equ TCA_SPLIT_CTRLESET_offset = 0x05    ; Control E Set
                                 .equ TCA_SPLIT_INTCTRL_offset = 0x0A     ; Interrupt Control
                                 .equ TCA_SPLIT_INTFLAGS_offset = 0x0B    ; Interrupt Flags
                                 .equ TCA_SPLIT_DBGCTRL_offset = 0x0E     ; Degbug Control
                                 .equ TCA_SPLIT_LCNT_offset = 0x20        ; Low Count
                                 .equ TCA_SPLIT_HCNT_offset = 0x21        ; High Count
                                 .equ TCA_SPLIT_LPER_offset = 0x26        ; Low Period
                                 .equ TCA_SPLIT_HPER_offset = 0x27        ; High Period
                                 .equ TCA_SPLIT_LCMP0_offset = 0x28       ; Low Compare
                                 .equ TCA_SPLIT_HCMP0_offset = 0x29       ; High Compare
                                 .equ TCA_SPLIT_LCMP1_offset = 0x2A       ; Low Compare
                                 .equ TCA_SPLIT_HCMP1_offset = 0x2B       ; High Compare
                                 .equ TCA_SPLIT_LCMP2_offset = 0x2C       ; Low Compare
                                 .equ TCA_SPLIT_HCMP2_offset = 0x2D       ; High Compare
                                 .equ TCA_SINGLE_offset = 0x00            ; 
                                 .equ TCA_SPLIT_offset = 0x00             ; 
                                 
                                 ;*************************************************************************
                                 ;** TCB - 16-bit Timer Type B
                                 ;*************************************************************************
                                 .equ TCB_CTRLA_offset = 0x00             ; Control A
                                 .equ TCB_CTRLB_offset = 0x01             ; Control Register B
                                 .equ TCB_EVCTRL_offset = 0x04            ; Event Control
                                 .equ TCB_INTCTRL_offset = 0x05           ; Interrupt Control
                                 .equ TCB_INTFLAGS_offset = 0x06          ; Interrupt Flags
                                 .equ TCB_STATUS_offset = 0x07            ; Status
                                 .equ TCB_DBGCTRL_offset = 0x08           ; Debug Control
                                 .equ TCB_TEMP_offset = 0x09              ; Temporary Value
                                 .equ TCB_CNT_offset = 0x0A               ; Count
                                 .equ TCB_CCMP_offset = 0x0C              ; Compare or Capture
                                 
                                 ;*************************************************************************
                                 ;** TCD - Timer Counter D
                                 ;*************************************************************************
                                 .equ TCD_CTRLA_offset = 0x00             ; Control A
                                 .equ TCD_CTRLB_offset = 0x01             ; Control B
                                 .equ TCD_CTRLC_offset = 0x02             ; Control C
                                 .equ TCD_CTRLD_offset = 0x03             ; Control D
                                 .equ TCD_CTRLE_offset = 0x04             ; Control E
                                 .equ TCD_EVCTRLA_offset = 0x08           ; EVCTRLA
                                 .equ TCD_EVCTRLB_offset = 0x09           ; EVCTRLB
                                 .equ TCD_INTCTRL_offset = 0x0C           ; Interrupt Control
                                 .equ TCD_INTFLAGS_offset = 0x0D          ; Interrupt Flags
                                 .equ TCD_STATUS_offset = 0x0E            ; Status
                                 .equ TCD_INPUTCTRLA_offset = 0x10        ; Input Control A
                                 .equ TCD_INPUTCTRLB_offset = 0x11        ; Input Control B
                                 .equ TCD_FAULTCTRL_offset = 0x12         ; Fault Control
                                 .equ TCD_DLYCTRL_offset = 0x14           ; Delay Control
                                 .equ TCD_DLYVAL_offset = 0x15            ; Delay value
                                 .equ TCD_DITCTRL_offset = 0x18           ; Dither Control A
                                 .equ TCD_DITVAL_offset = 0x19            ; Dither value
                                 .equ TCD_DBGCTRL_offset = 0x1E           ; Debug Control
                                 .equ TCD_CAPTUREA_offset = 0x22          ; Capture A
                                 .equ TCD_CAPTUREB_offset = 0x24          ; Capture B
                                 .equ TCD_CMPASET_offset = 0x28           ; Compare A Set
                                 .equ TCD_CMPACLR_offset = 0x2A           ; Compare A Clear
                                 .equ TCD_CMPBSET_offset = 0x2C           ; Compare B Set
                                 .equ TCD_CMPBCLR_offset = 0x2E           ; Compare B Clear
                                 
                                 ;*************************************************************************
                                 ;** TWI - Two-Wire Interface
                                 ;*************************************************************************
                                 .equ TWI_CTRLA_offset = 0x00             ; Control A
                                 .equ TWI_DUALCTRL_offset = 0x01          ; Dual Control
                                 .equ TWI_DBGCTRL_offset = 0x02           ; Debug Control Register
                                 .equ TWI_MCTRLA_offset = 0x03            ; Host Control A
                                 .equ TWI_MCTRLB_offset = 0x04            ; Host Control B
                                 .equ TWI_MSTATUS_offset = 0x05           ; Host Status
                                 .equ TWI_MBAUD_offset = 0x06             ; Host Baud Rate Control
                                 .equ TWI_MADDR_offset = 0x07             ; Host Address
                                 .equ TWI_MDATA_offset = 0x08             ; Host Data
                                 .equ TWI_SCTRLA_offset = 0x09            ; Client Control A
                                 .equ TWI_SCTRLB_offset = 0x0A            ; Client Control B
                                 .equ TWI_SSTATUS_offset = 0x0B           ; Client Status
                                 .equ TWI_SADDR_offset = 0x0C             ; Client Address
                                 .equ TWI_SDATA_offset = 0x0D             ; Client Data
                                 .equ TWI_SADDRMASK_offset = 0x0E         ; Client Address Mask
                                 
                                 ;*************************************************************************
                                 ;** USART - Universal Synchronous and Asynchronous Receiver and Transmitter
                                 ;*************************************************************************
                                 .equ USART_RXDATAL_offset = 0x00         ; Receive Data Low Byte
                                 .equ USART_RXDATAH_offset = 0x01         ; Receive Data High Byte
                                 .equ USART_TXDATAL_offset = 0x02         ; Transmit Data Low Byte
                                 .equ USART_TXDATAH_offset = 0x03         ; Transmit Data High Byte
                                 .equ USART_STATUS_offset = 0x04          ; Status
                                 .equ USART_CTRLA_offset = 0x05           ; Control A
                                 .equ USART_CTRLB_offset = 0x06           ; Control B
                                 .equ USART_CTRLC_offset = 0x07           ; Control C
                                 .equ USART_BAUD_offset = 0x08            ; Baud Rate
                                 .equ USART_CTRLD_offset = 0x0A           ; Control D
                                 .equ USART_DBGCTRL_offset = 0x0B         ; Debug Control
                                 .equ USART_EVCTRL_offset = 0x0C          ; Event Control
                                 .equ USART_TXPLCTRL_offset = 0x0D        ; IRCOM Transmitter Pulse Length Control
                                 .equ USART_RXPLCTRL_offset = 0x0E        ; IRCOM Receiver Pulse Length Control
                                 
                                 ;*************************************************************************
                                 ;** USERROW - User Row
                                 ;*************************************************************************
                                 .equ USERROW_USERROW0_offset = 0x00      ; User Row Byte 0
                                 .equ USERROW_USERROW1_offset = 0x01      ; User Row Byte 1
                                 .equ USERROW_USERROW2_offset = 0x02      ; User Row Byte 2
                                 .equ USERROW_USERROW3_offset = 0x03      ; User Row Byte 3
                                 .equ USERROW_USERROW4_offset = 0x04      ; User Row Byte 4
                                 .equ USERROW_USERROW5_offset = 0x05      ; User Row Byte 5
                                 .equ USERROW_USERROW6_offset = 0x06      ; User Row Byte 6
                                 .equ USERROW_USERROW7_offset = 0x07      ; User Row Byte 7
                                 .equ USERROW_USERROW8_offset = 0x08      ; User Row Byte 8
                                 .equ USERROW_USERROW9_offset = 0x09      ; User Row Byte 9
                                 .equ USERROW_USERROW10_offset = 0x0A     ; User Row Byte 10
                                 .equ USERROW_USERROW11_offset = 0x0B     ; User Row Byte 11
                                 .equ USERROW_USERROW12_offset = 0x0C     ; User Row Byte 12
                                 .equ USERROW_USERROW13_offset = 0x0D     ; User Row Byte 13
                                 .equ USERROW_USERROW14_offset = 0x0E     ; User Row Byte 14
                                 .equ USERROW_USERROW15_offset = 0x0F     ; User Row Byte 15
                                 .equ USERROW_USERROW16_offset = 0x10     ; User Row Byte 16
                                 .equ USERROW_USERROW17_offset = 0x11     ; User Row Byte 17
                                 .equ USERROW_USERROW18_offset = 0x12     ; User Row Byte 18
                                 .equ USERROW_USERROW19_offset = 0x13     ; User Row Byte 19
                                 .equ USERROW_USERROW20_offset = 0x14     ; User Row Byte 20
                                 .equ USERROW_USERROW21_offset = 0x15     ; User Row Byte 21
                                 .equ USERROW_USERROW22_offset = 0x16     ; User Row Byte 22
                                 .equ USERROW_USERROW23_offset = 0x17     ; User Row Byte 23
                                 .equ USERROW_USERROW24_offset = 0x18     ; User Row Byte 24
                                 .equ USERROW_USERROW25_offset = 0x19     ; User Row Byte 25
                                 .equ USERROW_USERROW26_offset = 0x1A     ; User Row Byte 26
                                 .equ USERROW_USERROW27_offset = 0x1B     ; User Row Byte 27
                                 .equ USERROW_USERROW28_offset = 0x1C     ; User Row Byte 28
                                 .equ USERROW_USERROW29_offset = 0x1D     ; User Row Byte 29
                                 .equ USERROW_USERROW30_offset = 0x1E     ; User Row Byte 30
                                 .equ USERROW_USERROW31_offset = 0x1F     ; User Row Byte 31
                                 
                                 ;*************************************************************************
                                 ;** VPORT - Virtual Ports
                                 ;*************************************************************************
                                 .equ VPORT_DIR_offset = 0x00             ; Data Direction
                                 .equ VPORT_OUT_offset = 0x01             ; Output Value
                                 .equ VPORT_IN_offset = 0x02              ; Input Value
                                 .equ VPORT_INTFLAGS_offset = 0x03        ; Interrupt Flags
                                 
                                 ;*************************************************************************
                                 ;** VREF - Voltage reference
                                 ;*************************************************************************
                                 .equ VREF_ADC0REF_offset = 0x00          ; ADC0 Reference
                                 .equ VREF_DAC0REF_offset = 0x02          ; DAC0 Reference
                                 .equ VREF_ACREF_offset = 0x04            ; AC Reference
                                 
                                 ;*************************************************************************
                                 ;** WDT - Watch-Dog Timer
                                 ;*************************************************************************
                                 .equ WDT_CTRLA_offset = 0x00             ; Control A
                                 .equ WDT_STATUS_offset = 0x01            ; Status
                                 
                                 ;*************************************************************************
                                 ;** ZCD - Zero Cross Detect
                                 ;*************************************************************************
                                 .equ ZCD_CTRLA_offset = 0x00             ; Control A
                                 .equ ZCD_INTCTRL_offset = 0x02           ; Interrupt Control
                                 .equ ZCD_STATUS_offset = 0x03            ; Status
                                 
                                 
                                 ; ***** LOCKBIT REGISTER LOCATIONS ***************************************
                                 
                                 
                                 
                                 
                                 ; ***** FUSE REGISTER LOCATIONS ******************************************
                                 
                                 
                                 
                                 
                                 ; ***** BIT AND VALUE DEFINITIONS ****************************************
                                 
                                 
                                 ;*************************************************************************
                                 ;** AC - Analog Comparator
                                 ;*************************************************************************
                                 
                                 ; AC_CTRLA masks
                                 .equ AC_ENABLE_bm = 0x01                 ; Enable bit mask
                                 .equ AC_ENABLE_bp = 0                    ; Enable bit position
                                 .equ AC_HYSMODE_gm = 0x06                ; Hysteresis Mode group mask
                                 .equ AC_HYSMODE_gp = 1                   ; Hysteresis Mode group position
                                 .equ AC_HYSMODE0_bm = (1<<1)             ; Hysteresis Mode bit 0 mask
                                 .equ AC_HYSMODE0_bp = 1                  ; Hysteresis Mode bit 0 position
                                 .equ AC_HYSMODE1_bm = (1<<2)             ; Hysteresis Mode bit 1 mask
                                 .equ AC_HYSMODE1_bp = 2                  ; Hysteresis Mode bit 1 position
                                 .equ AC_OUTEN_bm = 0x40                  ; Output Pad Enable bit mask
                                 .equ AC_OUTEN_bp = 6                     ; Output Pad Enable bit position
                                 .equ AC_POWER_gm = 0x18                  ; Power profile group mask
                                 .equ AC_POWER_gp = 3                     ; Power profile group position
                                 .equ AC_POWER0_bm = (1<<3)               ; Power profile bit 0 mask
                                 .equ AC_POWER0_bp = 3                    ; Power profile bit 0 position
                                 .equ AC_POWER1_bm = (1<<4)               ; Power profile bit 1 mask
                                 .equ AC_POWER1_bp = 4                    ; Power profile bit 1 position
                                 .equ AC_RUNSTDBY_bm = 0x80               ; Run in Standby Mode bit mask
                                 .equ AC_RUNSTDBY_bp = 7                  ; Run in Standby Mode bit position
                                 
                                 ; AC_CTRLB masks
                                 .equ AC_WINSEL_gm = 0x03                 ; Window selection mode group mask
                                 .equ AC_WINSEL_gp = 0                    ; Window selection mode group position
                                 .equ AC_WINSEL0_bm = (1<<0)              ; Window selection mode bit 0 mask
                                 .equ AC_WINSEL0_bp = 0                   ; Window selection mode bit 0 position
                                 .equ AC_WINSEL1_bm = (1<<1)              ; Window selection mode bit 1 mask
                                 .equ AC_WINSEL1_bp = 1                   ; Window selection mode bit 1 position
                                 
                                 ; AC_DACREF masks
                                 .equ AC_DACREF_gm = 0xFF                 ; DACREF group mask
                                 .equ AC_DACREF_gp = 0                    ; DACREF group position
                                 .equ AC_DACREF0_bm = (1<<0)              ; DACREF bit 0 mask
                                 .equ AC_DACREF0_bp = 0                   ; DACREF bit 0 position
                                 .equ AC_DACREF1_bm = (1<<1)              ; DACREF bit 1 mask
                                 .equ AC_DACREF1_bp = 1                   ; DACREF bit 1 position
                                 .equ AC_DACREF2_bm = (1<<2)              ; DACREF bit 2 mask
                                 .equ AC_DACREF2_bp = 2                   ; DACREF bit 2 position
                                 .equ AC_DACREF3_bm = (1<<3)              ; DACREF bit 3 mask
                                 .equ AC_DACREF3_bp = 3                   ; DACREF bit 3 position
                                 .equ AC_DACREF4_bm = (1<<4)              ; DACREF bit 4 mask
                                 .equ AC_DACREF4_bp = 4                   ; DACREF bit 4 position
                                 .equ AC_DACREF5_bm = (1<<5)              ; DACREF bit 5 mask
                                 .equ AC_DACREF5_bp = 5                   ; DACREF bit 5 position
                                 .equ AC_DACREF6_bm = (1<<6)              ; DACREF bit 6 mask
                                 .equ AC_DACREF6_bp = 6                   ; DACREF bit 6 position
                                 .equ AC_DACREF7_bm = (1<<7)              ; DACREF bit 7 mask
                                 .equ AC_DACREF7_bp = 7                   ; DACREF bit 7 position
                                 
                                 ; AC_INTCTRL masks
                                 .equ AC_CMP_bm = 0x01                    ; Interrupt Enable bit mask
                                 .equ AC_CMP_bp = 0                       ; Interrupt Enable bit position
                                 .equ AC_INTMODE_gm = 0x30                ; Interrupt Mode group mask
                                 .equ AC_INTMODE_gp = 4                   ; Interrupt Mode group position
                                 .equ AC_INTMODE0_bm = (1<<4)             ; Interrupt Mode bit 0 mask
                                 .equ AC_INTMODE0_bp = 4                  ; Interrupt Mode bit 0 position
                                 .equ AC_INTMODE1_bm = (1<<5)             ; Interrupt Mode bit 1 mask
                                 .equ AC_INTMODE1_bp = 5                  ; Interrupt Mode bit 1 position
                                 ; Masks for AC_INTMODE already defined
                                 
                                 ; AC_MUXCTRL masks
                                 .equ AC_INITVAL_bm = 0x40                ; AC Output Initial Value bit mask
                                 .equ AC_INITVAL_bp = 6                   ; AC Output Initial Value bit position
                                 .equ AC_INVERT_bm = 0x80                 ; Invert AC Output bit mask
                                 .equ AC_INVERT_bp = 7                    ; Invert AC Output bit position
                                 .equ AC_MUXNEG_gm = 0x07                 ; Negative Input MUX Selection group mask
                                 .equ AC_MUXNEG_gp = 0                    ; Negative Input MUX Selection group position
                                 .equ AC_MUXNEG0_bm = (1<<0)              ; Negative Input MUX Selection bit 0 mask
                                 .equ AC_MUXNEG0_bp = 0                   ; Negative Input MUX Selection bit 0 position
                                 .equ AC_MUXNEG1_bm = (1<<1)              ; Negative Input MUX Selection bit 1 mask
                                 .equ AC_MUXNEG1_bp = 1                   ; Negative Input MUX Selection bit 1 position
                                 .equ AC_MUXNEG2_bm = (1<<2)              ; Negative Input MUX Selection bit 2 mask
                                 .equ AC_MUXNEG2_bp = 2                   ; Negative Input MUX Selection bit 2 position
                                 .equ AC_MUXPOS_gm = 0x38                 ; Positive Input MUX Selection group mask
                                 .equ AC_MUXPOS_gp = 3                    ; Positive Input MUX Selection group position
                                 .equ AC_MUXPOS0_bm = (1<<3)              ; Positive Input MUX Selection bit 0 mask
                                 .equ AC_MUXPOS0_bp = 3                   ; Positive Input MUX Selection bit 0 position
                                 .equ AC_MUXPOS1_bm = (1<<4)              ; Positive Input MUX Selection bit 1 mask
                                 .equ AC_MUXPOS1_bp = 4                   ; Positive Input MUX Selection bit 1 position
                                 .equ AC_MUXPOS2_bm = (1<<5)              ; Positive Input MUX Selection bit 2 mask
                                 .equ AC_MUXPOS2_bp = 5                   ; Positive Input MUX Selection bit 2 position
                                 
                                 ; AC_STATUS masks
                                 .equ AC_CMPIF_bm = 0x01                  ; Analog Comparator Interrupt Flag bit mask
                                 .equ AC_CMPIF_bp = 0                     ; Analog Comparator Interrupt Flag bit position
                                 .equ AC_CMPSTATE_bm = 0x10               ; Analog Comparator State bit mask
                                 .equ AC_CMPSTATE_bp = 4                  ; Analog Comparator State bit position
                                 .equ AC_WINSTATE_gm = 0xC0               ; Analog Comparator Window State group mask
                                 .equ AC_WINSTATE_gp = 6                  ; Analog Comparator Window State group position
                                 .equ AC_WINSTATE0_bm = (1<<6)            ; Analog Comparator Window State bit 0 mask
                                 .equ AC_WINSTATE0_bp = 6                 ; Analog Comparator Window State bit 0 position
                                 .equ AC_WINSTATE1_bm = (1<<7)            ; Analog Comparator Window State bit 1 mask
                                 .equ AC_WINSTATE1_bp = 7                 ; Analog Comparator Window State bit 1 position
                                 
                                 ; Hysteresis Mode select
                                 .equ AC_HYSMODE_NONE_gc = (0x00<<1)      ; No hysteresis
                                 .equ AC_HYSMODE_SMALL_gc = (0x01<<1)     ; Small hysteresis
                                 .equ AC_HYSMODE_MEDIUM_gc = (0x02<<1)    ; Medium hysteresis
                                 .equ AC_HYSMODE_LARGE_gc = (0x03<<1)     ; Large hysteresis
                                 
                                 ; Power profile select
                                 .equ AC_POWER_PROFILE0_gc = (0x00<<3)    ; Power profile 0, Shortest response time, highest consumption
                                 .equ AC_POWER_PROFILE1_gc = (0x01<<3)    ; Power profile 1
                                 .equ AC_POWER_PROFILE2_gc = (0x02<<3)    ; Power profile 2
                                 
                                 ; Window selection mode select
                                 .equ AC_WINSEL_DISABLED_gc = (0x00<<0)   ; Window function disabled
                                 .equ AC_WINSEL_UPSEL1_gc = (0x01<<0)     ; Select ACn+1 as upper limit in window compare
                                 .equ AC_WINSEL_UPSEL2_gc = (0x02<<0)     ; Select ACn+2 as upper limit in window compare
                                 
                                 ; Interrupt Mode select
                                 .equ AC_NORMAL_INTMODE_BOTHEDGE_gc = (0x00<<4) ; Positive and negative inputs crosses
                                 .equ AC_NORMAL_INTMODE_NEGEDGE_gc = (0x02<<4) ; Positive input goes below negative input
                                 .equ AC_NORMAL_INTMODE_POSEDGE_gc = (0x03<<4) ; Positive input goes above negative input
                                 
                                 ; Interrupt Mode select
                                 .equ AC_WINDOW_INTMODE_ABOVE_gc = (0x00<<4) ; Window interrupt when input above both references
                                 .equ AC_WINDOW_INTMODE_INSIDE_gc = (0x01<<4) ; Window interrupt when input betweeen references
                                 .equ AC_WINDOW_INTMODE_BELOW_gc = (0x02<<4) ; Window interrupt when input below both references
                                 .equ AC_WINDOW_INTMODE_OUTSIDE_gc = (0x03<<4) ; Window interrupt when input outside reference
                                 
                                 ; AC Output Initial Value select
                                 .equ AC_INITVAL_LOW_gc = (0x00<<6)       ; Output initialized to 0
                                 .equ AC_INITVAL_HIGH_gc = (0x01<<6)      ; Output initialized to 1
                                 
                                 ; Negative Input MUX Selection select
                                 .equ AC_MUXNEG_AINN0_gc = (0x00<<0)      ; Negative Pin 0
                                 .equ AC_MUXNEG_AINN1_gc = (0x01<<0)      ; Negative Pin 1
                                 .equ AC_MUXNEG_AINN2_gc = (0x02<<0)      ; Negative Pin 2
                                 .equ AC_MUXNEG_DACREF_gc = (0x03<<0)     ; DAC Reference
                                 
                                 ; Positive Input MUX Selection select
                                 .equ AC_MUXPOS_AINP0_gc = (0x00<<3)      ; Positive Pin 0
                                 .equ AC_MUXPOS_AINP1_gc = (0x01<<3)      ; Positive Pin 1
                                 .equ AC_MUXPOS_AINP2_gc = (0x02<<3)      ; Positive Pin 2
                                 .equ AC_MUXPOS_AINP3_gc = (0x03<<3)      ; Positive Pin 3
                                 
                                 ; Analog Comparator Window State select
                                 .equ AC_WINSTATE_ABOVE_gc = (0x00<<6)    ; Above window
                                 .equ AC_WINSTATE_INSIDE_gc = (0x01<<6)   ; Inside window
                                 .equ AC_WINSTATE_BELOW_gc = (0x02<<6)    ; Below window
                                 
                                 
                                 ;*************************************************************************
                                 ;** ADC - Analog to Digital Converter
                                 ;*************************************************************************
                                 
                                 ; ADC_COMMAND masks
                                 .equ ADC_SPCONV_bm = 0x02                ; Stop Conversion bit mask
                                 .equ ADC_SPCONV_bp = 1                   ; Stop Conversion bit position
                                 .equ ADC_STCONV_bm = 0x01                ; Start Conversion bit mask
                                 .equ ADC_STCONV_bp = 0                   ; Start Conversion bit position
                                 
                                 ; ADC_CTRLA masks
                                 .equ ADC_CONVMODE_bm = 0x20              ; Conversion mode bit mask
                                 .equ ADC_CONVMODE_bp = 5                 ; Conversion mode bit position
                                 .equ ADC_ENABLE_bm = 0x01                ; ADC Enable bit mask
                                 .equ ADC_ENABLE_bp = 0                   ; ADC Enable bit position
                                 .equ ADC_FREERUN_bm = 0x02               ; Free running mode bit mask
                                 .equ ADC_FREERUN_bp = 1                  ; Free running mode bit position
                                 .equ ADC_LEFTADJ_bm = 0x10               ; Left adjust result bit mask
                                 .equ ADC_LEFTADJ_bp = 4                  ; Left adjust result bit position
                                 .equ ADC_RESSEL_gm = 0x0C                ; Resolution selection group mask
                                 .equ ADC_RESSEL_gp = 2                   ; Resolution selection group position
                                 .equ ADC_RESSEL0_bm = (1<<2)             ; Resolution selection bit 0 mask
                                 .equ ADC_RESSEL0_bp = 2                  ; Resolution selection bit 0 position
                                 .equ ADC_RESSEL1_bm = (1<<3)             ; Resolution selection bit 1 mask
                                 .equ ADC_RESSEL1_bp = 3                  ; Resolution selection bit 1 position
                                 .equ ADC_RUNSTBY_bm = 0x80               ; Run standby mode bit mask
                                 .equ ADC_RUNSTBY_bp = 7                  ; Run standby mode bit position
                                 
                                 ; ADC_CTRLB masks
                                 .equ ADC_SAMPNUM_gm = 0x07               ; Accumulation Samples group mask
                                 .equ ADC_SAMPNUM_gp = 0                  ; Accumulation Samples group position
                                 .equ ADC_SAMPNUM0_bm = (1<<0)            ; Accumulation Samples bit 0 mask
                                 .equ ADC_SAMPNUM0_bp = 0                 ; Accumulation Samples bit 0 position
                                 .equ ADC_SAMPNUM1_bm = (1<<1)            ; Accumulation Samples bit 1 mask
                                 .equ ADC_SAMPNUM1_bp = 1                 ; Accumulation Samples bit 1 position
                                 .equ ADC_SAMPNUM2_bm = (1<<2)            ; Accumulation Samples bit 2 mask
                                 .equ ADC_SAMPNUM2_bp = 2                 ; Accumulation Samples bit 2 position
                                 
                                 ; ADC_CTRLC masks
                                 .equ ADC_PRESC_gm = 0x0F                 ; Clock Pre-scaler group mask
                                 .equ ADC_PRESC_gp = 0                    ; Clock Pre-scaler group position
                                 .equ ADC_PRESC0_bm = (1<<0)              ; Clock Pre-scaler bit 0 mask
                                 .equ ADC_PRESC0_bp = 0                   ; Clock Pre-scaler bit 0 position
                                 .equ ADC_PRESC1_bm = (1<<1)              ; Clock Pre-scaler bit 1 mask
                                 .equ ADC_PRESC1_bp = 1                   ; Clock Pre-scaler bit 1 position
                                 .equ ADC_PRESC2_bm = (1<<2)              ; Clock Pre-scaler bit 2 mask
                                 .equ ADC_PRESC2_bp = 2                   ; Clock Pre-scaler bit 2 position
                                 .equ ADC_PRESC3_bm = (1<<3)              ; Clock Pre-scaler bit 3 mask
                                 .equ ADC_PRESC3_bp = 3                   ; Clock Pre-scaler bit 3 position
                                 
                                 ; ADC_CTRLD masks
                                 .equ ADC_INITDLY_gm = 0xE0               ; Initial Delay Selection group mask
                                 .equ ADC_INITDLY_gp = 5                  ; Initial Delay Selection group position
                                 .equ ADC_INITDLY0_bm = (1<<5)            ; Initial Delay Selection bit 0 mask
                                 .equ ADC_INITDLY0_bp = 5                 ; Initial Delay Selection bit 0 position
                                 .equ ADC_INITDLY1_bm = (1<<6)            ; Initial Delay Selection bit 1 mask
                                 .equ ADC_INITDLY1_bp = 6                 ; Initial Delay Selection bit 1 position
                                 .equ ADC_INITDLY2_bm = (1<<7)            ; Initial Delay Selection bit 2 mask
                                 .equ ADC_INITDLY2_bp = 7                 ; Initial Delay Selection bit 2 position
                                 .equ ADC_SAMPDLY_gm = 0x0F               ; Sampling Delay Selection group mask
                                 .equ ADC_SAMPDLY_gp = 0                  ; Sampling Delay Selection group position
                                 .equ ADC_SAMPDLY0_bm = (1<<0)            ; Sampling Delay Selection bit 0 mask
                                 .equ ADC_SAMPDLY0_bp = 0                 ; Sampling Delay Selection bit 0 position
                                 .equ ADC_SAMPDLY1_bm = (1<<1)            ; Sampling Delay Selection bit 1 mask
                                 .equ ADC_SAMPDLY1_bp = 1                 ; Sampling Delay Selection bit 1 position
                                 .equ ADC_SAMPDLY2_bm = (1<<2)            ; Sampling Delay Selection bit 2 mask
                                 .equ ADC_SAMPDLY2_bp = 2                 ; Sampling Delay Selection bit 2 position
                                 .equ ADC_SAMPDLY3_bm = (1<<3)            ; Sampling Delay Selection bit 3 mask
                                 .equ ADC_SAMPDLY3_bp = 3                 ; Sampling Delay Selection bit 3 position
                                 
                                 ; ADC_CTRLE masks
                                 .equ ADC_WINCM_gm = 0x07                 ; Window Comparator Mode group mask
                                 .equ ADC_WINCM_gp = 0                    ; Window Comparator Mode group position
                                 .equ ADC_WINCM0_bm = (1<<0)              ; Window Comparator Mode bit 0 mask
                                 .equ ADC_WINCM0_bp = 0                   ; Window Comparator Mode bit 0 position
                                 .equ ADC_WINCM1_bm = (1<<1)              ; Window Comparator Mode bit 1 mask
                                 .equ ADC_WINCM1_bp = 1                   ; Window Comparator Mode bit 1 position
                                 .equ ADC_WINCM2_bm = (1<<2)              ; Window Comparator Mode bit 2 mask
                                 .equ ADC_WINCM2_bp = 2                   ; Window Comparator Mode bit 2 position
                                 
                                 ; ADC_DBGCTRL masks
                                 .equ ADC_DBGRUN_bm = 0x01                ; Debug run bit mask
                                 .equ ADC_DBGRUN_bp = 0                   ; Debug run bit position
                                 
                                 ; ADC_EVCTRL masks
                                 .equ ADC_STARTEI_bm = 0x01               ; Start Event Input Enable bit mask
                                 .equ ADC_STARTEI_bp = 0                  ; Start Event Input Enable bit position
                                 
                                 ; ADC_INTCTRL masks
                                 .equ ADC_RESRDY_bm = 0x01                ; Result Ready Interrupt Enable bit mask
                                 .equ ADC_RESRDY_bp = 0                   ; Result Ready Interrupt Enable bit position
                                 .equ ADC_WCMP_bm = 0x02                  ; Window Comparator Interrupt Enable bit mask
                                 .equ ADC_WCMP_bp = 1                     ; Window Comparator Interrupt Enable bit position
                                 
                                 ; ADC_INTFLAGS masks
                                 ; Masks for ADC_RESRDY already defined
                                 ; Masks for ADC_WCMP already defined
                                 
                                 ; ADC_MUXNEG masks
                                 .equ ADC_MUXNEG_gm = 0x7F                ; Analog Channel Selection Bits group mask
                                 .equ ADC_MUXNEG_gp = 0                   ; Analog Channel Selection Bits group position
                                 .equ ADC_MUXNEG0_bm = (1<<0)             ; Analog Channel Selection Bits bit 0 mask
                                 .equ ADC_MUXNEG0_bp = 0                  ; Analog Channel Selection Bits bit 0 position
                                 .equ ADC_MUXNEG1_bm = (1<<1)             ; Analog Channel Selection Bits bit 1 mask
                                 .equ ADC_MUXNEG1_bp = 1                  ; Analog Channel Selection Bits bit 1 position
                                 .equ ADC_MUXNEG2_bm = (1<<2)             ; Analog Channel Selection Bits bit 2 mask
                                 .equ ADC_MUXNEG2_bp = 2                  ; Analog Channel Selection Bits bit 2 position
                                 .equ ADC_MUXNEG3_bm = (1<<3)             ; Analog Channel Selection Bits bit 3 mask
                                 .equ ADC_MUXNEG3_bp = 3                  ; Analog Channel Selection Bits bit 3 position
                                 .equ ADC_MUXNEG4_bm = (1<<4)             ; Analog Channel Selection Bits bit 4 mask
                                 .equ ADC_MUXNEG4_bp = 4                  ; Analog Channel Selection Bits bit 4 position
                                 .equ ADC_MUXNEG5_bm = (1<<5)             ; Analog Channel Selection Bits bit 5 mask
                                 .equ ADC_MUXNEG5_bp = 5                  ; Analog Channel Selection Bits bit 5 position
                                 .equ ADC_MUXNEG6_bm = (1<<6)             ; Analog Channel Selection Bits bit 6 mask
                                 .equ ADC_MUXNEG6_bp = 6                  ; Analog Channel Selection Bits bit 6 position
                                 
                                 ; ADC_MUXPOS masks
                                 .equ ADC_MUXPOS_gm = 0x7F                ; Analog Channel Selection Bits group mask
                                 .equ ADC_MUXPOS_gp = 0                   ; Analog Channel Selection Bits group position
                                 .equ ADC_MUXPOS0_bm = (1<<0)             ; Analog Channel Selection Bits bit 0 mask
                                 .equ ADC_MUXPOS0_bp = 0                  ; Analog Channel Selection Bits bit 0 position
                                 .equ ADC_MUXPOS1_bm = (1<<1)             ; Analog Channel Selection Bits bit 1 mask
                                 .equ ADC_MUXPOS1_bp = 1                  ; Analog Channel Selection Bits bit 1 position
                                 .equ ADC_MUXPOS2_bm = (1<<2)             ; Analog Channel Selection Bits bit 2 mask
                                 .equ ADC_MUXPOS2_bp = 2                  ; Analog Channel Selection Bits bit 2 position
                                 .equ ADC_MUXPOS3_bm = (1<<3)             ; Analog Channel Selection Bits bit 3 mask
                                 .equ ADC_MUXPOS3_bp = 3                  ; Analog Channel Selection Bits bit 3 position
                                 .equ ADC_MUXPOS4_bm = (1<<4)             ; Analog Channel Selection Bits bit 4 mask
                                 .equ ADC_MUXPOS4_bp = 4                  ; Analog Channel Selection Bits bit 4 position
                                 .equ ADC_MUXPOS5_bm = (1<<5)             ; Analog Channel Selection Bits bit 5 mask
                                 .equ ADC_MUXPOS5_bp = 5                  ; Analog Channel Selection Bits bit 5 position
                                 .equ ADC_MUXPOS6_bm = (1<<6)             ; Analog Channel Selection Bits bit 6 mask
                                 .equ ADC_MUXPOS6_bp = 6                  ; Analog Channel Selection Bits bit 6 position
                                 
                                 ; ADC_SAMPCTRL masks
                                 .equ ADC_SAMPLEN_gm = 0xFF               ; Sample lenght group mask
                                 .equ ADC_SAMPLEN_gp = 0                  ; Sample lenght group position
                                 .equ ADC_SAMPLEN0_bm = (1<<0)            ; Sample lenght bit 0 mask
                                 .equ ADC_SAMPLEN0_bp = 0                 ; Sample lenght bit 0 position
                                 .equ ADC_SAMPLEN1_bm = (1<<1)            ; Sample lenght bit 1 mask
                                 .equ ADC_SAMPLEN1_bp = 1                 ; Sample lenght bit 1 position
                                 .equ ADC_SAMPLEN2_bm = (1<<2)            ; Sample lenght bit 2 mask
                                 .equ ADC_SAMPLEN2_bp = 2                 ; Sample lenght bit 2 position
                                 .equ ADC_SAMPLEN3_bm = (1<<3)            ; Sample lenght bit 3 mask
                                 .equ ADC_SAMPLEN3_bp = 3                 ; Sample lenght bit 3 position
                                 .equ ADC_SAMPLEN4_bm = (1<<4)            ; Sample lenght bit 4 mask
                                 .equ ADC_SAMPLEN4_bp = 4                 ; Sample lenght bit 4 position
                                 .equ ADC_SAMPLEN5_bm = (1<<5)            ; Sample lenght bit 5 mask
                                 .equ ADC_SAMPLEN5_bp = 5                 ; Sample lenght bit 5 position
                                 .equ ADC_SAMPLEN6_bm = (1<<6)            ; Sample lenght bit 6 mask
                                 .equ ADC_SAMPLEN6_bp = 6                 ; Sample lenght bit 6 position
                                 .equ ADC_SAMPLEN7_bm = (1<<7)            ; Sample lenght bit 7 mask
                                 .equ ADC_SAMPLEN7_bp = 7                 ; Sample lenght bit 7 position
                                 
                                 ; ADC_TEMP masks
                                 .equ ADC_TEMP_gm = 0xFF                  ; Temporary group mask
                                 .equ ADC_TEMP_gp = 0                     ; Temporary group position
                                 .equ ADC_TEMP0_bm = (1<<0)               ; Temporary bit 0 mask
                                 .equ ADC_TEMP0_bp = 0                    ; Temporary bit 0 position
                                 .equ ADC_TEMP1_bm = (1<<1)               ; Temporary bit 1 mask
                                 .equ ADC_TEMP1_bp = 1                    ; Temporary bit 1 position
                                 .equ ADC_TEMP2_bm = (1<<2)               ; Temporary bit 2 mask
                                 .equ ADC_TEMP2_bp = 2                    ; Temporary bit 2 position
                                 .equ ADC_TEMP3_bm = (1<<3)               ; Temporary bit 3 mask
                                 .equ ADC_TEMP3_bp = 3                    ; Temporary bit 3 position
                                 .equ ADC_TEMP4_bm = (1<<4)               ; Temporary bit 4 mask
                                 .equ ADC_TEMP4_bp = 4                    ; Temporary bit 4 position
                                 .equ ADC_TEMP5_bm = (1<<5)               ; Temporary bit 5 mask
                                 .equ ADC_TEMP5_bp = 5                    ; Temporary bit 5 position
                                 .equ ADC_TEMP6_bm = (1<<6)               ; Temporary bit 6 mask
                                 .equ ADC_TEMP6_bp = 6                    ; Temporary bit 6 position
                                 .equ ADC_TEMP7_bm = (1<<7)               ; Temporary bit 7 mask
                                 .equ ADC_TEMP7_bp = 7                    ; Temporary bit 7 position
                                 
                                 ; Resolution selection select
                                 .equ ADC_RESSEL_12BIT_gc = (0x00<<2)     ; 12-bit mode
                                 .equ ADC_RESSEL_10BIT_gc = (0x01<<2)     ; 10-bit mode
                                 
                                 ; Accumulation Samples select
                                 .equ ADC_SAMPNUM_NONE_gc = (0x00<<0)     ; No accumulation
                                 .equ ADC_SAMPNUM_ACC2_gc = (0x01<<0)     ; 2 results accumulated
                                 .equ ADC_SAMPNUM_ACC4_gc = (0x02<<0)     ; 4 results accumulated
                                 .equ ADC_SAMPNUM_ACC8_gc = (0x03<<0)     ; 8 results accumulated
                                 .equ ADC_SAMPNUM_ACC16_gc = (0x04<<0)    ; 16 results accumulated
                                 .equ ADC_SAMPNUM_ACC32_gc = (0x05<<0)    ; 32 results accumulated
                                 .equ ADC_SAMPNUM_ACC64_gc = (0x06<<0)    ; 64 results accumulated
                                 .equ ADC_SAMPNUM_ACC128_gc = (0x07<<0)   ; 128 results accumulated
                                 
                                 ; Clock Pre-scaler select
                                 .equ ADC_PRESC_DIV2_gc = (0x00<<0)       ; CLK_PER divided by 2
                                 .equ ADC_PRESC_DIV4_gc = (0x01<<0)       ; CLK_PER divided by 4
                                 .equ ADC_PRESC_DIV8_gc = (0x02<<0)       ; CLK_PER divided by 8
                                 .equ ADC_PRESC_DIV12_gc = (0x03<<0)      ; CLK_PER divided by 12
                                 .equ ADC_PRESC_DIV16_gc = (0x04<<0)      ; CLK_PER divided by 16
                                 .equ ADC_PRESC_DIV20_gc = (0x05<<0)      ; CLK_PER divided by 20
                                 .equ ADC_PRESC_DIV24_gc = (0x06<<0)      ; CLK_PER divided by 24
                                 .equ ADC_PRESC_DIV28_gc = (0x07<<0)      ; CLK_PER divided by 28
                                 .equ ADC_PRESC_DIV32_gc = (0x08<<0)      ; CLK_PER divided by 32
                                 .equ ADC_PRESC_DIV48_gc = (0x09<<0)      ; CLK_PER divided by 48
                                 .equ ADC_PRESC_DIV64_gc = (0x0A<<0)      ; CLK_PER divided by 64
                                 .equ ADC_PRESC_DIV96_gc = (0x0B<<0)      ; CLK_PER divided by 96
                                 .equ ADC_PRESC_DIV128_gc = (0x0C<<0)     ; CLK_PER divided by 128
                                 .equ ADC_PRESC_DIV256_gc = (0x0D<<0)     ; CLK_PER divided by 256
                                 
                                 ; Initial Delay Selection select
                                 .equ ADC_INITDLY_DLY0_gc = (0x00<<5)     ; Delay 0 CLK_ADC cycles
                                 .equ ADC_INITDLY_DLY16_gc = (0x01<<5)    ; Delay 16 CLK_ADC cycles
                                 .equ ADC_INITDLY_DLY32_gc = (0x02<<5)    ; Delay 32 CLK_ADC cycles
                                 .equ ADC_INITDLY_DLY64_gc = (0x03<<5)    ; Delay 64 CLK_ADC cycles
                                 .equ ADC_INITDLY_DLY128_gc = (0x04<<5)   ; Delay 128 CLK_ADC cycles
                                 .equ ADC_INITDLY_DLY256_gc = (0x05<<5)   ; Delay 256 CLK_ADC cycles
                                 
                                 ; Sampling Delay Selection select
                                 .equ ADC_SAMPDLY_DLY0_gc = (0x00<<0)     ; Delay 0 CLK_ADC cycles
                                 .equ ADC_SAMPDLY_DLY1_gc = (0x01<<0)     ; Delay 1 CLK_ADC cycles
                                 .equ ADC_SAMPDLY_DLY2_gc = (0x02<<0)     ; Delay 2 CLK_ADC cycles
                                 .equ ADC_SAMPDLY_DLY3_gc = (0x03<<0)     ; Delay 3 CLK_ADC cycles
                                 .equ ADC_SAMPDLY_DLY4_gc = (0x04<<0)     ; Delay 4 CLK_ADC cycles
                                 .equ ADC_SAMPDLY_DLY5_gc = (0x05<<0)     ; Delay 5 CLK_ADC cycles
                                 .equ ADC_SAMPDLY_DLY6_gc = (0x06<<0)     ; Delay 6 CLK_ADC cycles
                                 .equ ADC_SAMPDLY_DLY7_gc = (0x07<<0)     ; Delay 7 CLK_ADC cycles
                                 .equ ADC_SAMPDLY_DLY8_gc = (0x08<<0)     ; Delay 8 CLK_ADC cycles
                                 .equ ADC_SAMPDLY_DLY9_gc = (0x09<<0)     ; Delay 9 CLK_ADC cycles
                                 .equ ADC_SAMPDLY_DLY10_gc = (0x0A<<0)    ; Delay 10 CLK_ADC cycles
                                 .equ ADC_SAMPDLY_DLY11_gc = (0x0B<<0)    ; Delay 11 CLK_ADC cycles
                                 .equ ADC_SAMPDLY_DLY12_gc = (0x0C<<0)    ; Delay 12 CLK_ADC cycles
                                 .equ ADC_SAMPDLY_DLY13_gc = (0x0D<<0)    ; Delay 13 CLK_ADC cycles
                                 .equ ADC_SAMPDLY_DLY14_gc = (0x0E<<0)    ; Delay 14 CLK_ADC cycles
                                 .equ ADC_SAMPDLY_DLY15_gc = (0x0F<<0)    ; Delay 15 CLK_ADC cycles
                                 
                                 ; Window Comparator Mode select
                                 .equ ADC_WINCM_NONE_gc = (0x00<<0)       ; No Window Comparison
                                 .equ ADC_WINCM_BELOW_gc = (0x01<<0)      ; Below Window
                                 .equ ADC_WINCM_ABOVE_gc = (0x02<<0)      ; Above Window
                                 .equ ADC_WINCM_INSIDE_gc = (0x03<<0)     ; Inside Window
                                 .equ ADC_WINCM_OUTSIDE_gc = (0x04<<0)    ; Outside Window
                                 
                                 ; Analog Channel Selection Bits select
                                 .equ ADC_MUXNEG_AIN0_gc = (0x00<<0)      ; ADC input pin 0
                                 .equ ADC_MUXNEG_AIN1_gc = (0x01<<0)      ; ADC input pin 1
                                 .equ ADC_MUXNEG_AIN2_gc = (0x02<<0)      ; ADC input pin 2
                                 .equ ADC_MUXNEG_AIN3_gc = (0x03<<0)      ; ADC input pin 3
                                 .equ ADC_MUXNEG_AIN4_gc = (0x04<<0)      ; ADC input pin 4
                                 .equ ADC_MUXNEG_AIN5_gc = (0x05<<0)      ; ADC input pin 5
                                 .equ ADC_MUXNEG_AIN6_gc = (0x06<<0)      ; ADC input pin 6
                                 .equ ADC_MUXNEG_AIN7_gc = (0x07<<0)      ; ADC input pin 7
                                 .equ ADC_MUXNEG_AIN8_gc = (0x08<<0)      ; ADC input pin 8
                                 .equ ADC_MUXNEG_AIN9_gc = (0x09<<0)      ; ADC input pin 9
                                 .equ ADC_MUXNEG_AIN10_gc = (0x0A<<0)     ; ADC input pin 10
                                 .equ ADC_MUXNEG_AIN11_gc = (0x0B<<0)     ; ADC input pin 11
                                 .equ ADC_MUXNEG_AIN12_gc = (0x0C<<0)     ; ADC input pin 12
                                 .equ ADC_MUXNEG_AIN13_gc = (0x0D<<0)     ; ADC input pin 13
                                 .equ ADC_MUXNEG_AIN14_gc = (0x0E<<0)     ; ADC input pin 14
                                 .equ ADC_MUXNEG_AIN15_gc = (0x0F<<0)     ; ADC input pin 15
                                 .equ ADC_MUXNEG_GND_gc = (0x40<<0)       ; Ground
                                 .equ ADC_MUXNEG_DAC0_gc = (0x48<<0)      ; DAC0
                                 
                                 ; Analog Channel Selection Bits select
                                 .equ ADC_MUXPOS_AIN0_gc = (0x00<<0)      ; ADC input pin 0
                                 .equ ADC_MUXPOS_AIN1_gc = (0x01<<0)      ; ADC input pin 1
                                 .equ ADC_MUXPOS_AIN2_gc = (0x02<<0)      ; ADC input pin 2
                                 .equ ADC_MUXPOS_AIN3_gc = (0x03<<0)      ; ADC input pin 3
                                 .equ ADC_MUXPOS_AIN4_gc = (0x04<<0)      ; ADC input pin 4
                                 .equ ADC_MUXPOS_AIN5_gc = (0x05<<0)      ; ADC input pin 5
                                 .equ ADC_MUXPOS_AIN6_gc = (0x06<<0)      ; ADC input pin 6
                                 .equ ADC_MUXPOS_AIN7_gc = (0x07<<0)      ; ADC input pin 7
                                 .equ ADC_MUXPOS_AIN8_gc = (0x08<<0)      ; ADC input pin 8
                                 .equ ADC_MUXPOS_AIN9_gc = (0x09<<0)      ; ADC input pin 9
                                 .equ ADC_MUXPOS_AIN10_gc = (0x0A<<0)     ; ADC input pin 10
                                 .equ ADC_MUXPOS_AIN11_gc = (0x0B<<0)     ; ADC input pin 11
                                 .equ ADC_MUXPOS_AIN12_gc = (0x0C<<0)     ; ADC input pin 12
                                 .equ ADC_MUXPOS_AIN13_gc = (0x0D<<0)     ; ADC input pin 13
                                 .equ ADC_MUXPOS_AIN14_gc = (0x0E<<0)     ; ADC input pin 14
                                 .equ ADC_MUXPOS_AIN15_gc = (0x0F<<0)     ; ADC input pin 15
                                 .equ ADC_MUXPOS_AIN16_gc = (0x10<<0)     ; ADC input pin 16
                                 .equ ADC_MUXPOS_AIN17_gc = (0x11<<0)     ; ADC input pin 17
                                 .equ ADC_MUXPOS_AIN18_gc = (0x12<<0)     ; ADC input pin 18
                                 .equ ADC_MUXPOS_AIN19_gc = (0x13<<0)     ; ADC input pin 19
                                 .equ ADC_MUXPOS_AIN20_gc = (0x14<<0)     ; ADC input pin 20
                                 .equ ADC_MUXPOS_AIN21_gc = (0x15<<0)     ; ADC input pin 21
                                 .equ ADC_MUXPOS_GND_gc = (0x40<<0)       ; Ground
                                 .equ ADC_MUXPOS_TEMPSENSE_gc = (0x42<<0) ; Temperature sensor
                                 .equ ADC_MUXPOS_VDDDIV10_gc = (0x44<<0)  ; VDD/10
                                 .equ ADC_MUXPOS_VDDIO2DIV10_gc = (0x45<<0) ; VDDIO2/10
                                 .equ ADC_MUXPOS_DAC0_gc = (0x48<<0)      ; DAC0
                                 
                                 
                                 ;*************************************************************************
                                 ;** BOD - Bod interface
                                 ;*************************************************************************
                                 
                                 ; BOD_CTRLA masks
                                 .equ BOD_ACTIVE_gm = 0x0C                ; Operation in active mode group mask
                                 .equ BOD_ACTIVE_gp = 2                   ; Operation in active mode group position
                                 .equ BOD_ACTIVE0_bm = (1<<2)             ; Operation in active mode bit 0 mask
                                 .equ BOD_ACTIVE0_bp = 2                  ; Operation in active mode bit 0 position
                                 .equ BOD_ACTIVE1_bm = (1<<3)             ; Operation in active mode bit 1 mask
                                 .equ BOD_ACTIVE1_bp = 3                  ; Operation in active mode bit 1 position
                                 .equ BOD_SAMPFREQ_bm = 0x10              ; Sample frequency bit mask
                                 .equ BOD_SAMPFREQ_bp = 4                 ; Sample frequency bit position
                                 .equ BOD_SLEEP_gm = 0x03                 ; Operation in sleep mode group mask
                                 .equ BOD_SLEEP_gp = 0                    ; Operation in sleep mode group position
                                 .equ BOD_SLEEP0_bm = (1<<0)              ; Operation in sleep mode bit 0 mask
                                 .equ BOD_SLEEP0_bp = 0                   ; Operation in sleep mode bit 0 position
                                 .equ BOD_SLEEP1_bm = (1<<1)              ; Operation in sleep mode bit 1 mask
                                 .equ BOD_SLEEP1_bp = 1                   ; Operation in sleep mode bit 1 position
                                 
                                 ; BOD_CTRLB masks
                                 .equ BOD_LVL_gm = 0x07                   ; Bod level group mask
                                 .equ BOD_LVL_gp = 0                      ; Bod level group position
                                 .equ BOD_LVL0_bm = (1<<0)                ; Bod level bit 0 mask
                                 .equ BOD_LVL0_bp = 0                     ; Bod level bit 0 position
                                 .equ BOD_LVL1_bm = (1<<1)                ; Bod level bit 1 mask
                                 .equ BOD_LVL1_bp = 1                     ; Bod level bit 1 position
                                 .equ BOD_LVL2_bm = (1<<2)                ; Bod level bit 2 mask
                                 .equ BOD_LVL2_bp = 2                     ; Bod level bit 2 position
                                 
                                 ; BOD_INTCTRL masks
                                 .equ BOD_VLMCFG_gm = 0x06                ; Configuration group mask
                                 .equ BOD_VLMCFG_gp = 1                   ; Configuration group position
                                 .equ BOD_VLMCFG0_bm = (1<<1)             ; Configuration bit 0 mask
                                 .equ BOD_VLMCFG0_bp = 1                  ; Configuration bit 0 position
                                 .equ BOD_VLMCFG1_bm = (1<<2)             ; Configuration bit 1 mask
                                 .equ BOD_VLMCFG1_bp = 2                  ; Configuration bit 1 position
                                 .equ BOD_VLMIE_bm = 0x01                 ; voltage level monitor interrrupt enable bit mask
                                 .equ BOD_VLMIE_bp = 0                    ; voltage level monitor interrrupt enable bit position
                                 
                                 ; BOD_INTFLAGS masks
                                 .equ BOD_VLMIF_bm = 0x01                 ; Voltage level monitor interrupt flag bit mask
                                 .equ BOD_VLMIF_bp = 0                    ; Voltage level monitor interrupt flag bit position
                                 
                                 ; BOD_STATUS masks
                                 .equ BOD_VLMS_bm = 0x01                  ; Voltage level monitor status bit mask
                                 .equ BOD_VLMS_bp = 0                     ; Voltage level monitor status bit position
                                 
                                 ; BOD_VLMCTRLA masks
                                 .equ BOD_VLMLVL_gm = 0x03                ; voltage level monitor level group mask
                                 .equ BOD_VLMLVL_gp = 0                   ; voltage level monitor level group position
                                 .equ BOD_VLMLVL0_bm = (1<<0)             ; voltage level monitor level bit 0 mask
                                 .equ BOD_VLMLVL0_bp = 0                  ; voltage level monitor level bit 0 position
                                 .equ BOD_VLMLVL1_bm = (1<<1)             ; voltage level monitor level bit 1 mask
                                 .equ BOD_VLMLVL1_bp = 1                  ; voltage level monitor level bit 1 position
                                 
                                 ; Operation in active mode select
                                 .equ BOD_ACTIVE_DIS_gc = (0x00<<2)       ; Disabled
                                 .equ BOD_ACTIVE_ENABLED_gc = (0x01<<2)   ; Enabled
                                 .equ BOD_ACTIVE_SAMPLED_gc = (0x02<<2)   ; Sampled
                                 .equ BOD_ACTIVE_ENWAKE_gc = (0x03<<2)    ; Enabled with wake-up halted until BOD is ready
                                 
                                 ; Sample frequency select
                                 .equ BOD_SAMPFREQ_128HZ_gc = (0x00<<4)   ; 128Hz sampling frequency
                                 .equ BOD_SAMPFREQ_32HZ_gc = (0x01<<4)    ; 32Hz sampling frequency
                                 
                                 ; Operation in sleep mode select
                                 .equ BOD_SLEEP_DIS_gc = (0x00<<0)        ; Disabled
                                 .equ BOD_SLEEP_ENABLED_gc = (0x01<<0)    ; Enabled
                                 .equ BOD_SLEEP_SAMPLED_gc = (0x02<<0)    ; Sampled
                                 
                                 ; Bod level select
                                 .equ BOD_LVL_BODLEVEL0_gc = (0x00<<0)    ; 1.9 V
                                 .equ BOD_LVL_BODLEVEL1_gc = (0x01<<0)    ; 2.45 V
                                 .equ BOD_LVL_BODLEVEL2_gc = (0x02<<0)    ; 2.7 V
                                 .equ BOD_LVL_BODLEVEL3_gc = (0x03<<0)    ; 2.85 V
                                 
                                 ; Configuration select
                                 .equ BOD_VLMCFG_FALLING_gc = (0x00<<1)   ; VDD falls below VLM threshold
                                 .equ BOD_VLMCFG_RISING_gc = (0x01<<1)    ; VDD rises above VLM threshold
                                 .equ BOD_VLMCFG_BOTH_gc = (0x02<<1)      ; VDD crosses VLM threshold
                                 
                                 ; Voltage level monitor status select
                                 .equ BOD_VLMS_ABOVE_gc = (0x00<<0)       ; The voltage is above the VLM threshold level
                                 .equ BOD_VLMS_BELOW_gc = (0x01<<0)       ; The voltage is below the VLM threshold level
                                 
                                 ; voltage level monitor level select
                                 .equ BOD_VLMLVL_OFF_gc = (0x00<<0)       ; VLM Disabled
                                 .equ BOD_VLMLVL_5ABOVE_gc = (0x01<<0)    ; VLM threshold 5% above BOD level
                                 .equ BOD_VLMLVL_15ABOVE_gc = (0x02<<0)   ; VLM threshold 15% above BOD level
                                 .equ BOD_VLMLVL_25ABOVE_gc = (0x03<<0)   ; VLM threshold 25% above BOD level
                                 
                                 
                                 ;*************************************************************************
                                 ;** CCL - Configurable Custom Logic
                                 ;*************************************************************************
                                 
                                 ; CCL_LUT0CTRLA masks
                                 .equ CCL_CLKSRC_gm = 0x0E                ; Clock Source Selection group mask
                                 .equ CCL_CLKSRC_gp = 1                   ; Clock Source Selection group position
                                 .equ CCL_CLKSRC0_bm = (1<<1)             ; Clock Source Selection bit 0 mask
                                 .equ CCL_CLKSRC0_bp = 1                  ; Clock Source Selection bit 0 position
                                 .equ CCL_CLKSRC1_bm = (1<<2)             ; Clock Source Selection bit 1 mask
                                 .equ CCL_CLKSRC1_bp = 2                  ; Clock Source Selection bit 1 position
                                 .equ CCL_CLKSRC2_bm = (1<<3)             ; Clock Source Selection bit 2 mask
                                 .equ CCL_CLKSRC2_bp = 3                  ; Clock Source Selection bit 2 position
                                 .equ CCL_EDGEDET_bm = 0x80               ; Edge Detection Enable bit mask
                                 .equ CCL_EDGEDET_bp = 7                  ; Edge Detection Enable bit position
                                 .equ CCL_ENABLE_bm = 0x01                ; LUT Enable bit mask
                                 .equ CCL_ENABLE_bp = 0                   ; LUT Enable bit position
                                 .equ CCL_FILTSEL_gm = 0x30               ; Filter Selection group mask
                                 .equ CCL_FILTSEL_gp = 4                  ; Filter Selection group position
                                 .equ CCL_FILTSEL0_bm = (1<<4)            ; Filter Selection bit 0 mask
                                 .equ CCL_FILTSEL0_bp = 4                 ; Filter Selection bit 0 position
                                 .equ CCL_FILTSEL1_bm = (1<<5)            ; Filter Selection bit 1 mask
                                 .equ CCL_FILTSEL1_bp = 5                 ; Filter Selection bit 1 position
                                 .equ CCL_OUTEN_bm = 0x40                 ; Output Enable bit mask
                                 .equ CCL_OUTEN_bp = 6                    ; Output Enable bit position
                                 
                                 ; CCL_LUT1CTRLA masks
                                 ; Masks for CCL_CLKSRC already defined
                                 ; Masks for CCL_EDGEDET already defined
                                 ; Masks for CCL_ENABLE already defined
                                 ; Masks for CCL_FILTSEL already defined
                                 ; Masks for CCL_OUTEN already defined
                                 
                                 ; CCL_LUT2CTRLA masks
                                 ; Masks for CCL_CLKSRC already defined
                                 ; Masks for CCL_EDGEDET already defined
                                 ; Masks for CCL_ENABLE already defined
                                 ; Masks for CCL_FILTSEL already defined
                                 ; Masks for CCL_OUTEN already defined
                                 
                                 ; CCL_LUT3CTRLA masks
                                 ; Masks for CCL_CLKSRC already defined
                                 ; Masks for CCL_EDGEDET already defined
                                 ; Masks for CCL_ENABLE already defined
                                 ; Masks for CCL_FILTSEL already defined
                                 ; Masks for CCL_OUTEN already defined
                                 
                                 ; CCL_LUT4CTRLA masks
                                 ; Masks for CCL_CLKSRC already defined
                                 ; Masks for CCL_EDGEDET already defined
                                 ; Masks for CCL_ENABLE already defined
                                 ; Masks for CCL_FILTSEL already defined
                                 ; Masks for CCL_OUTEN already defined
                                 
                                 ; CCL_LUT5CTRLA masks
                                 ; Masks for CCL_CLKSRC already defined
                                 ; Masks for CCL_EDGEDET already defined
                                 ; Masks for CCL_ENABLE already defined
                                 ; Masks for CCL_FILTSEL already defined
                                 ; Masks for CCL_OUTEN already defined
                                 
                                 ; CCL_LUT0CTRLB masks
                                 .equ CCL_INSEL0_gm = 0x0F                ; LUT Input 0 Source Selection group mask
                                 .equ CCL_INSEL0_gp = 0                   ; LUT Input 0 Source Selection group position
                                 .equ CCL_INSEL00_bm = (1<<0)             ; LUT Input 0 Source Selection bit 0 mask
                                 .equ CCL_INSEL00_bp = 0                  ; LUT Input 0 Source Selection bit 0 position
                                 .equ CCL_INSEL01_bm = (1<<1)             ; LUT Input 0 Source Selection bit 1 mask
                                 .equ CCL_INSEL01_bp = 1                  ; LUT Input 0 Source Selection bit 1 position
                                 .equ CCL_INSEL02_bm = (1<<2)             ; LUT Input 0 Source Selection bit 2 mask
                                 .equ CCL_INSEL02_bp = 2                  ; LUT Input 0 Source Selection bit 2 position
                                 .equ CCL_INSEL03_bm = (1<<3)             ; LUT Input 0 Source Selection bit 3 mask
                                 .equ CCL_INSEL03_bp = 3                  ; LUT Input 0 Source Selection bit 3 position
                                 .equ CCL_INSEL1_gm = 0xF0                ; LUT Input 1 Source Selection group mask
                                 .equ CCL_INSEL1_gp = 4                   ; LUT Input 1 Source Selection group position
                                 .equ CCL_INSEL10_bm = (1<<4)             ; LUT Input 1 Source Selection bit 0 mask
                                 .equ CCL_INSEL10_bp = 4                  ; LUT Input 1 Source Selection bit 0 position
                                 .equ CCL_INSEL11_bm = (1<<5)             ; LUT Input 1 Source Selection bit 1 mask
                                 .equ CCL_INSEL11_bp = 5                  ; LUT Input 1 Source Selection bit 1 position
                                 .equ CCL_INSEL12_bm = (1<<6)             ; LUT Input 1 Source Selection bit 2 mask
                                 .equ CCL_INSEL12_bp = 6                  ; LUT Input 1 Source Selection bit 2 position
                                 .equ CCL_INSEL13_bm = (1<<7)             ; LUT Input 1 Source Selection bit 3 mask
                                 .equ CCL_INSEL13_bp = 7                  ; LUT Input 1 Source Selection bit 3 position
                                 
                                 ; CCL_LUT1CTRLB masks
                                 ; Masks for CCL_INSEL0 already defined
                                 ; Masks for CCL_INSEL1 already defined
                                 
                                 ; CCL_LUT2CTRLB masks
                                 ; Masks for CCL_INSEL0 already defined
                                 ; Masks for CCL_INSEL1 already defined
                                 
                                 ; CCL_LUT3CTRLB masks
                                 ; Masks for CCL_INSEL0 already defined
                                 ; Masks for CCL_INSEL1 already defined
                                 
                                 ; CCL_LUT4CTRLB masks
                                 ; Masks for CCL_INSEL0 already defined
                                 ; Masks for CCL_INSEL1 already defined
                                 
                                 ; CCL_LUT5CTRLB masks
                                 ; Masks for CCL_INSEL0 already defined
                                 ; Masks for CCL_INSEL1 already defined
                                 
                                 ; CCL_LUT0CTRLC masks
                                 .equ CCL_INSEL2_gm = 0x0F                ; LUT Input 2 Source Selection group mask
                                 .equ CCL_INSEL2_gp = 0                   ; LUT Input 2 Source Selection group position
                                 .equ CCL_INSEL20_bm = (1<<0)             ; LUT Input 2 Source Selection bit 0 mask
                                 .equ CCL_INSEL20_bp = 0                  ; LUT Input 2 Source Selection bit 0 position
                                 .equ CCL_INSEL21_bm = (1<<1)             ; LUT Input 2 Source Selection bit 1 mask
                                 .equ CCL_INSEL21_bp = 1                  ; LUT Input 2 Source Selection bit 1 position
                                 .equ CCL_INSEL22_bm = (1<<2)             ; LUT Input 2 Source Selection bit 2 mask
                                 .equ CCL_INSEL22_bp = 2                  ; LUT Input 2 Source Selection bit 2 position
                                 .equ CCL_INSEL23_bm = (1<<3)             ; LUT Input 2 Source Selection bit 3 mask
                                 .equ CCL_INSEL23_bp = 3                  ; LUT Input 2 Source Selection bit 3 position
                                 
                                 ; CCL_LUT1CTRLC masks
                                 ; Masks for CCL_INSEL2 already defined
                                 
                                 ; CCL_LUT2CTRLC masks
                                 ; Masks for CCL_INSEL2 already defined
                                 
                                 ; CCL_LUT3CTRLC masks
                                 ; Masks for CCL_INSEL2 already defined
                                 
                                 ; CCL_LUT4CTRLC masks
                                 ; Masks for CCL_INSEL2 already defined
                                 
                                 ; CCL_LUT5CTRLC masks
                                 ; Masks for CCL_INSEL2 already defined
                                 
                                 ; CCL_TRUTH0 masks
                                 .equ CCL_TRUTH_gm = 0xFF                 ; Truth Table group mask
                                 .equ CCL_TRUTH_gp = 0                    ; Truth Table group position
                                 .equ CCL_TRUTH0_bm = (1<<0)              ; Truth Table bit 0 mask
                                 .equ CCL_TRUTH0_bp = 0                   ; Truth Table bit 0 position
                                 .equ CCL_TRUTH1_bm = (1<<1)              ; Truth Table bit 1 mask
                                 .equ CCL_TRUTH1_bp = 1                   ; Truth Table bit 1 position
                                 .equ CCL_TRUTH2_bm = (1<<2)              ; Truth Table bit 2 mask
                                 .equ CCL_TRUTH2_bp = 2                   ; Truth Table bit 2 position
                                 .equ CCL_TRUTH3_bm = (1<<3)              ; Truth Table bit 3 mask
                                 .equ CCL_TRUTH3_bp = 3                   ; Truth Table bit 3 position
                                 .equ CCL_TRUTH4_bm = (1<<4)              ; Truth Table bit 4 mask
                                 .equ CCL_TRUTH4_bp = 4                   ; Truth Table bit 4 position
                                 .equ CCL_TRUTH5_bm = (1<<5)              ; Truth Table bit 5 mask
                                 .equ CCL_TRUTH5_bp = 5                   ; Truth Table bit 5 position
                                 .equ CCL_TRUTH6_bm = (1<<6)              ; Truth Table bit 6 mask
                                 .equ CCL_TRUTH6_bp = 6                   ; Truth Table bit 6 position
                                 .equ CCL_TRUTH7_bm = (1<<7)              ; Truth Table bit 7 mask
                                 .equ CCL_TRUTH7_bp = 7                   ; Truth Table bit 7 position
                                 
                                 ; CCL_TRUTH1 masks
                                 ; Masks for CCL_TRUTH already defined
                                 
                                 ; CCL_TRUTH2 masks
                                 ; Masks for CCL_TRUTH already defined
                                 
                                 ; CCL_TRUTH3 masks
                                 ; Masks for CCL_TRUTH already defined
                                 
                                 ; CCL_TRUTH4 masks
                                 ; Masks for CCL_TRUTH already defined
                                 
                                 ; CCL_TRUTH5 masks
                                 ; Masks for CCL_TRUTH already defined
                                 
                                 ; CCL_SEQCTRL0 masks
                                 .equ CCL_SEQSEL_gm = 0x07                ; Sequential Selection group mask
                                 .equ CCL_SEQSEL_gp = 0                   ; Sequential Selection group position
                                 .equ CCL_SEQSEL0_bm = (1<<0)             ; Sequential Selection bit 0 mask
                                 .equ CCL_SEQSEL0_bp = 0                  ; Sequential Selection bit 0 position
                                 .equ CCL_SEQSEL1_bm = (1<<1)             ; Sequential Selection bit 1 mask
                                 .equ CCL_SEQSEL1_bp = 1                  ; Sequential Selection bit 1 position
                                 .equ CCL_SEQSEL2_bm = (1<<2)             ; Sequential Selection bit 2 mask
                                 .equ CCL_SEQSEL2_bp = 2                  ; Sequential Selection bit 2 position
                                 
                                 ; CCL_SEQCTRL1 masks
                                 ; Masks for CCL_SEQSEL already defined
                                 
                                 ; CCL_SEQCTRL2 masks
                                 ; Masks for CCL_SEQSEL already defined
                                 
                                 ; CCL_CTRLA masks
                                 ; Masks for CCL_ENABLE already defined
                                 .equ CCL_RUNSTDBY_bm = 0x40              ; Run in Standby bit mask
                                 .equ CCL_RUNSTDBY_bp = 6                 ; Run in Standby bit position
                                 
                                 ; CCL_INTCTRL0 masks
                                 .equ CCL_INTMODE0_gm = 0x03              ; Interrupt Mode for LUT0 group mask
                                 .equ CCL_INTMODE0_gp = 0                 ; Interrupt Mode for LUT0 group position
                                 .equ CCL_INTMODE00_bm = (1<<0)           ; Interrupt Mode for LUT0 bit 0 mask
                                 .equ CCL_INTMODE00_bp = 0                ; Interrupt Mode for LUT0 bit 0 position
                                 .equ CCL_INTMODE01_bm = (1<<1)           ; Interrupt Mode for LUT0 bit 1 mask
                                 .equ CCL_INTMODE01_bp = 1                ; Interrupt Mode for LUT0 bit 1 position
                                 .equ CCL_INTMODE1_gm = 0x0C              ; Interrupt Mode for LUT1 group mask
                                 .equ CCL_INTMODE1_gp = 2                 ; Interrupt Mode for LUT1 group position
                                 .equ CCL_INTMODE10_bm = (1<<2)           ; Interrupt Mode for LUT1 bit 0 mask
                                 .equ CCL_INTMODE10_bp = 2                ; Interrupt Mode for LUT1 bit 0 position
                                 .equ CCL_INTMODE11_bm = (1<<3)           ; Interrupt Mode for LUT1 bit 1 mask
                                 .equ CCL_INTMODE11_bp = 3                ; Interrupt Mode for LUT1 bit 1 position
                                 .equ CCL_INTMODE2_gm = 0x30              ; Interrupt Mode for LUT2 group mask
                                 .equ CCL_INTMODE2_gp = 4                 ; Interrupt Mode for LUT2 group position
                                 .equ CCL_INTMODE20_bm = (1<<4)           ; Interrupt Mode for LUT2 bit 0 mask
                                 .equ CCL_INTMODE20_bp = 4                ; Interrupt Mode for LUT2 bit 0 position
                                 .equ CCL_INTMODE21_bm = (1<<5)           ; Interrupt Mode for LUT2 bit 1 mask
                                 .equ CCL_INTMODE21_bp = 5                ; Interrupt Mode for LUT2 bit 1 position
                                 .equ CCL_INTMODE3_gm = 0xC0              ; Interrupt Mode for LUT3 group mask
                                 .equ CCL_INTMODE3_gp = 6                 ; Interrupt Mode for LUT3 group position
                                 .equ CCL_INTMODE30_bm = (1<<6)           ; Interrupt Mode for LUT3 bit 0 mask
                                 .equ CCL_INTMODE30_bp = 6                ; Interrupt Mode for LUT3 bit 0 position
                                 .equ CCL_INTMODE31_bm = (1<<7)           ; Interrupt Mode for LUT3 bit 1 mask
                                 .equ CCL_INTMODE31_bp = 7                ; Interrupt Mode for LUT3 bit 1 position
                                 
                                 ; CCL_INTCTRL1 masks
                                 .equ CCL_INTMODE4_gm = 0x03              ; Interrupt Mode for LUT4 group mask
                                 .equ CCL_INTMODE4_gp = 0                 ; Interrupt Mode for LUT4 group position
                                 .equ CCL_INTMODE40_bm = (1<<0)           ; Interrupt Mode for LUT4 bit 0 mask
                                 .equ CCL_INTMODE40_bp = 0                ; Interrupt Mode for LUT4 bit 0 position
                                 .equ CCL_INTMODE41_bm = (1<<1)           ; Interrupt Mode for LUT4 bit 1 mask
                                 .equ CCL_INTMODE41_bp = 1                ; Interrupt Mode for LUT4 bit 1 position
                                 .equ CCL_INTMODE5_gm = 0x0C              ; Interrupt Mode for LUT5 group mask
                                 .equ CCL_INTMODE5_gp = 2                 ; Interrupt Mode for LUT5 group position
                                 .equ CCL_INTMODE50_bm = (1<<2)           ; Interrupt Mode for LUT5 bit 0 mask
                                 .equ CCL_INTMODE50_bp = 2                ; Interrupt Mode for LUT5 bit 0 position
                                 .equ CCL_INTMODE51_bm = (1<<3)           ; Interrupt Mode for LUT5 bit 1 mask
                                 .equ CCL_INTMODE51_bp = 3                ; Interrupt Mode for LUT5 bit 1 position
                                 
                                 ; CCL_INTFLAGS masks
                                 .equ CCL_INT_gm = 0x3F                   ; Interrupt Flag group mask
                                 .equ CCL_INT_gp = 0                      ; Interrupt Flag group position
                                 .equ CCL_INT0_bm = (1<<0)                ; Interrupt Flag bit 0 mask
                                 .equ CCL_INT0_bp = 0                     ; Interrupt Flag bit 0 position
                                 .equ CCL_INT1_bm = (1<<1)                ; Interrupt Flag bit 1 mask
                                 .equ CCL_INT1_bp = 1                     ; Interrupt Flag bit 1 position
                                 .equ CCL_INT2_bm = (1<<2)                ; Interrupt Flag bit 2 mask
                                 .equ CCL_INT2_bp = 2                     ; Interrupt Flag bit 2 position
                                 .equ CCL_INT3_bm = (1<<3)                ; Interrupt Flag bit 3 mask
                                 .equ CCL_INT3_bp = 3                     ; Interrupt Flag bit 3 position
                                 .equ CCL_INT4_bm = (1<<4)                ; Interrupt Flag bit 4 mask
                                 .equ CCL_INT4_bp = 4                     ; Interrupt Flag bit 4 position
                                 .equ CCL_INT5_bm = (1<<5)                ; Interrupt Flag bit 5 mask
                                 .equ CCL_INT5_bp = 5                     ; Interrupt Flag bit 5 position
                                 
                                 ; Interrupt Mode for LUT0 select
                                 .equ CCL_INTMODE0_INTDISABLE_gc = (0x00<<0) ; Interrupt disabled
                                 .equ CCL_INTMODE0_RISING_gc = (0x01<<0)  ; Sense rising edge
                                 .equ CCL_INTMODE0_FALLING_gc = (0x02<<0) ; Sense falling edge
                                 .equ CCL_INTMODE0_BOTH_gc = (0x03<<0)    ; Sense both edges
                                 
                                 ; Interrupt Mode for LUT1 select
                                 .equ CCL_INTMODE1_INTDISABLE_gc = (0x00<<2) ; Interrupt disabled
                                 .equ CCL_INTMODE1_RISING_gc = (0x01<<2)  ; Sense rising edge
                                 .equ CCL_INTMODE1_FALLING_gc = (0x02<<2) ; Sense falling edge
                                 .equ CCL_INTMODE1_BOTH_gc = (0x03<<2)    ; Sense both edges
                                 
                                 ; Interrupt Mode for LUT2 select
                                 .equ CCL_INTMODE2_INTDISABLE_gc = (0x00<<4) ; Interrupt disabled
                                 .equ CCL_INTMODE2_RISING_gc = (0x01<<4)  ; Sense rising edge
                                 .equ CCL_INTMODE2_FALLING_gc = (0x02<<4) ; Sense falling edge
                                 .equ CCL_INTMODE2_BOTH_gc = (0x03<<4)    ; Sense both edges
                                 
                                 ; Interrupt Mode for LUT3 select
                                 .equ CCL_INTMODE3_INTDISABLE_gc = (0x00<<6) ; Interrupt disabled
                                 .equ CCL_INTMODE3_RISING_gc = (0x01<<6)  ; Sense rising edge
                                 .equ CCL_INTMODE3_FALLING_gc = (0x02<<6) ; Sense falling edge
                                 .equ CCL_INTMODE3_BOTH_gc = (0x03<<6)    ; Sense both edges
                                 
                                 ; Interrupt Mode for LUT4 select
                                 .equ CCL_INTMODE4_INTDISABLE_gc = (0x00<<0) ; Interrupt disabled
                                 .equ CCL_INTMODE4_RISING_gc = (0x01<<0)  ; Sense rising edge
                                 .equ CCL_INTMODE4_FALLING_gc = (0x02<<0) ; Sense falling edge
                                 .equ CCL_INTMODE4_BOTH_gc = (0x03<<0)    ; Sense both edges
                                 
                                 ; Interrupt Mode for LUT5 select
                                 .equ CCL_INTMODE5_INTDISABLE_gc = (0x00<<2) ; Interrupt disabled
                                 .equ CCL_INTMODE5_RISING_gc = (0x01<<2)  ; Sense rising edge
                                 .equ CCL_INTMODE5_FALLING_gc = (0x02<<2) ; Sense falling edge
                                 .equ CCL_INTMODE5_BOTH_gc = (0x03<<2)    ; Sense both edges
                                 
                                 ; Clock Source Selection select
                                 .equ CCL_CLKSRC_CLKPER_gc = (0x00<<1)    ; Peripheral Clock
                                 .equ CCL_CLKSRC_IN2_gc = (0x01<<1)       ; Selection by INSEL2
                                 .equ CCL_CLKSRC_OSCHF_gc = (0x04<<1)     ; Internal High-Frequency Oscillator
                                 .equ CCL_CLKSRC_OSC32K_gc = (0x05<<1)    ; 32.768 kHz oscillator
                                 .equ CCL_CLKSRC_OSC1K_gc = (0x06<<1)     ; 32.768 kHz oscillator divided by 32
                                 
                                 ; Edge Detection Enable select
                                 .equ CCL_EDGEDET_DIS_gc = (0x00<<7)      ; Edge detector is disabled
                                 .equ CCL_EDGEDET_EN_gc = (0x01<<7)       ; Edge detector is enabled
                                 
                                 ; Filter Selection select
                                 .equ CCL_FILTSEL_DISABLE_gc = (0x00<<4)  ; Filter disabled
                                 .equ CCL_FILTSEL_SYNCH_gc = (0x01<<4)    ; Synchronizer enabled
                                 .equ CCL_FILTSEL_FILTER_gc = (0x02<<4)   ; Filter enabled
                                 
                                 ; LUT Input 0 Source Selection select
                                 .equ CCL_INSEL0_MASK_gc = (0x00<<0)      ; Masked input
                                 .equ CCL_INSEL0_FEEDBACK_gc = (0x01<<0)  ; Feedback input source
                                 .equ CCL_INSEL0_LINK_gc = (0x02<<0)      ; Linked LUT input source
                                 .equ CCL_INSEL0_EVENTA_gc = (0x03<<0)    ; Event input source A
                                 .equ CCL_INSEL0_EVENTB_gc = (0x04<<0)    ; Event input source B
                                 .equ CCL_INSEL0_IN0_gc = (0x05<<0)       ; IO pin LUTn-IN0 input source
                                 .equ CCL_INSEL0_AC0_gc = (0x06<<0)       ; AC0 OUT input source
                                 .equ CCL_INSEL0_ZCD0_gc = (0x07<<0)      ; ZCD0 OUT input source
                                 .equ CCL_INSEL0_USART0_gc = (0x08<<0)    ; USART0 TXD input source
                                 .equ CCL_INSEL0_SPI0_gc = (0x09<<0)      ; SPI0 MOSI input source
                                 .equ CCL_INSEL0_TCA0_gc = (0x0A<<0)      ; TCA0 WO0 input source
                                 .equ CCL_INSEL0_TCA1_gc = (0x0B<<0)      ; TCA1 WO0 input source
                                 .equ CCL_INSEL0_TCB0_gc = (0x0C<<0)      ; TCB0 WO input source
                                 .equ CCL_INSEL0_TCD0_gc = (0x0D<<0)      ; TCD0 WOA input source
                                 
                                 ; LUT Input 1 Source Selection select
                                 .equ CCL_INSEL1_MASK_gc = (0x00<<4)      ; Masked input
                                 .equ CCL_INSEL1_FEEDBACK_gc = (0x01<<4)  ; Feedback input source
                                 .equ CCL_INSEL1_LINK_gc = (0x02<<4)      ; Linked LUT input source
                                 .equ CCL_INSEL1_EVENTA_gc = (0x03<<4)    ; Event input source A
                                 .equ CCL_INSEL1_EVENTB_gc = (0x04<<4)    ; Event input source B
                                 .equ CCL_INSEL1_IN1_gc = (0x05<<4)       ; IO pin LUTn-IN1 input source
                                 .equ CCL_INSEL1_AC1_gc = (0x06<<4)       ; AC1 OUT input source
                                 .equ CCL_INSEL1_ZCD1_gc = (0x07<<4)      ; ZCD1 OUT input source
                                 .equ CCL_INSEL1_USART1_gc = (0x08<<4)    ; USART1 TXD input source
                                 .equ CCL_INSEL1_SPI0_gc = (0x09<<4)      ; SPI0 MOSI input source
                                 .equ CCL_INSEL1_TCA0_gc = (0x0A<<4)      ; TCA0 WO1 input source
                                 .equ CCL_INSEL1_TCA1_gc = (0x0B<<4)      ; TCA1 WO1 input source
                                 .equ CCL_INSEL1_TCB1_gc = (0x0C<<4)      ; TCB1 WO input source
                                 .equ CCL_INSEL1_TCD0_gc = (0x0D<<4)      ; TCD0 WOB input source
                                 
                                 ; LUT Input 2 Source Selection select
                                 .equ CCL_INSEL2_MASK_gc = (0x00<<0)      ; Masked input
                                 .equ CCL_INSEL2_FEEDBACK_gc = (0x01<<0)  ; Feedback input source
                                 .equ CCL_INSEL2_LINK_gc = (0x02<<0)      ; Linked LUT input source
                                 .equ CCL_INSEL2_EVENTA_gc = (0x03<<0)    ; Event input source A
                                 .equ CCL_INSEL2_EVENTB_gc = (0x04<<0)    ; Event input source B
                                 .equ CCL_INSEL2_IN2_gc = (0x05<<0)       ; IO pin LUTn-IN2 input source
                                 .equ CCL_INSEL2_AC2_gc = (0x06<<0)       ; AC2 OUT input source
                                 .equ CCL_INSEL2_ZCD2_gc = (0x07<<0)      ; ZCD2 OUT input source
                                 .equ CCL_INSEL2_USART2_gc = (0x08<<0)    ; USART2 TXD input source
                                 .equ CCL_INSEL2_SPI0_gc = (0x09<<0)      ; SPI0 SCK input source
                                 .equ CCL_INSEL2_TCA0_gc = (0x0A<<0)      ; TCA0 WO2 input source
                                 .equ CCL_INSEL2_TCA1_gc = (0x0B<<0)      ; TCA1 WO2 input source
                                 .equ CCL_INSEL2_TCB2_gc = (0x0C<<0)      ; TCB2 WO input source
                                 .equ CCL_INSEL2_TCD0_gc = (0x0D<<0)      ; TCD0 WOC input source
                                 
                                 ; Sequential Selection select
                                 .equ CCL_SEQSEL_DISABLE_gc = (0x00<<0)   ; Sequential logic disabled
                                 .equ CCL_SEQSEL_DFF_gc = (0x01<<0)       ; D FlipFlop
                                 .equ CCL_SEQSEL_JK_gc = (0x02<<0)        ; JK FlipFlop
                                 .equ CCL_SEQSEL_LATCH_gc = (0x03<<0)     ; D Latch
                                 .equ CCL_SEQSEL_RS_gc = (0x04<<0)        ; RS Latch
                                 
                                 
                                 ;*************************************************************************
                                 ;** CLKCTRL - Clock controller
                                 ;*************************************************************************
                                 
                                 ; CLKCTRL_MCLKCTRLA masks
                                 .equ CLKCTRL_CLKOUT_bm = 0x80            ; System clock out bit mask
                                 .equ CLKCTRL_CLKOUT_bp = 7               ; System clock out bit position
                                 .equ CLKCTRL_CLKSEL_gm = 0x07            ; clock select group mask
                                 .equ CLKCTRL_CLKSEL_gp = 0               ; clock select group position
                                 .equ CLKCTRL_CLKSEL0_bm = (1<<0)         ; clock select bit 0 mask
                                 .equ CLKCTRL_CLKSEL0_bp = 0              ; clock select bit 0 position
                                 .equ CLKCTRL_CLKSEL1_bm = (1<<1)         ; clock select bit 1 mask
                                 .equ CLKCTRL_CLKSEL1_bp = 1              ; clock select bit 1 position
                                 .equ CLKCTRL_CLKSEL2_bm = (1<<2)         ; clock select bit 2 mask
                                 .equ CLKCTRL_CLKSEL2_bp = 2              ; clock select bit 2 position
                                 
                                 ; CLKCTRL_MCLKCTRLB masks
                                 .equ CLKCTRL_PDIV_gm = 0x1E              ; Prescaler division group mask
                                 .equ CLKCTRL_PDIV_gp = 1                 ; Prescaler division group position
                                 .equ CLKCTRL_PDIV0_bm = (1<<1)           ; Prescaler division bit 0 mask
                                 .equ CLKCTRL_PDIV0_bp = 1                ; Prescaler division bit 0 position
                                 .equ CLKCTRL_PDIV1_bm = (1<<2)           ; Prescaler division bit 1 mask
                                 .equ CLKCTRL_PDIV1_bp = 2                ; Prescaler division bit 1 position
                                 .equ CLKCTRL_PDIV2_bm = (1<<3)           ; Prescaler division bit 2 mask
                                 .equ CLKCTRL_PDIV2_bp = 3                ; Prescaler division bit 2 position
                                 .equ CLKCTRL_PDIV3_bm = (1<<4)           ; Prescaler division bit 3 mask
                                 .equ CLKCTRL_PDIV3_bp = 4                ; Prescaler division bit 3 position
                                 .equ CLKCTRL_PEN_bm = 0x01               ; Prescaler enable bit mask
                                 .equ CLKCTRL_PEN_bp = 0                  ; Prescaler enable bit position
                                 
                                 ; CLKCTRL_MCLKCTRLC masks
                                 .equ CLKCTRL_CFDEN_bm = 0x01             ; Clock Failure Detect Enable bit mask
                                 .equ CLKCTRL_CFDEN_bp = 0                ; Clock Failure Detect Enable bit position
                                 .equ CLKCTRL_CFDSRC_gm = 0x0C            ; Clock Failure Detect Source group mask
                                 .equ CLKCTRL_CFDSRC_gp = 2               ; Clock Failure Detect Source group position
                                 .equ CLKCTRL_CFDSRC0_bm = (1<<2)         ; Clock Failure Detect Source bit 0 mask
                                 .equ CLKCTRL_CFDSRC0_bp = 2              ; Clock Failure Detect Source bit 0 position
                                 .equ CLKCTRL_CFDSRC1_bm = (1<<3)         ; Clock Failure Detect Source bit 1 mask
                                 .equ CLKCTRL_CFDSRC1_bp = 3              ; Clock Failure Detect Source bit 1 position
                                 .equ CLKCTRL_CFDTST_bm = 0x02            ; Clock Failure Detect Test bit mask
                                 .equ CLKCTRL_CFDTST_bp = 1               ; Clock Failure Detect Test bit position
                                 
                                 ; CLKCTRL_MCLKINTCTRL masks
                                 .equ CLKCTRL_CFD_bm = 0x01               ; Clock Failure Detect Interrupt Enable bit mask
                                 .equ CLKCTRL_CFD_bp = 0                  ; Clock Failure Detect Interrupt Enable bit position
                                 .equ CLKCTRL_INTTYPE_bm = 0x80           ; Interrupt type bit mask
                                 .equ CLKCTRL_INTTYPE_bp = 7              ; Interrupt type bit position
                                 
                                 ; CLKCTRL_MCLKINTFLAGS masks
                                 ; Masks for CLKCTRL_CFD already defined
                                 
                                 ; CLKCTRL_MCLKSTATUS masks
                                 .equ CLKCTRL_EXTS_bm = 0x10              ; External Clock status bit mask
                                 .equ CLKCTRL_EXTS_bp = 4                 ; External Clock status bit position
                                 .equ CLKCTRL_OSCHFS_bm = 0x02            ; High frequency oscillator status bit mask
                                 .equ CLKCTRL_OSCHFS_bp = 1               ; High frequency oscillator status bit position
                                 .equ CLKCTRL_OSC32KS_bm = 0x04           ; 32KHz oscillator status bit mask
                                 .equ CLKCTRL_OSC32KS_bp = 2              ; 32KHz oscillator status bit position
                                 .equ CLKCTRL_PLLS_bm = 0x20              ; PLL oscillator status bit mask
                                 .equ CLKCTRL_PLLS_bp = 5                 ; PLL oscillator status bit position
                                 .equ CLKCTRL_SOSC_bm = 0x01              ; System Oscillator changing bit mask
                                 .equ CLKCTRL_SOSC_bp = 0                 ; System Oscillator changing bit position
                                 .equ CLKCTRL_XOSC32KS_bm = 0x08          ; 32.768 kHz Crystal Oscillator status bit mask
                                 .equ CLKCTRL_XOSC32KS_bp = 3             ; 32.768 kHz Crystal Oscillator status bit position
                                 
                                 ; CLKCTRL_OSCHFCTRLA masks
                                 .equ CLKCTRL_AUTOTUNE_bm = 0x01          ; Autotune bit mask
                                 .equ CLKCTRL_AUTOTUNE_bp = 0             ; Autotune bit position
                                 .equ CLKCTRL_FRQSEL_gm = 0x3C            ; Frequency select group mask
                                 .equ CLKCTRL_FRQSEL_gp = 2               ; Frequency select group position
                                 .equ CLKCTRL_FRQSEL0_bm = (1<<2)         ; Frequency select bit 0 mask
                                 .equ CLKCTRL_FRQSEL0_bp = 2              ; Frequency select bit 0 position
                                 .equ CLKCTRL_FRQSEL1_bm = (1<<3)         ; Frequency select bit 1 mask
                                 .equ CLKCTRL_FRQSEL1_bp = 3              ; Frequency select bit 1 position
                                 .equ CLKCTRL_FRQSEL2_bm = (1<<4)         ; Frequency select bit 2 mask
                                 .equ CLKCTRL_FRQSEL2_bp = 4              ; Frequency select bit 2 position
                                 .equ CLKCTRL_FRQSEL3_bm = (1<<5)         ; Frequency select bit 3 mask
                                 .equ CLKCTRL_FRQSEL3_bp = 5              ; Frequency select bit 3 position
                                 .equ CLKCTRL_RUNSTDBY_bm = 0x80          ; Run standby bit mask
                                 .equ CLKCTRL_RUNSTDBY_bp = 7             ; Run standby bit position
                                 
                                 ; CLKCTRL_OSCHFTUNE masks
                                 .equ CLKCTRL_TUNE_gm = 0xFF              ; Tune group mask
                                 .equ CLKCTRL_TUNE_gp = 0                 ; Tune group position
                                 .equ CLKCTRL_TUNE0_bm = (1<<0)           ; Tune bit 0 mask
                                 .equ CLKCTRL_TUNE0_bp = 0                ; Tune bit 0 position
                                 .equ CLKCTRL_TUNE1_bm = (1<<1)           ; Tune bit 1 mask
                                 .equ CLKCTRL_TUNE1_bp = 1                ; Tune bit 1 position
                                 .equ CLKCTRL_TUNE2_bm = (1<<2)           ; Tune bit 2 mask
                                 .equ CLKCTRL_TUNE2_bp = 2                ; Tune bit 2 position
                                 .equ CLKCTRL_TUNE3_bm = (1<<3)           ; Tune bit 3 mask
                                 .equ CLKCTRL_TUNE3_bp = 3                ; Tune bit 3 position
                                 .equ CLKCTRL_TUNE4_bm = (1<<4)           ; Tune bit 4 mask
                                 .equ CLKCTRL_TUNE4_bp = 4                ; Tune bit 4 position
                                 .equ CLKCTRL_TUNE5_bm = (1<<5)           ; Tune bit 5 mask
                                 .equ CLKCTRL_TUNE5_bp = 5                ; Tune bit 5 position
                                 .equ CLKCTRL_TUNE6_bm = (1<<6)           ; Tune bit 6 mask
                                 .equ CLKCTRL_TUNE6_bp = 6                ; Tune bit 6 position
                                 .equ CLKCTRL_TUNE7_bm = (1<<7)           ; Tune bit 7 mask
                                 .equ CLKCTRL_TUNE7_bp = 7                ; Tune bit 7 position
                                 
                                 ; CLKCTRL_OSC32KCTRLA masks
                                 ; Masks for CLKCTRL_RUNSTDBY already defined
                                 
                                 ; CLKCTRL_PLLCTRLA masks
                                 .equ CLKCTRL_MULFAC_gm = 0x03            ; Multiplication factor group mask
                                 .equ CLKCTRL_MULFAC_gp = 0               ; Multiplication factor group position
                                 .equ CLKCTRL_MULFAC0_bm = (1<<0)         ; Multiplication factor bit 0 mask
                                 .equ CLKCTRL_MULFAC0_bp = 0              ; Multiplication factor bit 0 position
                                 .equ CLKCTRL_MULFAC1_bm = (1<<1)         ; Multiplication factor bit 1 mask
                                 .equ CLKCTRL_MULFAC1_bp = 1              ; Multiplication factor bit 1 position
                                 ; Masks for CLKCTRL_RUNSTDBY already defined
                                 .equ CLKCTRL_SOURCE_bm = 0x40            ; Source bit mask
                                 .equ CLKCTRL_SOURCE_bp = 6               ; Source bit position
                                 
                                 ; CLKCTRL_XOSCHFCTRLA masks
                                 .equ CLKCTRL_CSUTHF_gm = 0x30            ; Start-up Time Select group mask
                                 .equ CLKCTRL_CSUTHF_gp = 4               ; Start-up Time Select group position
                                 .equ CLKCTRL_CSUTHF0_bm = (1<<4)         ; Start-up Time Select bit 0 mask
                                 .equ CLKCTRL_CSUTHF0_bp = 4              ; Start-up Time Select bit 0 position
                                 .equ CLKCTRL_CSUTHF1_bm = (1<<5)         ; Start-up Time Select bit 1 mask
                                 .equ CLKCTRL_CSUTHF1_bp = 5              ; Start-up Time Select bit 1 position
                                 .equ CLKCTRL_ENABLE_bm = 0x01            ; Enable bit mask
                                 .equ CLKCTRL_ENABLE_bp = 0               ; Enable bit position
                                 .equ CLKCTRL_FRQRANGE_gm = 0x0C          ; Frequency Range group mask
                                 .equ CLKCTRL_FRQRANGE_gp = 2             ; Frequency Range group position
                                 .equ CLKCTRL_FRQRANGE0_bm = (1<<2)       ; Frequency Range bit 0 mask
                                 .equ CLKCTRL_FRQRANGE0_bp = 2            ; Frequency Range bit 0 position
                                 .equ CLKCTRL_FRQRANGE1_bm = (1<<3)       ; Frequency Range bit 1 mask
                                 .equ CLKCTRL_FRQRANGE1_bp = 3            ; Frequency Range bit 1 position
                                 .equ CLKCTRL_RUNSTBY_bm = 0x80           ; Run Standby bit mask
                                 .equ CLKCTRL_RUNSTBY_bp = 7              ; Run Standby bit position
                                 .equ CLKCTRL_SELHF_bm = 0x02             ; External Source Select bit mask
                                 .equ CLKCTRL_SELHF_bp = 1                ; External Source Select bit position
                                 
                                 ; CLKCTRL_XOSC32KCTRLA masks
                                 .equ CLKCTRL_CSUT_gm = 0x30              ; Crystal startup time group mask
                                 .equ CLKCTRL_CSUT_gp = 4                 ; Crystal startup time group position
                                 .equ CLKCTRL_CSUT0_bm = (1<<4)           ; Crystal startup time bit 0 mask
                                 .equ CLKCTRL_CSUT0_bp = 4                ; Crystal startup time bit 0 position
                                 .equ CLKCTRL_CSUT1_bm = (1<<5)           ; Crystal startup time bit 1 mask
                                 .equ CLKCTRL_CSUT1_bp = 5                ; Crystal startup time bit 1 position
                                 ; Masks for CLKCTRL_ENABLE already defined
                                 .equ CLKCTRL_LPMODE_bm = 0x02            ; Low power mode bit mask
                                 .equ CLKCTRL_LPMODE_bp = 1               ; Low power mode bit position
                                 ; Masks for CLKCTRL_RUNSTDBY already defined
                                 .equ CLKCTRL_SEL_bm = 0x04               ; Select bit mask
                                 .equ CLKCTRL_SEL_bp = 2                  ; Select bit position
                                 
                                 ; clock select select
                                 .equ CLKCTRL_CLKSEL_OSCHF_gc = (0x00<<0) ; Internal high-frequency oscillator
                                 .equ CLKCTRL_CLKSEL_OSC32K_gc = (0x01<<0) ; Internal 32.768 kHz oscillator
                                 .equ CLKCTRL_CLKSEL_XOSC32K_gc = (0x02<<0) ; 32.768 kHz crystal oscillator
                                 .equ CLKCTRL_CLKSEL_EXTCLK_gc = (0x03<<0) ; External clock
                                 
                                 ; Prescaler division select
                                 .equ CLKCTRL_PDIV_2X_gc = (0x00<<1)      ; 2X
                                 .equ CLKCTRL_PDIV_4X_gc = (0x01<<1)      ; 4X
                                 .equ CLKCTRL_PDIV_8X_gc = (0x02<<1)      ; 8X
                                 .equ CLKCTRL_PDIV_16X_gc = (0x03<<1)     ; 16X
                                 .equ CLKCTRL_PDIV_32X_gc = (0x04<<1)     ; 32X
                                 .equ CLKCTRL_PDIV_64X_gc = (0x05<<1)     ; 64X
                                 .equ CLKCTRL_PDIV_6X_gc = (0x08<<1)      ; 6X
                                 .equ CLKCTRL_PDIV_10X_gc = (0x09<<1)     ; 10X
                                 .equ CLKCTRL_PDIV_12X_gc = (0x0A<<1)     ; 12X
                                 .equ CLKCTRL_PDIV_24X_gc = (0x0B<<1)     ; 24X
                                 .equ CLKCTRL_PDIV_48X_gc = (0x0C<<1)     ; 48X
                                 
                                 ; Clock Failure Detect Source select
                                 .equ CLKCTRL_CFDSRC_CLKMAIN_gc = (0x00<<2) ; Main Clock
                                 .equ CLKCTRL_CFDSRC_XOSCHF_gc = (0x01<<2) ; XOSCHF
                                 .equ CLKCTRL_CFDSRC_XOSC32K_gc = (0x02<<2) ; XOSC32K
                                 
                                 ; Interrupt type select
                                 .equ CLKCTRL_INTTYPE_INT_gc = (0x00<<7)  ; Regular Interrupt
                                 .equ CLKCTRL_INTTYPE_NMI_gc = (0x01<<7)  ; NMI
                                 
                                 ; Frequency select select
                                 .equ CLKCTRL_FRQSEL_1M_gc = (0x00<<2)    ; 1 MHz system clock
                                 .equ CLKCTRL_FRQSEL_2M_gc = (0x01<<2)    ; 2 MHz system clock
                                 .equ CLKCTRL_FRQSEL_3M_gc = (0x02<<2)    ; 3 MHz system clock
                                 .equ CLKCTRL_FRQSEL_4M_gc = (0x03<<2)    ; 4 MHz system clock (default)
                                 .equ CLKCTRL_FRQSEL_8M_gc = (0x05<<2)    ; 8 MHz system clock
                                 .equ CLKCTRL_FRQSEL_12M_gc = (0x06<<2)   ; 12 MHz system clock
                                 .equ CLKCTRL_FRQSEL_16M_gc = (0x07<<2)   ; 16 MHz system clock
                                 .equ CLKCTRL_FRQSEL_20M_gc = (0x08<<2)   ; 20 MHz system clock
                                 .equ CLKCTRL_FRQSEL_24M_gc = (0x09<<2)   ; 24 MHz system clock
                                 
                                 ; Multiplication factor select
                                 .equ CLKCTRL_MULFAC_DISABLE_gc = (0x00<<0) ; PLL is disabled
                                 .equ CLKCTRL_MULFAC_2x_gc = (0x01<<0)    ; 2 x multiplication factor
                                 .equ CLKCTRL_MULFAC_3x_gc = (0x02<<0)    ; 3 x multiplication factor
                                 
                                 ; Source select
                                 .equ CLKCTRL_SOURCE_OSCHF_gc = (0x00<<6) ; High frequency internal oscillator as PLL source
                                 .equ CLKCTRL_SOURCE_XOSCHF_gc = (0x01<<6) ; High frequency external clock or external high frequency oscillator as PLL source
                                 
                                 ; Start-up Time Select select
                                 .equ CLKCTRL_CSUTHF_256_gc = (0x00<<4)   ; 256 XOSCHF cycles
                                 .equ CLKCTRL_CSUTHF_1K_gc = (0x01<<4)    ; 1K XOSCHF cycles
                                 .equ CLKCTRL_CSUTHF_4K_gc = (0x02<<4)    ; 4K XOSCHF cycles
                                 
                                 ; Frequency Range select
                                 .equ CLKCTRL_FRQRANGE_8M_gc = (0x00<<2)  ; Max 8 MHz XTAL Frequency
                                 .equ CLKCTRL_FRQRANGE_16M_gc = (0x01<<2) ; Max 16 MHz XTAL Frequency
                                 .equ CLKCTRL_FRQRANGE_24M_gc = (0x02<<2) ; Max 24 MHz XTAL Frequency
                                 .equ CLKCTRL_FRQRANGE_32M_gc = (0x03<<2) ; Max 32 MHz XTAL Frequency
                                 
                                 ; External Source Select select
                                 .equ CLKCTRL_SELHF_XTAL_gc = (0x00<<1)   ; External Crystal
                                 .equ CLKCTRL_SELHF_EXTCLOCK_gc = (0x01<<1) ; External clock on XTALHF1 pin
                                 
                                 ; Crystal startup time select
                                 .equ CLKCTRL_CSUT_1K_gc = (0x00<<4)      ; 1k cycles
                                 .equ CLKCTRL_CSUT_16K_gc = (0x01<<4)     ; 16k cycles
                                 .equ CLKCTRL_CSUT_32K_gc = (0x02<<4)     ; 32k cycles
                                 .equ CLKCTRL_CSUT_64K_gc = (0x03<<4)     ; 64k cycles
                                 
                                 
                                 ;*************************************************************************
                                 ;** CPU - CPU
                                 ;*************************************************************************
                                 
                                 ; CPU_CCP masks
                                 .equ CPU_CCP_gm = 0xFF                   ; CCP signature group mask
                                 .equ CPU_CCP_gp = 0                      ; CCP signature group position
                                 .equ CPU_CCP0_bm = (1<<0)                ; CCP signature bit 0 mask
                                 .equ CPU_CCP0_bp = 0                     ; CCP signature bit 0 position
                                 .equ CPU_CCP1_bm = (1<<1)                ; CCP signature bit 1 mask
                                 .equ CPU_CCP1_bp = 1                     ; CCP signature bit 1 position
                                 .equ CPU_CCP2_bm = (1<<2)                ; CCP signature bit 2 mask
                                 .equ CPU_CCP2_bp = 2                     ; CCP signature bit 2 position
                                 .equ CPU_CCP3_bm = (1<<3)                ; CCP signature bit 3 mask
                                 .equ CPU_CCP3_bp = 3                     ; CCP signature bit 3 position
                                 .equ CPU_CCP4_bm = (1<<4)                ; CCP signature bit 4 mask
                                 .equ CPU_CCP4_bp = 4                     ; CCP signature bit 4 position
                                 .equ CPU_CCP5_bm = (1<<5)                ; CCP signature bit 5 mask
                                 .equ CPU_CCP5_bp = 5                     ; CCP signature bit 5 position
                                 .equ CPU_CCP6_bm = (1<<6)                ; CCP signature bit 6 mask
                                 .equ CPU_CCP6_bp = 6                     ; CCP signature bit 6 position
                                 .equ CPU_CCP7_bm = (1<<7)                ; CCP signature bit 7 mask
                                 .equ CPU_CCP7_bp = 7                     ; CCP signature bit 7 position
                                 
                                 ; CPU_SREG masks
                                 .equ CPU_C_bm = 0x01                     ; Carry Flag bit mask
                                 .equ CPU_C_bp = 0                        ; Carry Flag bit position
                                 .equ CPU_H_bm = 0x20                     ; Half Carry Flag bit mask
                                 .equ CPU_H_bp = 5                        ; Half Carry Flag bit position
                                 .equ CPU_I_bm = 0x80                     ; Global Interrupt Enable Flag bit mask
                                 .equ CPU_I_bp = 7                        ; Global Interrupt Enable Flag bit position
                                 .equ CPU_N_bm = 0x04                     ; Negative Flag bit mask
                                 .equ CPU_N_bp = 2                        ; Negative Flag bit position
                                 .equ CPU_S_bm = 0x10                     ; N Exclusive Or V Flag bit mask
                                 .equ CPU_S_bp = 4                        ; N Exclusive Or V Flag bit position
                                 .equ CPU_T_bm = 0x40                     ; Transfer Bit bit mask
                                 .equ CPU_T_bp = 6                        ; Transfer Bit bit position
                                 .equ CPU_V_bm = 0x08                     ; Two's Complement Overflow Flag bit mask
                                 .equ CPU_V_bp = 3                        ; Two's Complement Overflow Flag bit position
                                 .equ CPU_Z_bm = 0x02                     ; Zero Flag bit mask
                                 .equ CPU_Z_bp = 1                        ; Zero Flag bit position
                                 
                                 ; CCP signature select
                                 .equ CPU_CCP_SPM_gc = (0x9D<<0)          ; SPM Instruction Protection
                                 .equ CPU_CCP_IOREG_gc = (0xD8<<0)        ; IO Register Protection
                                 
                                 
                                 ;*************************************************************************
                                 ;** CPUINT - Interrupt Controller
                                 ;*************************************************************************
                                 
                                 ; CPUINT_CTRLA masks
                                 .equ CPUINT_CVT_bm = 0x20                ; Compact Vector Table bit mask
                                 .equ CPUINT_CVT_bp = 5                   ; Compact Vector Table bit position
                                 .equ CPUINT_IVSEL_bm = 0x40              ; Interrupt Vector Select bit mask
                                 .equ CPUINT_IVSEL_bp = 6                 ; Interrupt Vector Select bit position
                                 .equ CPUINT_LVL0RR_bm = 0x01             ; Round-robin Scheduling Enable bit mask
                                 .equ CPUINT_LVL0RR_bp = 0                ; Round-robin Scheduling Enable bit position
                                 
                                 ; CPUINT_LVL0PRI masks
                                 .equ CPUINT_LVL0PRI_gm = 0xFF            ; Interrupt Level Priority group mask
                                 .equ CPUINT_LVL0PRI_gp = 0               ; Interrupt Level Priority group position
                                 .equ CPUINT_LVL0PRI0_bm = (1<<0)         ; Interrupt Level Priority bit 0 mask
                                 .equ CPUINT_LVL0PRI0_bp = 0              ; Interrupt Level Priority bit 0 position
                                 .equ CPUINT_LVL0PRI1_bm = (1<<1)         ; Interrupt Level Priority bit 1 mask
                                 .equ CPUINT_LVL0PRI1_bp = 1              ; Interrupt Level Priority bit 1 position
                                 .equ CPUINT_LVL0PRI2_bm = (1<<2)         ; Interrupt Level Priority bit 2 mask
                                 .equ CPUINT_LVL0PRI2_bp = 2              ; Interrupt Level Priority bit 2 position
                                 .equ CPUINT_LVL0PRI3_bm = (1<<3)         ; Interrupt Level Priority bit 3 mask
                                 .equ CPUINT_LVL0PRI3_bp = 3              ; Interrupt Level Priority bit 3 position
                                 .equ CPUINT_LVL0PRI4_bm = (1<<4)         ; Interrupt Level Priority bit 4 mask
                                 .equ CPUINT_LVL0PRI4_bp = 4              ; Interrupt Level Priority bit 4 position
                                 .equ CPUINT_LVL0PRI5_bm = (1<<5)         ; Interrupt Level Priority bit 5 mask
                                 .equ CPUINT_LVL0PRI5_bp = 5              ; Interrupt Level Priority bit 5 position
                                 .equ CPUINT_LVL0PRI6_bm = (1<<6)         ; Interrupt Level Priority bit 6 mask
                                 .equ CPUINT_LVL0PRI6_bp = 6              ; Interrupt Level Priority bit 6 position
                                 .equ CPUINT_LVL0PRI7_bm = (1<<7)         ; Interrupt Level Priority bit 7 mask
                                 .equ CPUINT_LVL0PRI7_bp = 7              ; Interrupt Level Priority bit 7 position
                                 
                                 ; CPUINT_LVL1VEC masks
                                 .equ CPUINT_LVL1VEC_gm = 0xFF            ; Interrupt Vector with High Priority group mask
                                 .equ CPUINT_LVL1VEC_gp = 0               ; Interrupt Vector with High Priority group position
                                 .equ CPUINT_LVL1VEC0_bm = (1<<0)         ; Interrupt Vector with High Priority bit 0 mask
                                 .equ CPUINT_LVL1VEC0_bp = 0              ; Interrupt Vector with High Priority bit 0 position
                                 .equ CPUINT_LVL1VEC1_bm = (1<<1)         ; Interrupt Vector with High Priority bit 1 mask
                                 .equ CPUINT_LVL1VEC1_bp = 1              ; Interrupt Vector with High Priority bit 1 position
                                 .equ CPUINT_LVL1VEC2_bm = (1<<2)         ; Interrupt Vector with High Priority bit 2 mask
                                 .equ CPUINT_LVL1VEC2_bp = 2              ; Interrupt Vector with High Priority bit 2 position
                                 .equ CPUINT_LVL1VEC3_bm = (1<<3)         ; Interrupt Vector with High Priority bit 3 mask
                                 .equ CPUINT_LVL1VEC3_bp = 3              ; Interrupt Vector with High Priority bit 3 position
                                 .equ CPUINT_LVL1VEC4_bm = (1<<4)         ; Interrupt Vector with High Priority bit 4 mask
                                 .equ CPUINT_LVL1VEC4_bp = 4              ; Interrupt Vector with High Priority bit 4 position
                                 .equ CPUINT_LVL1VEC5_bm = (1<<5)         ; Interrupt Vector with High Priority bit 5 mask
                                 .equ CPUINT_LVL1VEC5_bp = 5              ; Interrupt Vector with High Priority bit 5 position
                                 .equ CPUINT_LVL1VEC6_bm = (1<<6)         ; Interrupt Vector with High Priority bit 6 mask
                                 .equ CPUINT_LVL1VEC6_bp = 6              ; Interrupt Vector with High Priority bit 6 position
                                 .equ CPUINT_LVL1VEC7_bm = (1<<7)         ; Interrupt Vector with High Priority bit 7 mask
                                 .equ CPUINT_LVL1VEC7_bp = 7              ; Interrupt Vector with High Priority bit 7 position
                                 
                                 ; CPUINT_STATUS masks
                                 .equ CPUINT_LVL0EX_bm = 0x01             ; Level 0 Interrupt Executing bit mask
                                 .equ CPUINT_LVL0EX_bp = 0                ; Level 0 Interrupt Executing bit position
                                 .equ CPUINT_LVL1EX_bm = 0x02             ; Level 1 Interrupt Executing bit mask
                                 .equ CPUINT_LVL1EX_bp = 1                ; Level 1 Interrupt Executing bit position
                                 .equ CPUINT_NMIEX_bm = 0x80              ; Non-maskable Interrupt Executing bit mask
                                 .equ CPUINT_NMIEX_bp = 7                 ; Non-maskable Interrupt Executing bit position
                                 
                                 
                                 ;*************************************************************************
                                 ;** CRCSCAN - CRCSCAN
                                 ;*************************************************************************
                                 
                                 ; CRCSCAN_CTRLA masks
                                 .equ CRCSCAN_ENABLE_bm = 0x01            ; Enable CRC scan bit mask
                                 .equ CRCSCAN_ENABLE_bp = 0               ; Enable CRC scan bit position
                                 .equ CRCSCAN_NMIEN_bm = 0x02             ; Enable NMI Trigger bit mask
                                 .equ CRCSCAN_NMIEN_bp = 1                ; Enable NMI Trigger bit position
                                 .equ CRCSCAN_RESET_bm = 0x80             ; Reset CRC scan bit mask
                                 .equ CRCSCAN_RESET_bp = 7                ; Reset CRC scan bit position
                                 
                                 ; CRCSCAN_CTRLB masks
                                 .equ CRCSCAN_SRC_gm = 0x03               ; CRC Source group mask
                                 .equ CRCSCAN_SRC_gp = 0                  ; CRC Source group position
                                 .equ CRCSCAN_SRC0_bm = (1<<0)            ; CRC Source bit 0 mask
                                 .equ CRCSCAN_SRC0_bp = 0                 ; CRC Source bit 0 position
                                 .equ CRCSCAN_SRC1_bm = (1<<1)            ; CRC Source bit 1 mask
                                 .equ CRCSCAN_SRC1_bp = 1                 ; CRC Source bit 1 position
                                 
                                 ; CRCSCAN_STATUS masks
                                 .equ CRCSCAN_BUSY_bm = 0x01              ; CRC Busy bit mask
                                 .equ CRCSCAN_BUSY_bp = 0                 ; CRC Busy bit position
                                 .equ CRCSCAN_OK_bm = 0x02                ; CRC Ok bit mask
                                 .equ CRCSCAN_OK_bp = 1                   ; CRC Ok bit position
                                 
                                 ; CRC Source select
                                 .equ CRCSCAN_SRC_FLASH_gc = (0x00<<0)    ; CRC on entire flash
                                 .equ CRCSCAN_SRC_APPLICATION_gc = (0x01<<0) ; CRC on boot and appl section of flash
                                 .equ CRCSCAN_SRC_BOOT_gc = (0x02<<0)     ; CRC on boot section of flash
                                 
                                 
                                 ;*************************************************************************
                                 ;** DAC - Digital to Analog Converter
                                 ;*************************************************************************
                                 
                                 ; DAC_CTRLA masks
                                 .equ DAC_ENABLE_bm = 0x01                ; DAC Enable bit mask
                                 .equ DAC_ENABLE_bp = 0                   ; DAC Enable bit position
                                 .equ DAC_OUTEN_bm = 0x40                 ; Output Buffer Enable bit mask
                                 .equ DAC_OUTEN_bp = 6                    ; Output Buffer Enable bit position
                                 .equ DAC_RUNSTDBY_bm = 0x80              ; Run in Standby Mode bit mask
                                 .equ DAC_RUNSTDBY_bp = 7                 ; Run in Standby Mode bit position
                                 
                                 ; DAC_DATA masks
                                 .equ DAC_DATA_gm = 0xFFC0                ; Data group mask
                                 .equ DAC_DATA_gp = 6                     ; Data group position
                                 .equ DAC_DATA0_bm = (1<<6)               ; Data bit 0 mask
                                 .equ DAC_DATA0_bp = 6                    ; Data bit 0 position
                                 .equ DAC_DATA1_bm = (1<<7)               ; Data bit 1 mask
                                 .equ DAC_DATA1_bp = 7                    ; Data bit 1 position
                                 .equ DAC_DATA2_bm = (1<<8)               ; Data bit 2 mask
                                 .equ DAC_DATA2_bp = 8                    ; Data bit 2 position
                                 .equ DAC_DATA3_bm = (1<<9)               ; Data bit 3 mask
                                 .equ DAC_DATA3_bp = 9                    ; Data bit 3 position
                                 .equ DAC_DATA4_bm = (1<<10)              ; Data bit 4 mask
                                 .equ DAC_DATA4_bp = 10                   ; Data bit 4 position
                                 .equ DAC_DATA5_bm = (1<<11)              ; Data bit 5 mask
                                 .equ DAC_DATA5_bp = 11                   ; Data bit 5 position
                                 .equ DAC_DATA6_bm = (1<<12)              ; Data bit 6 mask
                                 .equ DAC_DATA6_bp = 12                   ; Data bit 6 position
                                 .equ DAC_DATA7_bm = (1<<13)              ; Data bit 7 mask
                                 .equ DAC_DATA7_bp = 13                   ; Data bit 7 position
                                 .equ DAC_DATA8_bm = (1<<14)              ; Data bit 8 mask
                                 .equ DAC_DATA8_bp = 14                   ; Data bit 8 position
                                 .equ DAC_DATA9_bm = (1<<15)              ; Data bit 9 mask
                                 .equ DAC_DATA9_bp = 15                   ; Data bit 9 position
                                 
                                 
                                 ;*************************************************************************
                                 ;** EVSYS - Event System
                                 ;*************************************************************************
                                 
                                 ; EVSYS_CHANNEL0 masks
                                 .equ EVSYS_CHANNEL0_gm = 0xFF            ; Channel 0 generator select group mask
                                 .equ EVSYS_CHANNEL0_gp = 0               ; Channel 0 generator select group position
                                 .equ EVSYS_CHANNEL00_bm = (1<<0)         ; Channel 0 generator select bit 0 mask
                                 .equ EVSYS_CHANNEL00_bp = 0              ; Channel 0 generator select bit 0 position
                                 .equ EVSYS_CHANNEL01_bm = (1<<1)         ; Channel 0 generator select bit 1 mask
                                 .equ EVSYS_CHANNEL01_bp = 1              ; Channel 0 generator select bit 1 position
                                 .equ EVSYS_CHANNEL02_bm = (1<<2)         ; Channel 0 generator select bit 2 mask
                                 .equ EVSYS_CHANNEL02_bp = 2              ; Channel 0 generator select bit 2 position
                                 .equ EVSYS_CHANNEL03_bm = (1<<3)         ; Channel 0 generator select bit 3 mask
                                 .equ EVSYS_CHANNEL03_bp = 3              ; Channel 0 generator select bit 3 position
                                 .equ EVSYS_CHANNEL04_bm = (1<<4)         ; Channel 0 generator select bit 4 mask
                                 .equ EVSYS_CHANNEL04_bp = 4              ; Channel 0 generator select bit 4 position
                                 .equ EVSYS_CHANNEL05_bm = (1<<5)         ; Channel 0 generator select bit 5 mask
                                 .equ EVSYS_CHANNEL05_bp = 5              ; Channel 0 generator select bit 5 position
                                 .equ EVSYS_CHANNEL06_bm = (1<<6)         ; Channel 0 generator select bit 6 mask
                                 .equ EVSYS_CHANNEL06_bp = 6              ; Channel 0 generator select bit 6 position
                                 .equ EVSYS_CHANNEL07_bm = (1<<7)         ; Channel 0 generator select bit 7 mask
                                 .equ EVSYS_CHANNEL07_bp = 7              ; Channel 0 generator select bit 7 position
                                 
                                 ; EVSYS_CHANNEL1 masks
                                 .equ EVSYS_CHANNEL1_gm = 0xFF            ; Channel 1 generator select group mask
                                 .equ EVSYS_CHANNEL1_gp = 0               ; Channel 1 generator select group position
                                 .equ EVSYS_CHANNEL10_bm = (1<<0)         ; Channel 1 generator select bit 0 mask
                                 .equ EVSYS_CHANNEL10_bp = 0              ; Channel 1 generator select bit 0 position
                                 .equ EVSYS_CHANNEL11_bm = (1<<1)         ; Channel 1 generator select bit 1 mask
                                 .equ EVSYS_CHANNEL11_bp = 1              ; Channel 1 generator select bit 1 position
                                 .equ EVSYS_CHANNEL12_bm = (1<<2)         ; Channel 1 generator select bit 2 mask
                                 .equ EVSYS_CHANNEL12_bp = 2              ; Channel 1 generator select bit 2 position
                                 .equ EVSYS_CHANNEL13_bm = (1<<3)         ; Channel 1 generator select bit 3 mask
                                 .equ EVSYS_CHANNEL13_bp = 3              ; Channel 1 generator select bit 3 position
                                 .equ EVSYS_CHANNEL14_bm = (1<<4)         ; Channel 1 generator select bit 4 mask
                                 .equ EVSYS_CHANNEL14_bp = 4              ; Channel 1 generator select bit 4 position
                                 .equ EVSYS_CHANNEL15_bm = (1<<5)         ; Channel 1 generator select bit 5 mask
                                 .equ EVSYS_CHANNEL15_bp = 5              ; Channel 1 generator select bit 5 position
                                 .equ EVSYS_CHANNEL16_bm = (1<<6)         ; Channel 1 generator select bit 6 mask
                                 .equ EVSYS_CHANNEL16_bp = 6              ; Channel 1 generator select bit 6 position
                                 .equ EVSYS_CHANNEL17_bm = (1<<7)         ; Channel 1 generator select bit 7 mask
                                 .equ EVSYS_CHANNEL17_bp = 7              ; Channel 1 generator select bit 7 position
                                 
                                 ; EVSYS_CHANNEL2 masks
                                 .equ EVSYS_CHANNEL2_gm = 0xFF            ; Channel 2 generator select group mask
                                 .equ EVSYS_CHANNEL2_gp = 0               ; Channel 2 generator select group position
                                 .equ EVSYS_CHANNEL20_bm = (1<<0)         ; Channel 2 generator select bit 0 mask
                                 .equ EVSYS_CHANNEL20_bp = 0              ; Channel 2 generator select bit 0 position
                                 .equ EVSYS_CHANNEL21_bm = (1<<1)         ; Channel 2 generator select bit 1 mask
                                 .equ EVSYS_CHANNEL21_bp = 1              ; Channel 2 generator select bit 1 position
                                 .equ EVSYS_CHANNEL22_bm = (1<<2)         ; Channel 2 generator select bit 2 mask
                                 .equ EVSYS_CHANNEL22_bp = 2              ; Channel 2 generator select bit 2 position
                                 .equ EVSYS_CHANNEL23_bm = (1<<3)         ; Channel 2 generator select bit 3 mask
                                 .equ EVSYS_CHANNEL23_bp = 3              ; Channel 2 generator select bit 3 position
                                 .equ EVSYS_CHANNEL24_bm = (1<<4)         ; Channel 2 generator select bit 4 mask
                                 .equ EVSYS_CHANNEL24_bp = 4              ; Channel 2 generator select bit 4 position
                                 .equ EVSYS_CHANNEL25_bm = (1<<5)         ; Channel 2 generator select bit 5 mask
                                 .equ EVSYS_CHANNEL25_bp = 5              ; Channel 2 generator select bit 5 position
                                 .equ EVSYS_CHANNEL26_bm = (1<<6)         ; Channel 2 generator select bit 6 mask
                                 .equ EVSYS_CHANNEL26_bp = 6              ; Channel 2 generator select bit 6 position
                                 .equ EVSYS_CHANNEL27_bm = (1<<7)         ; Channel 2 generator select bit 7 mask
                                 .equ EVSYS_CHANNEL27_bp = 7              ; Channel 2 generator select bit 7 position
                                 
                                 ; EVSYS_CHANNEL3 masks
                                 .equ EVSYS_CHANNEL3_gm = 0xFF            ; Channel 3 generator select group mask
                                 .equ EVSYS_CHANNEL3_gp = 0               ; Channel 3 generator select group position
                                 .equ EVSYS_CHANNEL30_bm = (1<<0)         ; Channel 3 generator select bit 0 mask
                                 .equ EVSYS_CHANNEL30_bp = 0              ; Channel 3 generator select bit 0 position
                                 .equ EVSYS_CHANNEL31_bm = (1<<1)         ; Channel 3 generator select bit 1 mask
                                 .equ EVSYS_CHANNEL31_bp = 1              ; Channel 3 generator select bit 1 position
                                 .equ EVSYS_CHANNEL32_bm = (1<<2)         ; Channel 3 generator select bit 2 mask
                                 .equ EVSYS_CHANNEL32_bp = 2              ; Channel 3 generator select bit 2 position
                                 .equ EVSYS_CHANNEL33_bm = (1<<3)         ; Channel 3 generator select bit 3 mask
                                 .equ EVSYS_CHANNEL33_bp = 3              ; Channel 3 generator select bit 3 position
                                 .equ EVSYS_CHANNEL34_bm = (1<<4)         ; Channel 3 generator select bit 4 mask
                                 .equ EVSYS_CHANNEL34_bp = 4              ; Channel 3 generator select bit 4 position
                                 .equ EVSYS_CHANNEL35_bm = (1<<5)         ; Channel 3 generator select bit 5 mask
                                 .equ EVSYS_CHANNEL35_bp = 5              ; Channel 3 generator select bit 5 position
                                 .equ EVSYS_CHANNEL36_bm = (1<<6)         ; Channel 3 generator select bit 6 mask
                                 .equ EVSYS_CHANNEL36_bp = 6              ; Channel 3 generator select bit 6 position
                                 .equ EVSYS_CHANNEL37_bm = (1<<7)         ; Channel 3 generator select bit 7 mask
                                 .equ EVSYS_CHANNEL37_bp = 7              ; Channel 3 generator select bit 7 position
                                 
                                 ; EVSYS_CHANNEL4 masks
                                 .equ EVSYS_CHANNEL4_gm = 0xFF            ; Channel 4 generator select group mask
                                 .equ EVSYS_CHANNEL4_gp = 0               ; Channel 4 generator select group position
                                 .equ EVSYS_CHANNEL40_bm = (1<<0)         ; Channel 4 generator select bit 0 mask
                                 .equ EVSYS_CHANNEL40_bp = 0              ; Channel 4 generator select bit 0 position
                                 .equ EVSYS_CHANNEL41_bm = (1<<1)         ; Channel 4 generator select bit 1 mask
                                 .equ EVSYS_CHANNEL41_bp = 1              ; Channel 4 generator select bit 1 position
                                 .equ EVSYS_CHANNEL42_bm = (1<<2)         ; Channel 4 generator select bit 2 mask
                                 .equ EVSYS_CHANNEL42_bp = 2              ; Channel 4 generator select bit 2 position
                                 .equ EVSYS_CHANNEL43_bm = (1<<3)         ; Channel 4 generator select bit 3 mask
                                 .equ EVSYS_CHANNEL43_bp = 3              ; Channel 4 generator select bit 3 position
                                 .equ EVSYS_CHANNEL44_bm = (1<<4)         ; Channel 4 generator select bit 4 mask
                                 .equ EVSYS_CHANNEL44_bp = 4              ; Channel 4 generator select bit 4 position
                                 .equ EVSYS_CHANNEL45_bm = (1<<5)         ; Channel 4 generator select bit 5 mask
                                 .equ EVSYS_CHANNEL45_bp = 5              ; Channel 4 generator select bit 5 position
                                 .equ EVSYS_CHANNEL46_bm = (1<<6)         ; Channel 4 generator select bit 6 mask
                                 .equ EVSYS_CHANNEL46_bp = 6              ; Channel 4 generator select bit 6 position
                                 .equ EVSYS_CHANNEL47_bm = (1<<7)         ; Channel 4 generator select bit 7 mask
                                 .equ EVSYS_CHANNEL47_bp = 7              ; Channel 4 generator select bit 7 position
                                 
                                 ; EVSYS_CHANNEL5 masks
                                 .equ EVSYS_CHANNEL5_gm = 0xFF            ; Channel 5 generator select group mask
                                 .equ EVSYS_CHANNEL5_gp = 0               ; Channel 5 generator select group position
                                 .equ EVSYS_CHANNEL50_bm = (1<<0)         ; Channel 5 generator select bit 0 mask
                                 .equ EVSYS_CHANNEL50_bp = 0              ; Channel 5 generator select bit 0 position
                                 .equ EVSYS_CHANNEL51_bm = (1<<1)         ; Channel 5 generator select bit 1 mask
                                 .equ EVSYS_CHANNEL51_bp = 1              ; Channel 5 generator select bit 1 position
                                 .equ EVSYS_CHANNEL52_bm = (1<<2)         ; Channel 5 generator select bit 2 mask
                                 .equ EVSYS_CHANNEL52_bp = 2              ; Channel 5 generator select bit 2 position
                                 .equ EVSYS_CHANNEL53_bm = (1<<3)         ; Channel 5 generator select bit 3 mask
                                 .equ EVSYS_CHANNEL53_bp = 3              ; Channel 5 generator select bit 3 position
                                 .equ EVSYS_CHANNEL54_bm = (1<<4)         ; Channel 5 generator select bit 4 mask
                                 .equ EVSYS_CHANNEL54_bp = 4              ; Channel 5 generator select bit 4 position
                                 .equ EVSYS_CHANNEL55_bm = (1<<5)         ; Channel 5 generator select bit 5 mask
                                 .equ EVSYS_CHANNEL55_bp = 5              ; Channel 5 generator select bit 5 position
                                 .equ EVSYS_CHANNEL56_bm = (1<<6)         ; Channel 5 generator select bit 6 mask
                                 .equ EVSYS_CHANNEL56_bp = 6              ; Channel 5 generator select bit 6 position
                                 .equ EVSYS_CHANNEL57_bm = (1<<7)         ; Channel 5 generator select bit 7 mask
                                 .equ EVSYS_CHANNEL57_bp = 7              ; Channel 5 generator select bit 7 position
                                 
                                 ; EVSYS_CHANNEL6 masks
                                 .equ EVSYS_CHANNEL6_gm = 0xFF            ; Channel 6 generator select group mask
                                 .equ EVSYS_CHANNEL6_gp = 0               ; Channel 6 generator select group position
                                 .equ EVSYS_CHANNEL60_bm = (1<<0)         ; Channel 6 generator select bit 0 mask
                                 .equ EVSYS_CHANNEL60_bp = 0              ; Channel 6 generator select bit 0 position
                                 .equ EVSYS_CHANNEL61_bm = (1<<1)         ; Channel 6 generator select bit 1 mask
                                 .equ EVSYS_CHANNEL61_bp = 1              ; Channel 6 generator select bit 1 position
                                 .equ EVSYS_CHANNEL62_bm = (1<<2)         ; Channel 6 generator select bit 2 mask
                                 .equ EVSYS_CHANNEL62_bp = 2              ; Channel 6 generator select bit 2 position
                                 .equ EVSYS_CHANNEL63_bm = (1<<3)         ; Channel 6 generator select bit 3 mask
                                 .equ EVSYS_CHANNEL63_bp = 3              ; Channel 6 generator select bit 3 position
                                 .equ EVSYS_CHANNEL64_bm = (1<<4)         ; Channel 6 generator select bit 4 mask
                                 .equ EVSYS_CHANNEL64_bp = 4              ; Channel 6 generator select bit 4 position
                                 .equ EVSYS_CHANNEL65_bm = (1<<5)         ; Channel 6 generator select bit 5 mask
                                 .equ EVSYS_CHANNEL65_bp = 5              ; Channel 6 generator select bit 5 position
                                 .equ EVSYS_CHANNEL66_bm = (1<<6)         ; Channel 6 generator select bit 6 mask
                                 .equ EVSYS_CHANNEL66_bp = 6              ; Channel 6 generator select bit 6 position
                                 .equ EVSYS_CHANNEL67_bm = (1<<7)         ; Channel 6 generator select bit 7 mask
                                 .equ EVSYS_CHANNEL67_bp = 7              ; Channel 6 generator select bit 7 position
                                 
                                 ; EVSYS_CHANNEL7 masks
                                 .equ EVSYS_CHANNEL7_gm = 0xFF            ; Channel 7 generator select group mask
                                 .equ EVSYS_CHANNEL7_gp = 0               ; Channel 7 generator select group position
                                 .equ EVSYS_CHANNEL70_bm = (1<<0)         ; Channel 7 generator select bit 0 mask
                                 .equ EVSYS_CHANNEL70_bp = 0              ; Channel 7 generator select bit 0 position
                                 .equ EVSYS_CHANNEL71_bm = (1<<1)         ; Channel 7 generator select bit 1 mask
                                 .equ EVSYS_CHANNEL71_bp = 1              ; Channel 7 generator select bit 1 position
                                 .equ EVSYS_CHANNEL72_bm = (1<<2)         ; Channel 7 generator select bit 2 mask
                                 .equ EVSYS_CHANNEL72_bp = 2              ; Channel 7 generator select bit 2 position
                                 .equ EVSYS_CHANNEL73_bm = (1<<3)         ; Channel 7 generator select bit 3 mask
                                 .equ EVSYS_CHANNEL73_bp = 3              ; Channel 7 generator select bit 3 position
                                 .equ EVSYS_CHANNEL74_bm = (1<<4)         ; Channel 7 generator select bit 4 mask
                                 .equ EVSYS_CHANNEL74_bp = 4              ; Channel 7 generator select bit 4 position
                                 .equ EVSYS_CHANNEL75_bm = (1<<5)         ; Channel 7 generator select bit 5 mask
                                 .equ EVSYS_CHANNEL75_bp = 5              ; Channel 7 generator select bit 5 position
                                 .equ EVSYS_CHANNEL76_bm = (1<<6)         ; Channel 7 generator select bit 6 mask
                                 .equ EVSYS_CHANNEL76_bp = 6              ; Channel 7 generator select bit 6 position
                                 .equ EVSYS_CHANNEL77_bm = (1<<7)         ; Channel 7 generator select bit 7 mask
                                 .equ EVSYS_CHANNEL77_bp = 7              ; Channel 7 generator select bit 7 position
                                 
                                 ; EVSYS_CHANNEL8 masks
                                 .equ EVSYS_CHANNEL8_gm = 0xFF            ; Channel 8 generator select group mask
                                 .equ EVSYS_CHANNEL8_gp = 0               ; Channel 8 generator select group position
                                 .equ EVSYS_CHANNEL80_bm = (1<<0)         ; Channel 8 generator select bit 0 mask
                                 .equ EVSYS_CHANNEL80_bp = 0              ; Channel 8 generator select bit 0 position
                                 .equ EVSYS_CHANNEL81_bm = (1<<1)         ; Channel 8 generator select bit 1 mask
                                 .equ EVSYS_CHANNEL81_bp = 1              ; Channel 8 generator select bit 1 position
                                 .equ EVSYS_CHANNEL82_bm = (1<<2)         ; Channel 8 generator select bit 2 mask
                                 .equ EVSYS_CHANNEL82_bp = 2              ; Channel 8 generator select bit 2 position
                                 .equ EVSYS_CHANNEL83_bm = (1<<3)         ; Channel 8 generator select bit 3 mask
                                 .equ EVSYS_CHANNEL83_bp = 3              ; Channel 8 generator select bit 3 position
                                 .equ EVSYS_CHANNEL84_bm = (1<<4)         ; Channel 8 generator select bit 4 mask
                                 .equ EVSYS_CHANNEL84_bp = 4              ; Channel 8 generator select bit 4 position
                                 .equ EVSYS_CHANNEL85_bm = (1<<5)         ; Channel 8 generator select bit 5 mask
                                 .equ EVSYS_CHANNEL85_bp = 5              ; Channel 8 generator select bit 5 position
                                 .equ EVSYS_CHANNEL86_bm = (1<<6)         ; Channel 8 generator select bit 6 mask
                                 .equ EVSYS_CHANNEL86_bp = 6              ; Channel 8 generator select bit 6 position
                                 .equ EVSYS_CHANNEL87_bm = (1<<7)         ; Channel 8 generator select bit 7 mask
                                 .equ EVSYS_CHANNEL87_bp = 7              ; Channel 8 generator select bit 7 position
                                 
                                 ; EVSYS_CHANNEL9 masks
                                 .equ EVSYS_CHANNEL9_gm = 0xFF            ; Channel 9 generator select group mask
                                 .equ EVSYS_CHANNEL9_gp = 0               ; Channel 9 generator select group position
                                 .equ EVSYS_CHANNEL90_bm = (1<<0)         ; Channel 9 generator select bit 0 mask
                                 .equ EVSYS_CHANNEL90_bp = 0              ; Channel 9 generator select bit 0 position
                                 .equ EVSYS_CHANNEL91_bm = (1<<1)         ; Channel 9 generator select bit 1 mask
                                 .equ EVSYS_CHANNEL91_bp = 1              ; Channel 9 generator select bit 1 position
                                 .equ EVSYS_CHANNEL92_bm = (1<<2)         ; Channel 9 generator select bit 2 mask
                                 .equ EVSYS_CHANNEL92_bp = 2              ; Channel 9 generator select bit 2 position
                                 .equ EVSYS_CHANNEL93_bm = (1<<3)         ; Channel 9 generator select bit 3 mask
                                 .equ EVSYS_CHANNEL93_bp = 3              ; Channel 9 generator select bit 3 position
                                 .equ EVSYS_CHANNEL94_bm = (1<<4)         ; Channel 9 generator select bit 4 mask
                                 .equ EVSYS_CHANNEL94_bp = 4              ; Channel 9 generator select bit 4 position
                                 .equ EVSYS_CHANNEL95_bm = (1<<5)         ; Channel 9 generator select bit 5 mask
                                 .equ EVSYS_CHANNEL95_bp = 5              ; Channel 9 generator select bit 5 position
                                 .equ EVSYS_CHANNEL96_bm = (1<<6)         ; Channel 9 generator select bit 6 mask
                                 .equ EVSYS_CHANNEL96_bp = 6              ; Channel 9 generator select bit 6 position
                                 .equ EVSYS_CHANNEL97_bm = (1<<7)         ; Channel 9 generator select bit 7 mask
                                 .equ EVSYS_CHANNEL97_bp = 7              ; Channel 9 generator select bit 7 position
                                 
                                 ; EVSYS_SWEVENTA masks
                                 .equ EVSYS_SWEVENTA_gm = 0xFF            ; Software event on channel select group mask
                                 .equ EVSYS_SWEVENTA_gp = 0               ; Software event on channel select group position
                                 .equ EVSYS_SWEVENTA0_bm = (1<<0)         ; Software event on channel select bit 0 mask
                                 .equ EVSYS_SWEVENTA0_bp = 0              ; Software event on channel select bit 0 position
                                 .equ EVSYS_SWEVENTA1_bm = (1<<1)         ; Software event on channel select bit 1 mask
                                 .equ EVSYS_SWEVENTA1_bp = 1              ; Software event on channel select bit 1 position
                                 .equ EVSYS_SWEVENTA2_bm = (1<<2)         ; Software event on channel select bit 2 mask
                                 .equ EVSYS_SWEVENTA2_bp = 2              ; Software event on channel select bit 2 position
                                 .equ EVSYS_SWEVENTA3_bm = (1<<3)         ; Software event on channel select bit 3 mask
                                 .equ EVSYS_SWEVENTA3_bp = 3              ; Software event on channel select bit 3 position
                                 .equ EVSYS_SWEVENTA4_bm = (1<<4)         ; Software event on channel select bit 4 mask
                                 .equ EVSYS_SWEVENTA4_bp = 4              ; Software event on channel select bit 4 position
                                 .equ EVSYS_SWEVENTA5_bm = (1<<5)         ; Software event on channel select bit 5 mask
                                 .equ EVSYS_SWEVENTA5_bp = 5              ; Software event on channel select bit 5 position
                                 .equ EVSYS_SWEVENTA6_bm = (1<<6)         ; Software event on channel select bit 6 mask
                                 .equ EVSYS_SWEVENTA6_bp = 6              ; Software event on channel select bit 6 position
                                 .equ EVSYS_SWEVENTA7_bm = (1<<7)         ; Software event on channel select bit 7 mask
                                 .equ EVSYS_SWEVENTA7_bp = 7              ; Software event on channel select bit 7 position
                                 
                                 ; EVSYS_SWEVENTB masks
                                 .equ EVSYS_SWEVENTB_gm = 0x03            ; Software event on channel select group mask
                                 .equ EVSYS_SWEVENTB_gp = 0               ; Software event on channel select group position
                                 .equ EVSYS_SWEVENTB0_bm = (1<<0)         ; Software event on channel select bit 0 mask
                                 .equ EVSYS_SWEVENTB0_bp = 0              ; Software event on channel select bit 0 position
                                 .equ EVSYS_SWEVENTB1_bm = (1<<1)         ; Software event on channel select bit 1 mask
                                 .equ EVSYS_SWEVENTB1_bp = 1              ; Software event on channel select bit 1 position
                                 
                                 ; EVSYS_USERADC0START masks
                                 .equ EVSYS_USER_gm = 0xFF                ; User channel select group mask
                                 .equ EVSYS_USER_gp = 0                   ; User channel select group position
                                 .equ EVSYS_USER0_bm = (1<<0)             ; User channel select bit 0 mask
                                 .equ EVSYS_USER0_bp = 0                  ; User channel select bit 0 position
                                 .equ EVSYS_USER1_bm = (1<<1)             ; User channel select bit 1 mask
                                 .equ EVSYS_USER1_bp = 1                  ; User channel select bit 1 position
                                 .equ EVSYS_USER2_bm = (1<<2)             ; User channel select bit 2 mask
                                 .equ EVSYS_USER2_bp = 2                  ; User channel select bit 2 position
                                 .equ EVSYS_USER3_bm = (1<<3)             ; User channel select bit 3 mask
                                 .equ EVSYS_USER3_bp = 3                  ; User channel select bit 3 position
                                 .equ EVSYS_USER4_bm = (1<<4)             ; User channel select bit 4 mask
                                 .equ EVSYS_USER4_bp = 4                  ; User channel select bit 4 position
                                 .equ EVSYS_USER5_bm = (1<<5)             ; User channel select bit 5 mask
                                 .equ EVSYS_USER5_bp = 5                  ; User channel select bit 5 position
                                 .equ EVSYS_USER6_bm = (1<<6)             ; User channel select bit 6 mask
                                 .equ EVSYS_USER6_bp = 6                  ; User channel select bit 6 position
                                 .equ EVSYS_USER7_bm = (1<<7)             ; User channel select bit 7 mask
                                 .equ EVSYS_USER7_bp = 7                  ; User channel select bit 7 position
                                 
                                 ; EVSYS_USERCCLLUT0A masks
                                 ; Masks for EVSYS_USER already defined
                                 
                                 ; EVSYS_USERCCLLUT0B masks
                                 ; Masks for EVSYS_USER already defined
                                 
                                 ; EVSYS_USERCCLLUT1A masks
                                 ; Masks for EVSYS_USER already defined
                                 
                                 ; EVSYS_USERCCLLUT1B masks
                                 ; Masks for EVSYS_USER already defined
                                 
                                 ; EVSYS_USERCCLLUT2A masks
                                 ; Masks for EVSYS_USER already defined
                                 
                                 ; EVSYS_USERCCLLUT2B masks
                                 ; Masks for EVSYS_USER already defined
                                 
                                 ; EVSYS_USERCCLLUT3A masks
                                 ; Masks for EVSYS_USER already defined
                                 
                                 ; EVSYS_USERCCLLUT3B masks
                                 ; Masks for EVSYS_USER already defined
                                 
                                 ; EVSYS_USERCCLLUT4A masks
                                 ; Masks for EVSYS_USER already defined
                                 
                                 ; EVSYS_USERCCLLUT4B masks
                                 ; Masks for EVSYS_USER already defined
                                 
                                 ; EVSYS_USERCCLLUT5A masks
                                 ; Masks for EVSYS_USER already defined
                                 
                                 ; EVSYS_USERCCLLUT5B masks
                                 ; Masks for EVSYS_USER already defined
                                 
                                 ; EVSYS_USEREVSYSEVOUTA masks
                                 ; Masks for EVSYS_USER already defined
                                 
                                 ; EVSYS_USEREVSYSEVOUTB masks
                                 ; Masks for EVSYS_USER already defined
                                 
                                 ; EVSYS_USEREVSYSEVOUTC masks
                                 ; Masks for EVSYS_USER already defined
                                 
                                 ; EVSYS_USEREVSYSEVOUTD masks
                                 ; Masks for EVSYS_USER already defined
                                 
                                 ; EVSYS_USEREVSYSEVOUTE masks
                                 ; Masks for EVSYS_USER already defined
                                 
                                 ; EVSYS_USEREVSYSEVOUTF masks
                                 ; Masks for EVSYS_USER already defined
                                 
                                 ; EVSYS_USEREVSYSEVOUTG masks
                                 ; Masks for EVSYS_USER already defined
                                 
                                 ; EVSYS_USEROPAMP0DISABLE masks
                                 ; Masks for EVSYS_USER already defined
                                 
                                 ; EVSYS_USEROPAMP0DRIVE masks
                                 ; Masks for EVSYS_USER already defined
                                 
                                 ; EVSYS_USEROPAMP0DUMP masks
                                 ; Masks for EVSYS_USER already defined
                                 
                                 ; EVSYS_USEROPAMP0ENABLE masks
                                 ; Masks for EVSYS_USER already defined
                                 
                                 ; EVSYS_USEROPAMP1DISABLE masks
                                 ; Masks for EVSYS_USER already defined
                                 
                                 ; EVSYS_USEROPAMP1DRIVE masks
                                 ; Masks for EVSYS_USER already defined
                                 
                                 ; EVSYS_USEROPAMP1DUMP masks
                                 ; Masks for EVSYS_USER already defined
                                 
                                 ; EVSYS_USEROPAMP1ENABLE masks
                                 ; Masks for EVSYS_USER already defined
                                 
                                 ; EVSYS_USEROPAMP2DISABLE masks
                                 ; Masks for EVSYS_USER already defined
                                 
                                 ; EVSYS_USEROPAMP2DRIVE masks
                                 ; Masks for EVSYS_USER already defined
                                 
                                 ; EVSYS_USEROPAMP2DUMP masks
                                 ; Masks for EVSYS_USER already defined
                                 
                                 ; EVSYS_USEROPAMP2ENABLE masks
                                 ; Masks for EVSYS_USER already defined
                                 
                                 ; EVSYS_USERTCA0CNTA masks
                                 ; Masks for EVSYS_USER already defined
                                 
                                 ; EVSYS_USERTCA0CNTB masks
                                 ; Masks for EVSYS_USER already defined
                                 
                                 ; EVSYS_USERTCA1CNTA masks
                                 ; Masks for EVSYS_USER already defined
                                 
                                 ; EVSYS_USERTCA1CNTB masks
                                 ; Masks for EVSYS_USER already defined
                                 
                                 ; EVSYS_USERTCB0CAPT masks
                                 ; Masks for EVSYS_USER already defined
                                 
                                 ; EVSYS_USERTCB0COUNT masks
                                 ; Masks for EVSYS_USER already defined
                                 
                                 ; EVSYS_USERTCB1CAPT masks
                                 ; Masks for EVSYS_USER already defined
                                 
                                 ; EVSYS_USERTCB1COUNT masks
                                 ; Masks for EVSYS_USER already defined
                                 
                                 ; EVSYS_USERTCB2CAPT masks
                                 ; Masks for EVSYS_USER already defined
                                 
                                 ; EVSYS_USERTCB2COUNT masks
                                 ; Masks for EVSYS_USER already defined
                                 
                                 ; EVSYS_USERTCB3CAPT masks
                                 ; Masks for EVSYS_USER already defined
                                 
                                 ; EVSYS_USERTCB3COUNT masks
                                 ; Masks for EVSYS_USER already defined
                                 
                                 ; EVSYS_USERTCB4CAPT masks
                                 ; Masks for EVSYS_USER already defined
                                 
                                 ; EVSYS_USERTCB4COUNT masks
                                 ; Masks for EVSYS_USER already defined
                                 
                                 ; EVSYS_USERTCD0INPUTA masks
                                 ; Masks for EVSYS_USER already defined
                                 
                                 ; EVSYS_USERTCD0INPUTB masks
                                 ; Masks for EVSYS_USER already defined
                                 
                                 ; EVSYS_USERUSART0IRDA masks
                                 ; Masks for EVSYS_USER already defined
                                 
                                 ; EVSYS_USERUSART1IRDA masks
                                 ; Masks for EVSYS_USER already defined
                                 
                                 ; EVSYS_USERUSART2IRDA masks
                                 ; Masks for EVSYS_USER already defined
                                 
                                 ; EVSYS_USERUSART3IRDA masks
                                 ; Masks for EVSYS_USER already defined
                                 
                                 ; EVSYS_USERUSART4IRDA masks
                                 ; Masks for EVSYS_USER already defined
                                 
                                 ; EVSYS_USERUSART5IRDA masks
                                 ; Masks for EVSYS_USER already defined
                                 
                                 ; Channel 0 generator select select
                                 .equ EVSYS_CHANNEL0_OFF_gc = (0x00<<0)   ; Off
                                 .equ EVSYS_CHANNEL0_UPDI_SYNCH_gc = (0x01<<0) ; UPDI SYNCH character
                                 .equ EVSYS_CHANNEL0_MVIO_gc = (0x05<<0)  ; MVIO VDDIO2 OK
                                 .equ EVSYS_CHANNEL0_RTC_OVF_gc = (0x06<<0) ; Real Time Counter overflow
                                 .equ EVSYS_CHANNEL0_RTC_CMP_gc = (0x07<<0) ; Real Time Counter compare
                                 .equ EVSYS_CHANNEL0_RTC_PIT_DIV8192_gc = (0x08<<0) ; Periodic Interrupt Timer output 0
                                 .equ EVSYS_CHANNEL0_RTC_PIT_DIV4096_gc = (0x09<<0) ; Periodic Interrupt Timer output 1
                                 .equ EVSYS_CHANNEL0_RTC_PIT_DIV2048_gc = (0x0A<<0) ; Periodic Interrupt Timer output 2
                                 .equ EVSYS_CHANNEL0_RTC_PIT_DIV1024_gc = (0x0B<<0) ; Periodic Interrupt Timer output 3
                                 .equ EVSYS_CHANNEL0_CCL_LUT0_gc = (0x10<<0) ; Configurable Custom Logic LUT0
                                 .equ EVSYS_CHANNEL0_CCL_LUT1_gc = (0x11<<0) ; Configurable Custom Logic LUT1
                                 .equ EVSYS_CHANNEL0_CCL_LUT2_gc = (0x12<<0) ; Configurable Custom Logic LUT2
                                 .equ EVSYS_CHANNEL0_CCL_LUT3_gc = (0x13<<0) ; Configurable Custom Logic LUT3
                                 .equ EVSYS_CHANNEL0_CCL_LUT4_gc = (0x14<<0) ; Configurable Custom Logic LUT4
                                 .equ EVSYS_CHANNEL0_CCL_LUT5_gc = (0x15<<0) ; Configurable Custom Logic LUT5
                                 .equ EVSYS_CHANNEL0_AC0_OUT_gc = (0x20<<0) ; Analog Comparator 0 out
                                 .equ EVSYS_CHANNEL0_AC1_OUT_gc = (0x21<<0) ; Analog Comparator 1 out
                                 .equ EVSYS_CHANNEL0_AC2_OUT_gc = (0x22<<0) ; Analog Comparator 2 out
                                 .equ EVSYS_CHANNEL0_ADC0_RESRDY_gc = (0x24<<0) ; ADC 0 Result Ready
                                 .equ EVSYS_CHANNEL0_ZCD0_gc = (0x30<<0)  ; Zero Cross Detect 0 out
                                 .equ EVSYS_CHANNEL0_ZCD1_gc = (0x31<<0)  ; Zero Cross Detect 1 out
                                 .equ EVSYS_CHANNEL0_ZCD2_gc = (0x32<<0)  ; Zero Cross Detect 2 out
                                 .equ EVSYS_CHANNEL0_OPAMP0_READY_gc = (0x34<<0) ; OPAMP0 Ready
                                 .equ EVSYS_CHANNEL0_OPAMP1_READY_gc = (0x35<<0) ; OPAMP1 Ready
                                 .equ EVSYS_CHANNEL0_OPAMP2_READY_gc = (0x36<<0) ; OPAMP2 Ready
                                 .equ EVSYS_CHANNEL0_PORTA_PIN0_gc = (0x40<<0) ; Port A Pin 0
                                 .equ EVSYS_CHANNEL0_PORTA_PIN1_gc = (0x41<<0) ; Port A Pin 1
                                 .equ EVSYS_CHANNEL0_PORTA_PIN2_gc = (0x42<<0) ; Port A Pin 2
                                 .equ EVSYS_CHANNEL0_PORTA_PIN3_gc = (0x43<<0) ; Port A Pin 3
                                 .equ EVSYS_CHANNEL0_PORTA_PIN4_gc = (0x44<<0) ; Port A Pin 4
                                 .equ EVSYS_CHANNEL0_PORTA_PIN5_gc = (0x45<<0) ; Port A Pin 5
                                 .equ EVSYS_CHANNEL0_PORTA_PIN6_gc = (0x46<<0) ; Port A Pin 6
                                 .equ EVSYS_CHANNEL0_PORTA_PIN7_gc = (0x47<<0) ; Port A Pin 7
                                 .equ EVSYS_CHANNEL0_PORTB_PIN0_gc = (0x48<<0) ; Port B Pin 0
                                 .equ EVSYS_CHANNEL0_PORTB_PIN1_gc = (0x49<<0) ; Port B Pin 1
                                 .equ EVSYS_CHANNEL0_PORTB_PIN2_gc = (0x4A<<0) ; Port B Pin 2
                                 .equ EVSYS_CHANNEL0_PORTB_PIN3_gc = (0x4B<<0) ; Port B Pin 3
                                 .equ EVSYS_CHANNEL0_PORTB_PIN4_gc = (0x4C<<0) ; Port B Pin 4
                                 .equ EVSYS_CHANNEL0_PORTB_PIN5_gc = (0x4D<<0) ; Port B Pin 5
                                 .equ EVSYS_CHANNEL0_PORTB_PIN6_gc = (0x4E<<0) ; Port B Pin 6
                                 .equ EVSYS_CHANNEL0_PORTB_PIN7_gc = (0x4F<<0) ; Port B Pin 7
                                 .equ EVSYS_CHANNEL0_USART0_XCK_gc = (0x60<<0) ; USART 0 XCK
                                 .equ EVSYS_CHANNEL0_USART1_XCK_gc = (0x61<<0) ; USART 1 XCK
                                 .equ EVSYS_CHANNEL0_USART2_XCK_gc = (0x62<<0) ; USART 2 XCK
                                 .equ EVSYS_CHANNEL0_USART3_XCK_gc = (0x63<<0) ; USART 3 XCK
                                 .equ EVSYS_CHANNEL0_USART4_XCK_gc = (0x64<<0) ; USART 4 XCK
                                 .equ EVSYS_CHANNEL0_USART5_XCK_gc = (0x65<<0) ; USART 5 XCK
                                 .equ EVSYS_CHANNEL0_SPI0_SCK_gc = (0x68<<0) ; SPI 0 SCK
                                 .equ EVSYS_CHANNEL0_SPI1_SCK_gc = (0x69<<0) ; SPI 1 SCK
                                 .equ EVSYS_CHANNEL0_TCA0_OVF_LUNF_gc = (0x80<<0) ; Timer/Counter A0 overflow / low byte timer underflow
                                 .equ EVSYS_CHANNEL0_TCA0_HUNF_gc = (0x81<<0) ; Timer/Counter A0 high byte timer underflow
                                 .equ EVSYS_CHANNEL0_TCA0_CMP0_LCMP0_gc = (0x84<<0) ; Timer/Counter A0 compare 0 / low byte timer compare 0
                                 .equ EVSYS_CHANNEL0_TCA0_CMP1_LCMP1_gc = (0x85<<0) ; Timer/Counter A0 compare 1 / low byte timer compare 1
                                 .equ EVSYS_CHANNEL0_TCA0_CMP2_LCMP2_gc = (0x86<<0) ; Timer/Counter A0 compare 2 / low byte timer compare 2
                                 .equ EVSYS_CHANNEL0_TCA1_OVF_LUNF_gc = (0x88<<0) ; Timer/Counter A1 overflow / low byte timer underflow
                                 .equ EVSYS_CHANNEL0_TCA1_HUNF_gc = (0x89<<0) ; Timer/Counter A1 high byte timer underflow
                                 .equ EVSYS_CHANNEL0_TCA1_CMP0_LCMP0_gc = (0x8C<<0) ; Timer/Counter A1 compare 0 / low byte timer compare 0
                                 .equ EVSYS_CHANNEL0_TCA1_CMP1_LCMP1_gc = (0x8D<<0) ; Timer/Counter A1 compare 1 / low byte timer compare 1
                                 .equ EVSYS_CHANNEL0_TCA1_CMP2_LCMP2_gc = (0x8E<<0) ; Timer/Counter A1 compare 2 / low byte timer compare 2
                                 .equ EVSYS_CHANNEL0_TCB0_CAPT_gc = (0xA0<<0) ; Timer/Counter B0 capture
                                 .equ EVSYS_CHANNEL0_TCB0_OVF_gc = (0xA1<<0) ; Timer/Counter B0 overflow
                                 .equ EVSYS_CHANNEL0_TCB1_CAPT_gc = (0xA2<<0) ; Timer/Counter B1 capture
                                 .equ EVSYS_CHANNEL0_TCB1_OVF_gc = (0xA3<<0) ; Timer/Counter B1 overflow
                                 .equ EVSYS_CHANNEL0_TCB2_CAPT_gc = (0xA4<<0) ; Timer/Counter B2 capture
                                 .equ EVSYS_CHANNEL0_TCB2_OVF_gc = (0xA5<<0) ; Timer/Counter B2 overflow
                                 .equ EVSYS_CHANNEL0_TCB3_CAPT_gc = (0xA6<<0) ; Timer/Counter B3 capture
                                 .equ EVSYS_CHANNEL0_TCB3_OVF_gc = (0xA7<<0) ; Timer/Counter B3 overflow
                                 .equ EVSYS_CHANNEL0_TCB4_CAPT_gc = (0xA8<<0) ; Timer/Counter B4 capture
                                 .equ EVSYS_CHANNEL0_TCB4_OVF_gc = (0xA9<<0) ; Timer/Counter B4 overflow
                                 .equ EVSYS_CHANNEL0_TCD0_CMPBCLR_gc = (0xB0<<0) ; Timer/Counter D0 event 0
                                 .equ EVSYS_CHANNEL0_TCD0_CMPASET_gc = (0xB1<<0) ; Timer/Counter D0 event 1
                                 .equ EVSYS_CHANNEL0_TCD0_CMPBSET_gc = (0xB2<<0) ; Timer/Counter D0 event 2
                                 .equ EVSYS_CHANNEL0_TCD0_PROGEV_gc = (0xB3<<0) ; Timer/Counter D0 event 3
                                 
                                 ; Channel 1 generator select select
                                 .equ EVSYS_CHANNEL1_OFF_gc = (0x00<<0)   ; Off
                                 .equ EVSYS_CHANNEL1_UPDI_SYNCH_gc = (0x01<<0) ; UPDI SYNCH character
                                 .equ EVSYS_CHANNEL1_MVIO_gc = (0x05<<0)  ; MVIO VDDIO2 OK
                                 .equ EVSYS_CHANNEL1_RTC_OVF_gc = (0x06<<0) ; Real Time Counter overflow
                                 .equ EVSYS_CHANNEL1_RTC_CMP_gc = (0x07<<0) ; Real Time Counter compare
                                 .equ EVSYS_CHANNEL1_RTC_PIT_DIV512_gc = (0x08<<0) ; Periodic Interrupt Timer output 0
                                 .equ EVSYS_CHANNEL1_RTC_PIT_DIV256_gc = (0x09<<0) ; Periodic Interrupt Timer output 1
                                 .equ EVSYS_CHANNEL1_RTC_PIT_DIV128_gc = (0x0A<<0) ; Periodic Interrupt Timer output 2
                                 .equ EVSYS_CHANNEL1_RTC_PIT_DIV64_gc = (0x0B<<0) ; Periodic Interrupt Timer output 3
                                 .equ EVSYS_CHANNEL1_CCL_LUT0_gc = (0x10<<0) ; Configurable Custom Logic LUT0
                                 .equ EVSYS_CHANNEL1_CCL_LUT1_gc = (0x11<<0) ; Configurable Custom Logic LUT1
                                 .equ EVSYS_CHANNEL1_CCL_LUT2_gc = (0x12<<0) ; Configurable Custom Logic LUT2
                                 .equ EVSYS_CHANNEL1_CCL_LUT3_gc = (0x13<<0) ; Configurable Custom Logic LUT3
                                 .equ EVSYS_CHANNEL1_CCL_LUT4_gc = (0x14<<0) ; Configurable Custom Logic LUT4
                                 .equ EVSYS_CHANNEL1_CCL_LUT5_gc = (0x15<<0) ; Configurable Custom Logic LUT5
                                 .equ EVSYS_CHANNEL1_AC0_OUT_gc = (0x20<<0) ; Analog Comparator 0 out
                                 .equ EVSYS_CHANNEL1_AC1_OUT_gc = (0x21<<0) ; Analog Comparator 1 out
                                 .equ EVSYS_CHANNEL1_AC2_OUT_gc = (0x22<<0) ; Analog Comparator 2 out
                                 .equ EVSYS_CHANNEL1_ADC0_RESRDY_gc = (0x24<<0) ; ADC 0 Result Ready
                                 .equ EVSYS_CHANNEL1_ZCD0_gc = (0x30<<0)  ; Zero Cross Detect 0 out
                                 .equ EVSYS_CHANNEL1_ZCD1_gc = (0x31<<0)  ; Zero Cross Detect 1 out
                                 .equ EVSYS_CHANNEL1_ZCD2_gc = (0x32<<0)  ; Zero Cross Detect 2 out
                                 .equ EVSYS_CHANNEL1_OPAMP0_READY_gc = (0x34<<0) ; OPAMP0 Ready
                                 .equ EVSYS_CHANNEL1_OPAMP1_READY_gc = (0x35<<0) ; OPAMP1 Ready
                                 .equ EVSYS_CHANNEL1_OPAMP2_READY_gc = (0x36<<0) ; OPAMP2 Ready
                                 .equ EVSYS_CHANNEL1_PORTA_PIN0_gc = (0x40<<0) ; Port A Pin 0
                                 .equ EVSYS_CHANNEL1_PORTA_PIN1_gc = (0x41<<0) ; Port A Pin 1
                                 .equ EVSYS_CHANNEL1_PORTA_PIN2_gc = (0x42<<0) ; Port A Pin 2
                                 .equ EVSYS_CHANNEL1_PORTA_PIN3_gc = (0x43<<0) ; Port A Pin 3
                                 .equ EVSYS_CHANNEL1_PORTA_PIN4_gc = (0x44<<0) ; Port A Pin 4
                                 .equ EVSYS_CHANNEL1_PORTA_PIN5_gc = (0x45<<0) ; Port A Pin 5
                                 .equ EVSYS_CHANNEL1_PORTA_PIN6_gc = (0x46<<0) ; Port A Pin 6
                                 .equ EVSYS_CHANNEL1_PORTA_PIN7_gc = (0x47<<0) ; Port A Pin 7
                                 .equ EVSYS_CHANNEL1_PORTB_PIN0_gc = (0x48<<0) ; Port B Pin 0
                                 .equ EVSYS_CHANNEL1_PORTB_PIN1_gc = (0x49<<0) ; Port B Pin 1
                                 .equ EVSYS_CHANNEL1_PORTB_PIN2_gc = (0x4A<<0) ; Port B Pin 2
                                 .equ EVSYS_CHANNEL1_PORTB_PIN3_gc = (0x4B<<0) ; Port B Pin 3
                                 .equ EVSYS_CHANNEL1_PORTB_PIN4_gc = (0x4C<<0) ; Port B Pin 4
                                 .equ EVSYS_CHANNEL1_PORTB_PIN5_gc = (0x4D<<0) ; Port B Pin 5
                                 .equ EVSYS_CHANNEL1_PORTB_PIN6_gc = (0x4E<<0) ; Port B Pin 6
                                 .equ EVSYS_CHANNEL1_PORTB_PIN7_gc = (0x4F<<0) ; Port B Pin 7
                                 .equ EVSYS_CHANNEL1_USART0_XCK_gc = (0x60<<0) ; USART 0 XCK
                                 .equ EVSYS_CHANNEL1_USART1_XCK_gc = (0x61<<0) ; USART 1 XCK
                                 .equ EVSYS_CHANNEL1_USART2_XCK_gc = (0x62<<0) ; USART 2 XCK
                                 .equ EVSYS_CHANNEL1_USART3_XCK_gc = (0x63<<0) ; USART 3 XCK
                                 .equ EVSYS_CHANNEL1_USART4_XCK_gc = (0x64<<0) ; USART 4 XCK
                                 .equ EVSYS_CHANNEL1_USART5_XCK_gc = (0x65<<0) ; USART 5 XCK
                                 .equ EVSYS_CHANNEL1_SPI0_SCK_gc = (0x68<<0) ; SPI 0 SCK
                                 .equ EVSYS_CHANNEL1_SPI1_SCK_gc = (0x69<<0) ; SPI 1 SCK
                                 .equ EVSYS_CHANNEL1_TCA0_OVF_LUNF_gc = (0x80<<0) ; Timer/Counter A0 overflow / low byte timer underflow
                                 .equ EVSYS_CHANNEL1_TCA0_HUNF_gc = (0x81<<0) ; Timer/Counter A0 high byte timer underflow
                                 .equ EVSYS_CHANNEL1_TCA0_CMP0_LCMP0_gc = (0x84<<0) ; Timer/Counter A0 compare 0 / low byte timer compare 0
                                 .equ EVSYS_CHANNEL1_TCA0_CMP1_LCMP1_gc = (0x85<<0) ; Timer/Counter A0 compare 1 / low byte timer compare 1
                                 .equ EVSYS_CHANNEL1_TCA0_CMP2_LCMP2_gc = (0x86<<0) ; Timer/Counter A0 compare 2 / low byte timer compare 2
                                 .equ EVSYS_CHANNEL1_TCA1_OVF_LUNF_gc = (0x88<<0) ; Timer/Counter A1 overflow / low byte timer underflow
                                 .equ EVSYS_CHANNEL1_TCA1_HUNF_gc = (0x89<<0) ; Timer/Counter A1 high byte timer underflow
                                 .equ EVSYS_CHANNEL1_TCA1_CMP0_LCMP0_gc = (0x8C<<0) ; Timer/Counter A1 compare 0 / low byte timer compare 0
                                 .equ EVSYS_CHANNEL1_TCA1_CMP1_LCMP1_gc = (0x8D<<0) ; Timer/Counter A1 compare 1 / low byte timer compare 1
                                 .equ EVSYS_CHANNEL1_TCA1_CMP2_LCMP2_gc = (0x8E<<0) ; Timer/Counter A1 compare 2 / low byte timer compare 2
                                 .equ EVSYS_CHANNEL1_TCB0_CAPT_gc = (0xA0<<0) ; Timer/Counter B0 capture
                                 .equ EVSYS_CHANNEL1_TCB0_OVF_gc = (0xA1<<0) ; Timer/Counter B0 overflow
                                 .equ EVSYS_CHANNEL1_TCB1_CAPT_gc = (0xA2<<0) ; Timer/Counter B1 capture
                                 .equ EVSYS_CHANNEL1_TCB1_OVF_gc = (0xA3<<0) ; Timer/Counter B1 overflow
                                 .equ EVSYS_CHANNEL1_TCB2_CAPT_gc = (0xA4<<0) ; Timer/Counter B2 capture
                                 .equ EVSYS_CHANNEL1_TCB2_OVF_gc = (0xA5<<0) ; Timer/Counter B2 overflow
                                 .equ EVSYS_CHANNEL1_TCB3_CAPT_gc = (0xA6<<0) ; Timer/Counter B3 capture
                                 .equ EVSYS_CHANNEL1_TCB3_OVF_gc = (0xA7<<0) ; Timer/Counter B3 overflow
                                 .equ EVSYS_CHANNEL1_TCB4_CAPT_gc = (0xA8<<0) ; Timer/Counter B4 capture
                                 .equ EVSYS_CHANNEL1_TCB4_OVF_gc = (0xA9<<0) ; Timer/Counter B4 overflow
                                 .equ EVSYS_CHANNEL1_TCD0_CMPBCLR_gc = (0xB0<<0) ; Timer/Counter D0 event 0
                                 .equ EVSYS_CHANNEL1_TCD0_CMPASET_gc = (0xB1<<0) ; Timer/Counter D0 event 1
                                 .equ EVSYS_CHANNEL1_TCD0_CMPBSET_gc = (0xB2<<0) ; Timer/Counter D0 event 2
                                 .equ EVSYS_CHANNEL1_TCD0_PROGEV_gc = (0xB3<<0) ; Timer/Counter D0 event 3
                                 
                                 ; Channel 2 generator select select
                                 .equ EVSYS_CHANNEL2_OFF_gc = (0x00<<0)   ; Off
                                 .equ EVSYS_CHANNEL2_UPDI_SYNCH_gc = (0x01<<0) ; UPDI SYNCH character
                                 .equ EVSYS_CHANNEL2_MVIO_gc = (0x05<<0)  ; MVIO VDDIO2 OK
                                 .equ EVSYS_CHANNEL2_RTC_OVF_gc = (0x06<<0) ; Real Time Counter overflow
                                 .equ EVSYS_CHANNEL2_RTC_CMP_gc = (0x07<<0) ; Real Time Counter compare
                                 .equ EVSYS_CHANNEL2_RTC_PIT_DIV8192_gc = (0x08<<0) ; Periodic Interrupt Timer output 0
                                 .equ EVSYS_CHANNEL2_RTC_PIT_DIV4096_gc = (0x09<<0) ; Periodic Interrupt Timer output 1
                                 .equ EVSYS_CHANNEL2_RTC_PIT_DIV2048_gc = (0x0A<<0) ; Periodic Interrupt Timer output 2
                                 .equ EVSYS_CHANNEL2_RTC_PIT_DIV1024_gc = (0x0B<<0) ; Periodic Interrupt Timer output 3
                                 .equ EVSYS_CHANNEL2_CCL_LUT0_gc = (0x10<<0) ; Configurable Custom Logic LUT0
                                 .equ EVSYS_CHANNEL2_CCL_LUT1_gc = (0x11<<0) ; Configurable Custom Logic LUT1
                                 .equ EVSYS_CHANNEL2_CCL_LUT2_gc = (0x12<<0) ; Configurable Custom Logic LUT2
                                 .equ EVSYS_CHANNEL2_CCL_LUT3_gc = (0x13<<0) ; Configurable Custom Logic LUT3
                                 .equ EVSYS_CHANNEL2_CCL_LUT4_gc = (0x14<<0) ; Configurable Custom Logic LUT4
                                 .equ EVSYS_CHANNEL2_CCL_LUT5_gc = (0x15<<0) ; Configurable Custom Logic LUT5
                                 .equ EVSYS_CHANNEL2_AC0_OUT_gc = (0x20<<0) ; Analog Comparator 0 out
                                 .equ EVSYS_CHANNEL2_AC1_OUT_gc = (0x21<<0) ; Analog Comparator 1 out
                                 .equ EVSYS_CHANNEL2_AC2_OUT_gc = (0x22<<0) ; Analog Comparator 2 out
                                 .equ EVSYS_CHANNEL2_ADC0_RESRDY_gc = (0x24<<0) ; ADC 0 Result Ready
                                 .equ EVSYS_CHANNEL2_ZCD0_gc = (0x30<<0)  ; Zero Cross Detect 0 out
                                 .equ EVSYS_CHANNEL2_ZCD1_gc = (0x31<<0)  ; Zero Cross Detect 1 out
                                 .equ EVSYS_CHANNEL2_ZCD2_gc = (0x32<<0)  ; Zero Cross Detect 2 out
                                 .equ EVSYS_CHANNEL2_OPAMP0_READY_gc = (0x34<<0) ; OPAMP0 Ready
                                 .equ EVSYS_CHANNEL2_OPAMP1_READY_gc = (0x35<<0) ; OPAMP1 Ready
                                 .equ EVSYS_CHANNEL2_OPAMP2_READY_gc = (0x36<<0) ; OPAMP2 Ready
                                 .equ EVSYS_CHANNEL2_PORTC_PIN0_gc = (0x40<<0) ; Port C Pin 0
                                 .equ EVSYS_CHANNEL2_PORTC_PIN1_gc = (0x41<<0) ; Port C Pin 1
                                 .equ EVSYS_CHANNEL2_PORTC_PIN2_gc = (0x42<<0) ; Port C Pin 2
                                 .equ EVSYS_CHANNEL2_PORTC_PIN3_gc = (0x43<<0) ; Port C Pin 3
                                 .equ EVSYS_CHANNEL2_PORTC_PIN4_gc = (0x44<<0) ; Port C Pin 4
                                 .equ EVSYS_CHANNEL2_PORTC_PIN5_gc = (0x45<<0) ; Port C Pin 5
                                 .equ EVSYS_CHANNEL2_PORTC_PIN6_gc = (0x46<<0) ; Port C Pin 6
                                 .equ EVSYS_CHANNEL2_PORTC_PIN7_gc = (0x47<<0) ; Port C Pin 7
                                 .equ EVSYS_CHANNEL2_PORTD_PIN0_gc = (0x48<<0) ; Port D Pin 0
                                 .equ EVSYS_CHANNEL2_PORTD_PIN1_gc = (0x49<<0) ; Port D Pin 1
                                 .equ EVSYS_CHANNEL2_PORTD_PIN2_gc = (0x4A<<0) ; Port D Pin 2
                                 .equ EVSYS_CHANNEL2_PORTD_PIN3_gc = (0x4B<<0) ; Port D Pin 3
                                 .equ EVSYS_CHANNEL2_PORTD_PIN4_gc = (0x4C<<0) ; Port D Pin 4
                                 .equ EVSYS_CHANNEL2_PORTD_PIN5_gc = (0x4D<<0) ; Port D Pin 5
                                 .equ EVSYS_CHANNEL2_PORTD_PIN6_gc = (0x4E<<0) ; Port D Pin 6
                                 .equ EVSYS_CHANNEL2_PORTD_PIN7_gc = (0x4F<<0) ; Port D Pin 7
                                 .equ EVSYS_CHANNEL2_USART0_XCK_gc = (0x60<<0) ; USART 0 XCK
                                 .equ EVSYS_CHANNEL2_USART1_XCK_gc = (0x61<<0) ; USART 1 XCK
                                 .equ EVSYS_CHANNEL2_USART2_XCK_gc = (0x62<<0) ; USART 2 XCK
                                 .equ EVSYS_CHANNEL2_USART3_XCK_gc = (0x63<<0) ; USART 3 XCK
                                 .equ EVSYS_CHANNEL2_USART4_XCK_gc = (0x64<<0) ; USART 4 XCK
                                 .equ EVSYS_CHANNEL2_USART5_XCK_gc = (0x65<<0) ; USART 5 XCK
                                 .equ EVSYS_CHANNEL2_SPI0_SCK_gc = (0x68<<0) ; SPI 0 SCK
                                 .equ EVSYS_CHANNEL2_SPI1_SCK_gc = (0x69<<0) ; SPI 1 SCK
                                 .equ EVSYS_CHANNEL2_TCA0_OVF_LUNF_gc = (0x80<<0) ; Timer/Counter A0 overflow / low byte timer underflow
                                 .equ EVSYS_CHANNEL2_TCA0_HUNF_gc = (0x81<<0) ; Timer/Counter A0 high byte timer underflow
                                 .equ EVSYS_CHANNEL2_TCA0_CMP0_LCMP0_gc = (0x84<<0) ; Timer/Counter A0 compare 0 / low byte timer compare 0
                                 .equ EVSYS_CHANNEL2_TCA0_CMP1_LCMP1_gc = (0x85<<0) ; Timer/Counter A0 compare 1 / low byte timer compare 1
                                 .equ EVSYS_CHANNEL2_TCA0_CMP2_LCMP2_gc = (0x86<<0) ; Timer/Counter A0 compare 2 / low byte timer compare 2
                                 .equ EVSYS_CHANNEL2_TCA1_OVF_LUNF_gc = (0x88<<0) ; Timer/Counter A1 overflow / low byte timer underflow
                                 .equ EVSYS_CHANNEL2_TCA1_HUNF_gc = (0x89<<0) ; Timer/Counter A1 high byte timer underflow
                                 .equ EVSYS_CHANNEL2_TCA1_CMP0_LCMP0_gc = (0x8C<<0) ; Timer/Counter A1 compare 0 / low byte timer compare 0
                                 .equ EVSYS_CHANNEL2_TCA1_CMP1_LCMP1_gc = (0x8D<<0) ; Timer/Counter A1 compare 1 / low byte timer compare 1
                                 .equ EVSYS_CHANNEL2_TCA1_CMP2_LCMP2_gc = (0x8E<<0) ; Timer/Counter A1 compare 2 / low byte timer compare 2
                                 .equ EVSYS_CHANNEL2_TCB0_CAPT_gc = (0xA0<<0) ; Timer/Counter B0 capture
                                 .equ EVSYS_CHANNEL2_TCB0_OVF_gc = (0xA1<<0) ; Timer/Counter B0 overflow
                                 .equ EVSYS_CHANNEL2_TCB1_CAPT_gc = (0xA2<<0) ; Timer/Counter B1 capture
                                 .equ EVSYS_CHANNEL2_TCB1_OVF_gc = (0xA3<<0) ; Timer/Counter B1 overflow
                                 .equ EVSYS_CHANNEL2_TCB2_CAPT_gc = (0xA4<<0) ; Timer/Counter B2 capture
                                 .equ EVSYS_CHANNEL2_TCB2_OVF_gc = (0xA5<<0) ; Timer/Counter B2 overflow
                                 .equ EVSYS_CHANNEL2_TCB3_CAPT_gc = (0xA6<<0) ; Timer/Counter B3 capture
                                 .equ EVSYS_CHANNEL2_TCB3_OVF_gc = (0xA7<<0) ; Timer/Counter B3 overflow
                                 .equ EVSYS_CHANNEL2_TCB4_CAPT_gc = (0xA8<<0) ; Timer/Counter B4 capture
                                 .equ EVSYS_CHANNEL2_TCB4_OVF_gc = (0xA9<<0) ; Timer/Counter B4 overflow
                                 .equ EVSYS_CHANNEL2_TCD0_CMPBCLR_gc = (0xB0<<0) ; Timer/Counter D0 event 0
                                 .equ EVSYS_CHANNEL2_TCD0_CMPASET_gc = (0xB1<<0) ; Timer/Counter D0 event 1
                                 .equ EVSYS_CHANNEL2_TCD0_CMPBSET_gc = (0xB2<<0) ; Timer/Counter D0 event 2
                                 .equ EVSYS_CHANNEL2_TCD0_PROGEV_gc = (0xB3<<0) ; Timer/Counter D0 event 3
                                 
                                 ; Channel 3 generator select select
                                 .equ EVSYS_CHANNEL3_OFF_gc = (0x00<<0)   ; Off
                                 .equ EVSYS_CHANNEL3_UPDI_SYNCH_gc = (0x01<<0) ; UPDI SYNCH character
                                 .equ EVSYS_CHANNEL3_MVIO_gc = (0x05<<0)  ; MVIO VDDIO2 OK
                                 .equ EVSYS_CHANNEL3_RTC_OVF_gc = (0x06<<0) ; Real Time Counter overflow
                                 .equ EVSYS_CHANNEL3_RTC_CMP_gc = (0x07<<0) ; Real Time Counter compare
                                 .equ EVSYS_CHANNEL3_RTC_PIT_DIV512_gc = (0x08<<0) ; Periodic Interrupt Timer output 0
                                 .equ EVSYS_CHANNEL3_RTC_PIT_DIV256_gc = (0x09<<0) ; Periodic Interrupt Timer output 1
                                 .equ EVSYS_CHANNEL3_RTC_PIT_DIV128_gc = (0x0A<<0) ; Periodic Interrupt Timer output 2
                                 .equ EVSYS_CHANNEL3_RTC_PIT_DIV64_gc = (0x0B<<0) ; Periodic Interrupt Timer output 3
                                 .equ EVSYS_CHANNEL3_CCL_LUT0_gc = (0x10<<0) ; Configurable Custom Logic LUT0
                                 .equ EVSYS_CHANNEL3_CCL_LUT1_gc = (0x11<<0) ; Configurable Custom Logic LUT1
                                 .equ EVSYS_CHANNEL3_CCL_LUT2_gc = (0x12<<0) ; Configurable Custom Logic LUT2
                                 .equ EVSYS_CHANNEL3_CCL_LUT3_gc = (0x13<<0) ; Configurable Custom Logic LUT3
                                 .equ EVSYS_CHANNEL3_CCL_LUT4_gc = (0x14<<0) ; Configurable Custom Logic LUT4
                                 .equ EVSYS_CHANNEL3_CCL_LUT5_gc = (0x15<<0) ; Configurable Custom Logic LUT5
                                 .equ EVSYS_CHANNEL3_AC0_OUT_gc = (0x20<<0) ; Analog Comparator 0 out
                                 .equ EVSYS_CHANNEL3_AC1_OUT_gc = (0x21<<0) ; Analog Comparator 1 out
                                 .equ EVSYS_CHANNEL3_AC2_OUT_gc = (0x22<<0) ; Analog Comparator 2 out
                                 .equ EVSYS_CHANNEL3_ADC0_RESRDY_gc = (0x24<<0) ; ADC 0 Result Ready
                                 .equ EVSYS_CHANNEL3_ZCD0_gc = (0x30<<0)  ; Zero Cross Detect 0 out
                                 .equ EVSYS_CHANNEL3_ZCD1_gc = (0x31<<0)  ; Zero Cross Detect 1 out
                                 .equ EVSYS_CHANNEL3_ZCD2_gc = (0x32<<0)  ; Zero Cross Detect 2 out
                                 .equ EVSYS_CHANNEL3_OPAMP0_READY_gc = (0x34<<0) ; OPAMP0 Ready
                                 .equ EVSYS_CHANNEL3_OPAMP1_READY_gc = (0x35<<0) ; OPAMP1 Ready
                                 .equ EVSYS_CHANNEL3_OPAMP2_READY_gc = (0x36<<0) ; OPAMP2 Ready
                                 .equ EVSYS_CHANNEL3_PORTC_PIN0_gc = (0x40<<0) ; Port C Pin 0
                                 .equ EVSYS_CHANNEL3_PORTC_PIN1_gc = (0x41<<0) ; Port C Pin 1
                                 .equ EVSYS_CHANNEL3_PORTC_PIN2_gc = (0x42<<0) ; Port C Pin 2
                                 .equ EVSYS_CHANNEL3_PORTC_PIN3_gc = (0x43<<0) ; Port C Pin 3
                                 .equ EVSYS_CHANNEL3_PORTC_PIN4_gc = (0x44<<0) ; Port C Pin 4
                                 .equ EVSYS_CHANNEL3_PORTC_PIN5_gc = (0x45<<0) ; Port C Pin 5
                                 .equ EVSYS_CHANNEL3_PORTC_PIN6_gc = (0x46<<0) ; Port C Pin 6
                                 .equ EVSYS_CHANNEL3_PORTC_PIN7_gc = (0x47<<0) ; Port C Pin 7
                                 .equ EVSYS_CHANNEL3_PORTD_PIN0_gc = (0x48<<0) ; Port D Pin 0
                                 .equ EVSYS_CHANNEL3_PORTD_PIN1_gc = (0x49<<0) ; Port D Pin 1
                                 .equ EVSYS_CHANNEL3_PORTD_PIN2_gc = (0x4A<<0) ; Port D Pin 2
                                 .equ EVSYS_CHANNEL3_PORTD_PIN3_gc = (0x4B<<0) ; Port D Pin 3
                                 .equ EVSYS_CHANNEL3_PORTD_PIN4_gc = (0x4C<<0) ; Port D Pin 4
                                 .equ EVSYS_CHANNEL3_PORTD_PIN5_gc = (0x4D<<0) ; Port D Pin 5
                                 .equ EVSYS_CHANNEL3_PORTD_PIN6_gc = (0x4E<<0) ; Port D Pin 6
                                 .equ EVSYS_CHANNEL3_PORTD_PIN7_gc = (0x4F<<0) ; Port D Pin 7
                                 .equ EVSYS_CHANNEL3_USART0_XCK_gc = (0x60<<0) ; USART 0 XCK
                                 .equ EVSYS_CHANNEL3_USART1_XCK_gc = (0x61<<0) ; USART 1 XCK
                                 .equ EVSYS_CHANNEL3_USART2_XCK_gc = (0x62<<0) ; USART 2 XCK
                                 .equ EVSYS_CHANNEL3_USART3_XCK_gc = (0x63<<0) ; USART 3 XCK
                                 .equ EVSYS_CHANNEL3_USART4_XCK_gc = (0x64<<0) ; USART 4 XCK
                                 .equ EVSYS_CHANNEL3_USART5_XCK_gc = (0x65<<0) ; USART 5 XCK
                                 .equ EVSYS_CHANNEL3_SPI0_SCK_gc = (0x68<<0) ; SPI 0 SCK
                                 .equ EVSYS_CHANNEL3_SPI1_SCK_gc = (0x69<<0) ; SPI 1 SCK
                                 .equ EVSYS_CHANNEL3_TCA0_OVF_LUNF_gc = (0x80<<0) ; Timer/Counter A0 overflow / low byte timer underflow
                                 .equ EVSYS_CHANNEL3_TCA0_HUNF_gc = (0x81<<0) ; Timer/Counter A0 high byte timer underflow
                                 .equ EVSYS_CHANNEL3_TCA0_CMP0_LCMP0_gc = (0x84<<0) ; Timer/Counter A0 compare 0 / low byte timer compare 0
                                 .equ EVSYS_CHANNEL3_TCA0_CMP1_LCMP1_gc = (0x85<<0) ; Timer/Counter A0 compare 1 / low byte timer compare 1
                                 .equ EVSYS_CHANNEL3_TCA0_CMP2_LCMP2_gc = (0x86<<0) ; Timer/Counter A0 compare 2 / low byte timer compare 2
                                 .equ EVSYS_CHANNEL3_TCA1_OVF_LUNF_gc = (0x88<<0) ; Timer/Counter A1 overflow / low byte timer underflow
                                 .equ EVSYS_CHANNEL3_TCA1_HUNF_gc = (0x89<<0) ; Timer/Counter A1 high byte timer underflow
                                 .equ EVSYS_CHANNEL3_TCA1_CMP0_LCMP0_gc = (0x8C<<0) ; Timer/Counter A1 compare 0 / low byte timer compare 0
                                 .equ EVSYS_CHANNEL3_TCA1_CMP1_LCMP1_gc = (0x8D<<0) ; Timer/Counter A1 compare 1 / low byte timer compare 1
                                 .equ EVSYS_CHANNEL3_TCA1_CMP2_LCMP2_gc = (0x8E<<0) ; Timer/Counter A1 compare 2 / low byte timer compare 2
                                 .equ EVSYS_CHANNEL3_TCB0_CAPT_gc = (0xA0<<0) ; Timer/Counter B0 capture
                                 .equ EVSYS_CHANNEL3_TCB0_OVF_gc = (0xA1<<0) ; Timer/Counter B0 overflow
                                 .equ EVSYS_CHANNEL3_TCB1_CAPT_gc = (0xA2<<0) ; Timer/Counter B1 capture
                                 .equ EVSYS_CHANNEL3_TCB1_OVF_gc = (0xA3<<0) ; Timer/Counter B1 overflow
                                 .equ EVSYS_CHANNEL3_TCB2_CAPT_gc = (0xA4<<0) ; Timer/Counter B2 capture
                                 .equ EVSYS_CHANNEL3_TCB2_OVF_gc = (0xA5<<0) ; Timer/Counter B2 overflow
                                 .equ EVSYS_CHANNEL3_TCB3_CAPT_gc = (0xA6<<0) ; Timer/Counter B3 capture
                                 .equ EVSYS_CHANNEL3_TCB3_OVF_gc = (0xA7<<0) ; Timer/Counter B3 overflow
                                 .equ EVSYS_CHANNEL3_TCB4_CAPT_gc = (0xA8<<0) ; Timer/Counter B4 capture
                                 .equ EVSYS_CHANNEL3_TCB4_OVF_gc = (0xA9<<0) ; Timer/Counter B4 overflow
                                 .equ EVSYS_CHANNEL3_TCD0_CMPBCLR_gc = (0xB0<<0) ; Timer/Counter D0 event 0
                                 .equ EVSYS_CHANNEL3_TCD0_CMPASET_gc = (0xB1<<0) ; Timer/Counter D0 event 1
                                 .equ EVSYS_CHANNEL3_TCD0_CMPBSET_gc = (0xB2<<0) ; Timer/Counter D0 event 2
                                 .equ EVSYS_CHANNEL3_TCD0_PROGEV_gc = (0xB3<<0) ; Timer/Counter D0 event 3
                                 
                                 ; Channel 4 generator select select
                                 .equ EVSYS_CHANNEL4_OFF_gc = (0x00<<0)   ; Off
                                 .equ EVSYS_CHANNEL4_UPDI_SYNCH_gc = (0x01<<0) ; UPDI SYNCH character
                                 .equ EVSYS_CHANNEL4_MVIO_gc = (0x05<<0)  ; MVIO VDDIO2 OK
                                 .equ EVSYS_CHANNEL4_RTC_OVF_gc = (0x06<<0) ; Real Time Counter overflow
                                 .equ EVSYS_CHANNEL4_RTC_CMP_gc = (0x07<<0) ; Real Time Counter compare
                                 .equ EVSYS_CHANNEL4_RTC_PIT_DIV8192_gc = (0x08<<0) ; Periodic Interrupt Timer output 0
                                 .equ EVSYS_CHANNEL4_RTC_PIT_DIV4096_gc = (0x09<<0) ; Periodic Interrupt Timer output 1
                                 .equ EVSYS_CHANNEL4_RTC_PIT_DIV2048_gc = (0x0A<<0) ; Periodic Interrupt Timer output 2
                                 .equ EVSYS_CHANNEL4_RTC_PIT_DIV1024_gc = (0x0B<<0) ; Periodic Interrupt Timer output 3
                                 .equ EVSYS_CHANNEL4_CCL_LUT0_gc = (0x10<<0) ; Configurable Custom Logic LUT0
                                 .equ EVSYS_CHANNEL4_CCL_LUT1_gc = (0x11<<0) ; Configurable Custom Logic LUT1
                                 .equ EVSYS_CHANNEL4_CCL_LUT2_gc = (0x12<<0) ; Configurable Custom Logic LUT2
                                 .equ EVSYS_CHANNEL4_CCL_LUT3_gc = (0x13<<0) ; Configurable Custom Logic LUT3
                                 .equ EVSYS_CHANNEL4_CCL_LUT4_gc = (0x14<<0) ; Configurable Custom Logic LUT4
                                 .equ EVSYS_CHANNEL4_CCL_LUT5_gc = (0x15<<0) ; Configurable Custom Logic LUT5
                                 .equ EVSYS_CHANNEL4_AC0_OUT_gc = (0x20<<0) ; Analog Comparator 0 out
                                 .equ EVSYS_CHANNEL4_AC1_OUT_gc = (0x21<<0) ; Analog Comparator 1 out
                                 .equ EVSYS_CHANNEL4_AC2_OUT_gc = (0x22<<0) ; Analog Comparator 2 out
                                 .equ EVSYS_CHANNEL4_ADC0_RESRDY_gc = (0x24<<0) ; ADC 0 Result Ready
                                 .equ EVSYS_CHANNEL4_ZCD0_gc = (0x30<<0)  ; Zero Cross Detect 0 out
                                 .equ EVSYS_CHANNEL4_ZCD1_gc = (0x31<<0)  ; Zero Cross Detect 1 out
                                 .equ EVSYS_CHANNEL4_ZCD2_gc = (0x32<<0)  ; Zero Cross Detect 2 out
                                 .equ EVSYS_CHANNEL4_OPAMP0_READY_gc = (0x34<<0) ; OPAMP0 Ready
                                 .equ EVSYS_CHANNEL4_OPAMP1_READY_gc = (0x35<<0) ; OPAMP1 Ready
                                 .equ EVSYS_CHANNEL4_OPAMP2_READY_gc = (0x36<<0) ; OPAMP2 Ready
                                 .equ EVSYS_CHANNEL4_PORTE_PIN0_gc = (0x40<<0) ; Port E Pin 0
                                 .equ EVSYS_CHANNEL4_PORTE_PIN1_gc = (0x41<<0) ; Port E Pin 1
                                 .equ EVSYS_CHANNEL4_PORTE_PIN2_gc = (0x42<<0) ; Port E Pin 2
                                 .equ EVSYS_CHANNEL4_PORTE_PIN3_gc = (0x43<<0) ; Port E Pin 3
                                 .equ EVSYS_CHANNEL4_PORTE_PIN4_gc = (0x44<<0) ; Port E Pin 4
                                 .equ EVSYS_CHANNEL4_PORTE_PIN5_gc = (0x45<<0) ; Port E Pin 5
                                 .equ EVSYS_CHANNEL4_PORTE_PIN6_gc = (0x46<<0) ; Port E Pin 6
                                 .equ EVSYS_CHANNEL4_PORTE_PIN7_gc = (0x47<<0) ; Port E Pin 7
                                 .equ EVSYS_CHANNEL4_PORTF_PIN0_gc = (0x48<<0) ; Port F Pin 0
                                 .equ EVSYS_CHANNEL4_PORTF_PIN1_gc = (0x49<<0) ; Port F Pin 1
                                 .equ EVSYS_CHANNEL4_PORTF_PIN2_gc = (0x4A<<0) ; Port F Pin 2
                                 .equ EVSYS_CHANNEL4_PORTF_PIN3_gc = (0x4B<<0) ; Port F Pin 3
                                 .equ EVSYS_CHANNEL4_PORTF_PIN4_gc = (0x4C<<0) ; Port F Pin 4
                                 .equ EVSYS_CHANNEL4_PORTF_PIN5_gc = (0x4D<<0) ; Port F Pin 5
                                 .equ EVSYS_CHANNEL4_PORTF_PIN6_gc = (0x4E<<0) ; Port F Pin 6
                                 .equ EVSYS_CHANNEL4_USART0_XCK_gc = (0x60<<0) ; USART 0 XCK
                                 .equ EVSYS_CHANNEL4_USART1_XCK_gc = (0x61<<0) ; USART 1 XCK
                                 .equ EVSYS_CHANNEL4_USART2_XCK_gc = (0x62<<0) ; USART 2 XCK
                                 .equ EVSYS_CHANNEL4_USART3_XCK_gc = (0x63<<0) ; USART 3 XCK
                                 .equ EVSYS_CHANNEL4_USART4_XCK_gc = (0x64<<0) ; USART 4 XCK
                                 .equ EVSYS_CHANNEL4_USART5_XCK_gc = (0x65<<0) ; USART 5 XCK
                                 .equ EVSYS_CHANNEL4_SPI0_SCK_gc = (0x68<<0) ; SPI 0 SCK
                                 .equ EVSYS_CHANNEL4_SPI1_SCK_gc = (0x69<<0) ; SPI 1 SCK
                                 .equ EVSYS_CHANNEL4_TCA0_OVF_LUNF_gc = (0x80<<0) ; Timer/Counter A0 overflow / low byte timer underflow
                                 .equ EVSYS_CHANNEL4_TCA0_HUNF_gc = (0x81<<0) ; Timer/Counter A0 high byte timer underflow
                                 .equ EVSYS_CHANNEL4_TCA0_CMP0_LCMP0_gc = (0x84<<0) ; Timer/Counter A0 compare 0 / low byte timer compare 0
                                 .equ EVSYS_CHANNEL4_TCA0_CMP1_LCMP1_gc = (0x85<<0) ; Timer/Counter A0 compare 1 / low byte timer compare 1
                                 .equ EVSYS_CHANNEL4_TCA0_CMP2_LCMP2_gc = (0x86<<0) ; Timer/Counter A0 compare 2 / low byte timer compare 2
                                 .equ EVSYS_CHANNEL4_TCA1_OVF_LUNF_gc = (0x88<<0) ; Timer/Counter A1 overflow / low byte timer underflow
                                 .equ EVSYS_CHANNEL4_TCA1_HUNF_gc = (0x89<<0) ; Timer/Counter A1 high byte timer underflow
                                 .equ EVSYS_CHANNEL4_TCA1_CMP0_LCMP0_gc = (0x8C<<0) ; Timer/Counter A1 compare 0 / low byte timer compare 0
                                 .equ EVSYS_CHANNEL4_TCA1_CMP1_LCMP1_gc = (0x8D<<0) ; Timer/Counter A1 compare 1 / low byte timer compare 1
                                 .equ EVSYS_CHANNEL4_TCA1_CMP2_LCMP2_gc = (0x8E<<0) ; Timer/Counter A1 compare 2 / low byte timer compare 2
                                 .equ EVSYS_CHANNEL4_TCB0_CAPT_gc = (0xA0<<0) ; Timer/Counter B0 capture
                                 .equ EVSYS_CHANNEL4_TCB0_OVF_gc = (0xA1<<0) ; Timer/Counter B0 overflow
                                 .equ EVSYS_CHANNEL4_TCB1_CAPT_gc = (0xA2<<0) ; Timer/Counter B1 capture
                                 .equ EVSYS_CHANNEL4_TCB1_OVF_gc = (0xA3<<0) ; Timer/Counter B1 overflow
                                 .equ EVSYS_CHANNEL4_TCB2_CAPT_gc = (0xA4<<0) ; Timer/Counter B2 capture
                                 .equ EVSYS_CHANNEL4_TCB2_OVF_gc = (0xA5<<0) ; Timer/Counter B2 overflow
                                 .equ EVSYS_CHANNEL4_TCB3_CAPT_gc = (0xA6<<0) ; Timer/Counter B3 capture
                                 .equ EVSYS_CHANNEL4_TCB3_OVF_gc = (0xA7<<0) ; Timer/Counter B3 overflow
                                 .equ EVSYS_CHANNEL4_TCB4_CAPT_gc = (0xA8<<0) ; Timer/Counter B4 capture
                                 .equ EVSYS_CHANNEL4_TCB4_OVF_gc = (0xA9<<0) ; Timer/Counter B4 overflow
                                 .equ EVSYS_CHANNEL4_TCD0_CMPBCLR_gc = (0xB0<<0) ; Timer/Counter D0 event 0
                                 .equ EVSYS_CHANNEL4_TCD0_CMPASET_gc = (0xB1<<0) ; Timer/Counter D0 event 1
                                 .equ EVSYS_CHANNEL4_TCD0_CMPBSET_gc = (0xB2<<0) ; Timer/Counter D0 event 2
                                 .equ EVSYS_CHANNEL4_TCD0_PROGEV_gc = (0xB3<<0) ; Timer/Counter D0 event 3
                                 
                                 ; Channel 5 generator select select
                                 .equ EVSYS_CHANNEL5_OFF_gc = (0x00<<0)   ; Off
                                 .equ EVSYS_CHANNEL5_UPDI_SYNCH_gc = (0x01<<0) ; UPDI SYNCH character
                                 .equ EVSYS_CHANNEL5_MVIO_gc = (0x05<<0)  ; MVIO VDDIO2 OK
                                 .equ EVSYS_CHANNEL5_RTC_OVF_gc = (0x06<<0) ; Real Time Counter overflow
                                 .equ EVSYS_CHANNEL5_RTC_CMP_gc = (0x07<<0) ; Real Time Counter compare
                                 .equ EVSYS_CHANNEL5_RTC_PIT_DIV512_gc = (0x08<<0) ; Periodic Interrupt Timer output 0
                                 .equ EVSYS_CHANNEL5_RTC_PIT_DIV256_gc = (0x09<<0) ; Periodic Interrupt Timer output 1
                                 .equ EVSYS_CHANNEL5_RTC_PIT_DIV128_gc = (0x0A<<0) ; Periodic Interrupt Timer output 2
                                 .equ EVSYS_CHANNEL5_RTC_PIT_DIV64_gc = (0x0B<<0) ; Periodic Interrupt Timer output 3
                                 .equ EVSYS_CHANNEL5_CCL_LUT0_gc = (0x10<<0) ; Configurable Custom Logic LUT0
                                 .equ EVSYS_CHANNEL5_CCL_LUT1_gc = (0x11<<0) ; Configurable Custom Logic LUT1
                                 .equ EVSYS_CHANNEL5_CCL_LUT2_gc = (0x12<<0) ; Configurable Custom Logic LUT2
                                 .equ EVSYS_CHANNEL5_CCL_LUT3_gc = (0x13<<0) ; Configurable Custom Logic LUT3
                                 .equ EVSYS_CHANNEL5_CCL_LUT4_gc = (0x14<<0) ; Configurable Custom Logic LUT4
                                 .equ EVSYS_CHANNEL5_CCL_LUT5_gc = (0x15<<0) ; Configurable Custom Logic LUT5
                                 .equ EVSYS_CHANNEL5_AC0_OUT_gc = (0x20<<0) ; Analog Comparator 0 out
                                 .equ EVSYS_CHANNEL5_AC1_OUT_gc = (0x21<<0) ; Analog Comparator 1 out
                                 .equ EVSYS_CHANNEL5_AC2_OUT_gc = (0x22<<0) ; Analog Comparator 2 out
                                 .equ EVSYS_CHANNEL5_ADC0_RESRDY_gc = (0x24<<0) ; ADC 0 Result Ready
                                 .equ EVSYS_CHANNEL5_ZCD0_gc = (0x30<<0)  ; Zero Cross Detect 0 out
                                 .equ EVSYS_CHANNEL5_ZCD1_gc = (0x31<<0)  ; Zero Cross Detect 1 out
                                 .equ EVSYS_CHANNEL5_ZCD2_gc = (0x32<<0)  ; Zero Cross Detect 2 out
                                 .equ EVSYS_CHANNEL5_OPAMP0_READY_gc = (0x34<<0) ; OPAMP0 Ready
                                 .equ EVSYS_CHANNEL5_OPAMP1_READY_gc = (0x35<<0) ; OPAMP1 Ready
                                 .equ EVSYS_CHANNEL5_OPAMP2_READY_gc = (0x36<<0) ; OPAMP2 Ready
                                 .equ EVSYS_CHANNEL5_PORTE_PIN0_gc = (0x40<<0) ; Port E Pin 0
                                 .equ EVSYS_CHANNEL5_PORTE_PIN1_gc = (0x41<<0) ; Port E Pin 1
                                 .equ EVSYS_CHANNEL5_PORTE_PIN2_gc = (0x42<<0) ; Port E Pin 2
                                 .equ EVSYS_CHANNEL5_PORTE_PIN3_gc = (0x43<<0) ; Port E Pin 3
                                 .equ EVSYS_CHANNEL5_PORTE_PIN4_gc = (0x44<<0) ; Port E Pin 4
                                 .equ EVSYS_CHANNEL5_PORTE_PIN5_gc = (0x45<<0) ; Port E Pin 5
                                 .equ EVSYS_CHANNEL5_PORTE_PIN6_gc = (0x46<<0) ; Port E Pin 6
                                 .equ EVSYS_CHANNEL5_PORTE_PIN7_gc = (0x47<<0) ; Port E Pin 7
                                 .equ EVSYS_CHANNEL5_PORTF_PIN0_gc = (0x48<<0) ; Port F Pin 0
                                 .equ EVSYS_CHANNEL5_PORTF_PIN1_gc = (0x49<<0) ; Port F Pin 1
                                 .equ EVSYS_CHANNEL5_PORTF_PIN2_gc = (0x4A<<0) ; Port F Pin 2
                                 .equ EVSYS_CHANNEL5_PORTF_PIN3_gc = (0x4B<<0) ; Port F Pin 3
                                 .equ EVSYS_CHANNEL5_PORTF_PIN4_gc = (0x4C<<0) ; Port F Pin 4
                                 .equ EVSYS_CHANNEL5_PORTF_PIN5_gc = (0x4D<<0) ; Port F Pin 5
                                 .equ EVSYS_CHANNEL5_PORTF_PIN6_gc = (0x4E<<0) ; Port F Pin 6
                                 .equ EVSYS_CHANNEL5_USART0_XCK_gc = (0x60<<0) ; USART 0 XCK
                                 .equ EVSYS_CHANNEL5_USART1_XCK_gc = (0x61<<0) ; USART 1 XCK
                                 .equ EVSYS_CHANNEL5_USART2_XCK_gc = (0x62<<0) ; USART 2 XCK
                                 .equ EVSYS_CHANNEL5_USART3_XCK_gc = (0x63<<0) ; USART 3 XCK
                                 .equ EVSYS_CHANNEL5_USART4_XCK_gc = (0x64<<0) ; USART 4 XCK
                                 .equ EVSYS_CHANNEL5_USART5_XCK_gc = (0x65<<0) ; USART 5 XCK
                                 .equ EVSYS_CHANNEL5_SPI0_SCK_gc = (0x68<<0) ; SPI 0 SCK
                                 .equ EVSYS_CHANNEL5_SPI1_SCK_gc = (0x69<<0) ; SPI 1 SCK
                                 .equ EVSYS_CHANNEL5_TCA0_OVF_LUNF_gc = (0x80<<0) ; Timer/Counter A0 overflow / low byte timer underflow
                                 .equ EVSYS_CHANNEL5_TCA0_HUNF_gc = (0x81<<0) ; Timer/Counter A0 high byte timer underflow
                                 .equ EVSYS_CHANNEL5_TCA0_CMP0_LCMP0_gc = (0x84<<0) ; Timer/Counter A0 compare 0 / low byte timer compare 0
                                 .equ EVSYS_CHANNEL5_TCA0_CMP1_LCMP1_gc = (0x85<<0) ; Timer/Counter A0 compare 1 / low byte timer compare 1
                                 .equ EVSYS_CHANNEL5_TCA0_CMP2_LCMP2_gc = (0x86<<0) ; Timer/Counter A0 compare 2 / low byte timer compare 2
                                 .equ EVSYS_CHANNEL5_TCA1_OVF_LUNF_gc = (0x88<<0) ; Timer/Counter A1 overflow / low byte timer underflow
                                 .equ EVSYS_CHANNEL5_TCA1_HUNF_gc = (0x89<<0) ; Timer/Counter A1 high byte timer underflow
                                 .equ EVSYS_CHANNEL5_TCA1_CMP0_LCMP0_gc = (0x8C<<0) ; Timer/Counter A1 compare 0 / low byte timer compare 0
                                 .equ EVSYS_CHANNEL5_TCA1_CMP1_LCMP1_gc = (0x8D<<0) ; Timer/Counter A1 compare 1 / low byte timer compare 1
                                 .equ EVSYS_CHANNEL5_TCA1_CMP2_LCMP2_gc = (0x8E<<0) ; Timer/Counter A1 compare 2 / low byte timer compare 2
                                 .equ EVSYS_CHANNEL5_TCB0_CAPT_gc = (0xA0<<0) ; Timer/Counter B0 capture
                                 .equ EVSYS_CHANNEL5_TCB0_OVF_gc = (0xA1<<0) ; Timer/Counter B0 overflow
                                 .equ EVSYS_CHANNEL5_TCB1_CAPT_gc = (0xA2<<0) ; Timer/Counter B1 capture
                                 .equ EVSYS_CHANNEL5_TCB1_OVF_gc = (0xA3<<0) ; Timer/Counter B1 overflow
                                 .equ EVSYS_CHANNEL5_TCB2_CAPT_gc = (0xA4<<0) ; Timer/Counter B2 capture
                                 .equ EVSYS_CHANNEL5_TCB2_OVF_gc = (0xA5<<0) ; Timer/Counter B2 overflow
                                 .equ EVSYS_CHANNEL5_TCB3_CAPT_gc = (0xA6<<0) ; Timer/Counter B3 capture
                                 .equ EVSYS_CHANNEL5_TCB3_OVF_gc = (0xA7<<0) ; Timer/Counter B3 overflow
                                 .equ EVSYS_CHANNEL5_TCB4_CAPT_gc = (0xA8<<0) ; Timer/Counter B4 capture
                                 .equ EVSYS_CHANNEL5_TCB4_OVF_gc = (0xA9<<0) ; Timer/Counter B4 overflow
                                 .equ EVSYS_CHANNEL5_TCD0_CMPBCLR_gc = (0xB0<<0) ; Timer/Counter D0 event 0
                                 .equ EVSYS_CHANNEL5_TCD0_CMPASET_gc = (0xB1<<0) ; Timer/Counter D0 event 1
                                 .equ EVSYS_CHANNEL5_TCD0_CMPBSET_gc = (0xB2<<0) ; Timer/Counter D0 event 2
                                 .equ EVSYS_CHANNEL5_TCD0_PROGEV_gc = (0xB3<<0) ; Timer/Counter D0 event 3
                                 
                                 ; Channel 6 generator select select
                                 .equ EVSYS_CHANNEL6_OFF_gc = (0x00<<0)   ; Off
                                 .equ EVSYS_CHANNEL6_UPDI_SYNCH_gc = (0x01<<0) ; UPDI SYNCH character
                                 .equ EVSYS_CHANNEL6_MVIO_gc = (0x05<<0)  ; MVIO VDDIO2 OK
                                 .equ EVSYS_CHANNEL6_RTC_OVF_gc = (0x06<<0) ; Real Time Counter overflow
                                 .equ EVSYS_CHANNEL6_RTC_CMP_gc = (0x07<<0) ; Real Time Counter compare
                                 .equ EVSYS_CHANNEL6_RTC_PIT_DIV8192_gc = (0x08<<0) ; Periodic Interrupt Timer output 0
                                 .equ EVSYS_CHANNEL6_RTC_PIT_DIV4096_gc = (0x09<<0) ; Periodic Interrupt Timer output 1
                                 .equ EVSYS_CHANNEL6_RTC_PIT_DIV2048_gc = (0x0A<<0) ; Periodic Interrupt Timer output 2
                                 .equ EVSYS_CHANNEL6_RTC_PIT_DIV1024_gc = (0x0B<<0) ; Periodic Interrupt Timer output 3
                                 .equ EVSYS_CHANNEL6_CCL_LUT0_gc = (0x10<<0) ; Configurable Custom Logic LUT0
                                 .equ EVSYS_CHANNEL6_CCL_LUT1_gc = (0x11<<0) ; Configurable Custom Logic LUT1
                                 .equ EVSYS_CHANNEL6_CCL_LUT2_gc = (0x12<<0) ; Configurable Custom Logic LUT2
                                 .equ EVSYS_CHANNEL6_CCL_LUT3_gc = (0x13<<0) ; Configurable Custom Logic LUT3
                                 .equ EVSYS_CHANNEL6_CCL_LUT4_gc = (0x14<<0) ; Configurable Custom Logic LUT4
                                 .equ EVSYS_CHANNEL6_CCL_LUT5_gc = (0x15<<0) ; Configurable Custom Logic LUT5
                                 .equ EVSYS_CHANNEL6_AC0_OUT_gc = (0x20<<0) ; Analog Comparator 0 out
                                 .equ EVSYS_CHANNEL6_AC1_OUT_gc = (0x21<<0) ; Analog Comparator 1 out
                                 .equ EVSYS_CHANNEL6_AC2_OUT_gc = (0x22<<0) ; Analog Comparator 2 out
                                 .equ EVSYS_CHANNEL6_ADC0_RESRDY_gc = (0x24<<0) ; ADC 0 Result Ready
                                 .equ EVSYS_CHANNEL6_ZCD0_gc = (0x30<<0)  ; Zero Cross Detect 0 out
                                 .equ EVSYS_CHANNEL6_ZCD1_gc = (0x31<<0)  ; Zero Cross Detect 1 out
                                 .equ EVSYS_CHANNEL6_ZCD2_gc = (0x32<<0)  ; Zero Cross Detect 2 out
                                 .equ EVSYS_CHANNEL6_OPAMP0_READY_gc = (0x34<<0) ; OPAMP0 Ready
                                 .equ EVSYS_CHANNEL6_OPAMP1_READY_gc = (0x35<<0) ; OPAMP1 Ready
                                 .equ EVSYS_CHANNEL6_OPAMP2_READY_gc = (0x36<<0) ; OPAMP2 Ready
                                 .equ EVSYS_CHANNEL6_PORTG_PIN0_gc = (0x40<<0) ; Port G Pin 0
                                 .equ EVSYS_CHANNEL6_PORTG_PIN1_gc = (0x41<<0) ; Port G Pin 1
                                 .equ EVSYS_CHANNEL6_PORTG_PIN2_gc = (0x42<<0) ; Port G Pin 2
                                 .equ EVSYS_CHANNEL6_PORTG_PIN3_gc = (0x43<<0) ; Port G Pin 3
                                 .equ EVSYS_CHANNEL6_PORTG_PIN4_gc = (0x44<<0) ; Port G Pin 4
                                 .equ EVSYS_CHANNEL6_PORTG_PIN5_gc = (0x45<<0) ; Port G Pin 5
                                 .equ EVSYS_CHANNEL6_PORTG_PIN6_gc = (0x46<<0) ; Port G Pin 6
                                 .equ EVSYS_CHANNEL6_PORTG_PIN7_gc = (0x47<<0) ; Port G Pin 7
                                 .equ EVSYS_CHANNEL6_USART0_XCK_gc = (0x60<<0) ; USART 0 XCK
                                 .equ EVSYS_CHANNEL6_USART1_XCK_gc = (0x61<<0) ; USART 1 XCK
                                 .equ EVSYS_CHANNEL6_USART2_XCK_gc = (0x62<<0) ; USART 2 XCK
                                 .equ EVSYS_CHANNEL6_USART3_XCK_gc = (0x63<<0) ; USART 3 XCK
                                 .equ EVSYS_CHANNEL6_USART4_XCK_gc = (0x64<<0) ; USART 4 XCK
                                 .equ EVSYS_CHANNEL6_USART5_XCK_gc = (0x65<<0) ; USART 5 XCK
                                 .equ EVSYS_CHANNEL6_SPI0_SCK_gc = (0x68<<0) ; SPI 0 SCK
                                 .equ EVSYS_CHANNEL6_SPI1_SCK_gc = (0x69<<0) ; SPI 1 SCK
                                 .equ EVSYS_CHANNEL6_TCA0_OVF_LUNF_gc = (0x80<<0) ; Timer/Counter A0 overflow / low byte timer underflow
                                 .equ EVSYS_CHANNEL6_TCA0_HUNF_gc = (0x81<<0) ; Timer/Counter A0 high byte timer underflow
                                 .equ EVSYS_CHANNEL6_TCA0_CMP0_LCMP0_gc = (0x84<<0) ; Timer/Counter A0 compare 0 / low byte timer compare 0
                                 .equ EVSYS_CHANNEL6_TCA0_CMP1_LCMP1_gc = (0x85<<0) ; Timer/Counter A0 compare 1 / low byte timer compare 1
                                 .equ EVSYS_CHANNEL6_TCA0_CMP2_LCMP2_gc = (0x86<<0) ; Timer/Counter A0 compare 2 / low byte timer compare 2
                                 .equ EVSYS_CHANNEL6_TCA1_OVF_LUNF_gc = (0x88<<0) ; Timer/Counter A1 overflow / low byte timer underflow
                                 .equ EVSYS_CHANNEL6_TCA1_HUNF_gc = (0x89<<0) ; Timer/Counter A1 high byte timer underflow
                                 .equ EVSYS_CHANNEL6_TCA1_CMP0_LCMP0_gc = (0x8C<<0) ; Timer/Counter A1 compare 0 / low byte timer compare 0
                                 .equ EVSYS_CHANNEL6_TCA1_CMP1_LCMP1_gc = (0x8D<<0) ; Timer/Counter A1 compare 1 / low byte timer compare 1
                                 .equ EVSYS_CHANNEL6_TCA1_CMP2_LCMP2_gc = (0x8E<<0) ; Timer/Counter A1 compare 2 / low byte timer compare 2
                                 .equ EVSYS_CHANNEL6_TCB0_CAPT_gc = (0xA0<<0) ; Timer/Counter B0 capture
                                 .equ EVSYS_CHANNEL6_TCB0_OVF_gc = (0xA1<<0) ; Timer/Counter B0 overflow
                                 .equ EVSYS_CHANNEL6_TCB1_CAPT_gc = (0xA2<<0) ; Timer/Counter B1 capture
                                 .equ EVSYS_CHANNEL6_TCB1_OVF_gc = (0xA3<<0) ; Timer/Counter B1 overflow
                                 .equ EVSYS_CHANNEL6_TCB2_CAPT_gc = (0xA4<<0) ; Timer/Counter B2 capture
                                 .equ EVSYS_CHANNEL6_TCB2_OVF_gc = (0xA5<<0) ; Timer/Counter B2 overflow
                                 .equ EVSYS_CHANNEL6_TCB3_CAPT_gc = (0xA6<<0) ; Timer/Counter B3 capture
                                 .equ EVSYS_CHANNEL6_TCB3_OVF_gc = (0xA7<<0) ; Timer/Counter B3 overflow
                                 .equ EVSYS_CHANNEL6_TCB4_CAPT_gc = (0xA8<<0) ; Timer/Counter B4 capture
                                 .equ EVSYS_CHANNEL6_TCB4_OVF_gc = (0xA9<<0) ; Timer/Counter B4 overflow
                                 .equ EVSYS_CHANNEL6_TCD0_CMPBCLR_gc = (0xB0<<0) ; Timer/Counter D0 event 0
                                 .equ EVSYS_CHANNEL6_TCD0_CMPASET_gc = (0xB1<<0) ; Timer/Counter D0 event 1
                                 .equ EVSYS_CHANNEL6_TCD0_CMPBSET_gc = (0xB2<<0) ; Timer/Counter D0 event 2
                                 .equ EVSYS_CHANNEL6_TCD0_PROGEV_gc = (0xB3<<0) ; Timer/Counter D0 event 3
                                 
                                 ; Channel 7 generator select select
                                 .equ EVSYS_CHANNEL7_OFF_gc = (0x00<<0)   ; Off
                                 .equ EVSYS_CHANNEL7_UPDI_SYNCH_gc = (0x01<<0) ; UPDI SYNCH character
                                 .equ EVSYS_CHANNEL7_MVIO_gc = (0x05<<0)  ; MVIO VDDIO2 OK
                                 .equ EVSYS_CHANNEL7_RTC_OVF_gc = (0x06<<0) ; Real Time Counter overflow
                                 .equ EVSYS_CHANNEL7_RTC_CMP_gc = (0x07<<0) ; Real Time Counter compare
                                 .equ EVSYS_CHANNEL7_RTC_PIT_DIV512_gc = (0x08<<0) ; Periodic Interrupt Timer output 0
                                 .equ EVSYS_CHANNEL7_RTC_PIT_DIV256_gc = (0x09<<0) ; Periodic Interrupt Timer output 1
                                 .equ EVSYS_CHANNEL7_RTC_PIT_DIV128_gc = (0x0A<<0) ; Periodic Interrupt Timer output 2
                                 .equ EVSYS_CHANNEL7_RTC_PIT_DIV64_gc = (0x0B<<0) ; Periodic Interrupt Timer output 3
                                 .equ EVSYS_CHANNEL7_CCL_LUT0_gc = (0x10<<0) ; Configurable Custom Logic LUT0
                                 .equ EVSYS_CHANNEL7_CCL_LUT1_gc = (0x11<<0) ; Configurable Custom Logic LUT1
                                 .equ EVSYS_CHANNEL7_CCL_LUT2_gc = (0x12<<0) ; Configurable Custom Logic LUT2
                                 .equ EVSYS_CHANNEL7_CCL_LUT3_gc = (0x13<<0) ; Configurable Custom Logic LUT3
                                 .equ EVSYS_CHANNEL7_CCL_LUT4_gc = (0x14<<0) ; Configurable Custom Logic LUT4
                                 .equ EVSYS_CHANNEL7_CCL_LUT5_gc = (0x15<<0) ; Configurable Custom Logic LUT5
                                 .equ EVSYS_CHANNEL7_AC0_OUT_gc = (0x20<<0) ; Analog Comparator 0 out
                                 .equ EVSYS_CHANNEL7_AC1_OUT_gc = (0x21<<0) ; Analog Comparator 1 out
                                 .equ EVSYS_CHANNEL7_AC2_OUT_gc = (0x22<<0) ; Analog Comparator 2 out
                                 .equ EVSYS_CHANNEL7_ADC0_RESRDY_gc = (0x24<<0) ; ADC 0 Result Ready
                                 .equ EVSYS_CHANNEL7_ZCD0_gc = (0x30<<0)  ; Zero Cross Detect 0 out
                                 .equ EVSYS_CHANNEL7_ZCD1_gc = (0x31<<0)  ; Zero Cross Detect 1 out
                                 .equ EVSYS_CHANNEL7_ZCD2_gc = (0x32<<0)  ; Zero Cross Detect 2 out
                                 .equ EVSYS_CHANNEL7_OPAMP0_READY_gc = (0x34<<0) ; OPAMP0 Ready
                                 .equ EVSYS_CHANNEL7_OPAMP1_READY_gc = (0x35<<0) ; OPAMP1 Ready
                                 .equ EVSYS_CHANNEL7_OPAMP2_READY_gc = (0x36<<0) ; OPAMP2 Ready
                                 .equ EVSYS_CHANNEL7_PORTG_PIN0_gc = (0x40<<0) ; Port G Pin 0
                                 .equ EVSYS_CHANNEL7_PORTG_PIN1_gc = (0x41<<0) ; Port G Pin 1
                                 .equ EVSYS_CHANNEL7_PORTG_PIN2_gc = (0x42<<0) ; Port G Pin 2
                                 .equ EVSYS_CHANNEL7_PORTG_PIN3_gc = (0x43<<0) ; Port G Pin 3
                                 .equ EVSYS_CHANNEL7_PORTG_PIN4_gc = (0x44<<0) ; Port G Pin 4
                                 .equ EVSYS_CHANNEL7_PORTG_PIN5_gc = (0x45<<0) ; Port G Pin 5
                                 .equ EVSYS_CHANNEL7_PORTG_PIN6_gc = (0x46<<0) ; Port G Pin 6
                                 .equ EVSYS_CHANNEL7_PORTG_PIN7_gc = (0x47<<0) ; Port G Pin 7
                                 .equ EVSYS_CHANNEL7_USART0_XCK_gc = (0x60<<0) ; USART 0 XCK
                                 .equ EVSYS_CHANNEL7_USART1_XCK_gc = (0x61<<0) ; USART 1 XCK
                                 .equ EVSYS_CHANNEL7_USART2_XCK_gc = (0x62<<0) ; USART 2 XCK
                                 .equ EVSYS_CHANNEL7_USART3_XCK_gc = (0x63<<0) ; USART 3 XCK
                                 .equ EVSYS_CHANNEL7_USART4_XCK_gc = (0x64<<0) ; USART 4 XCK
                                 .equ EVSYS_CHANNEL7_USART5_XCK_gc = (0x65<<0) ; USART 5 XCK
                                 .equ EVSYS_CHANNEL7_SPI0_SCK_gc = (0x68<<0) ; SPI 0 SCK
                                 .equ EVSYS_CHANNEL7_SPI1_SCK_gc = (0x69<<0) ; SPI 1 SCK
                                 .equ EVSYS_CHANNEL7_TCA0_OVF_LUNF_gc = (0x80<<0) ; Timer/Counter A0 overflow / low byte timer underflow
                                 .equ EVSYS_CHANNEL7_TCA0_HUNF_gc = (0x81<<0) ; Timer/Counter A0 high byte timer underflow
                                 .equ EVSYS_CHANNEL7_TCA0_CMP0_LCMP0_gc = (0x84<<0) ; Timer/Counter A0 compare 0 / low byte timer compare 0
                                 .equ EVSYS_CHANNEL7_TCA0_CMP1_LCMP1_gc = (0x85<<0) ; Timer/Counter A0 compare 1 / low byte timer compare 1
                                 .equ EVSYS_CHANNEL7_TCA0_CMP2_LCMP2_gc = (0x86<<0) ; Timer/Counter A0 compare 2 / low byte timer compare 2
                                 .equ EVSYS_CHANNEL7_TCA1_OVF_LUNF_gc = (0x88<<0) ; Timer/Counter A1 overflow / low byte timer underflow
                                 .equ EVSYS_CHANNEL7_TCA1_HUNF_gc = (0x89<<0) ; Timer/Counter A1 high byte timer underflow
                                 .equ EVSYS_CHANNEL7_TCA1_CMP0_LCMP0_gc = (0x8C<<0) ; Timer/Counter A1 compare 0 / low byte timer compare 0
                                 .equ EVSYS_CHANNEL7_TCA1_CMP1_LCMP1_gc = (0x8D<<0) ; Timer/Counter A1 compare 1 / low byte timer compare 1
                                 .equ EVSYS_CHANNEL7_TCA1_CMP2_LCMP2_gc = (0x8E<<0) ; Timer/Counter A1 compare 2 / low byte timer compare 2
                                 .equ EVSYS_CHANNEL7_TCB0_CAPT_gc = (0xA0<<0) ; Timer/Counter B0 capture
                                 .equ EVSYS_CHANNEL7_TCB0_OVF_gc = (0xA1<<0) ; Timer/Counter B0 overflow
                                 .equ EVSYS_CHANNEL7_TCB1_CAPT_gc = (0xA2<<0) ; Timer/Counter B1 capture
                                 .equ EVSYS_CHANNEL7_TCB1_OVF_gc = (0xA3<<0) ; Timer/Counter B1 overflow
                                 .equ EVSYS_CHANNEL7_TCB2_CAPT_gc = (0xA4<<0) ; Timer/Counter B2 capture
                                 .equ EVSYS_CHANNEL7_TCB2_OVF_gc = (0xA5<<0) ; Timer/Counter B2 overflow
                                 .equ EVSYS_CHANNEL7_TCB3_CAPT_gc = (0xA6<<0) ; Timer/Counter B3 capture
                                 .equ EVSYS_CHANNEL7_TCB3_OVF_gc = (0xA7<<0) ; Timer/Counter B3 overflow
                                 .equ EVSYS_CHANNEL7_TCB4_CAPT_gc = (0xA8<<0) ; Timer/Counter B4 capture
                                 .equ EVSYS_CHANNEL7_TCB4_OVF_gc = (0xA9<<0) ; Timer/Counter B4 overflow
                                 .equ EVSYS_CHANNEL7_TCD0_CMPBCLR_gc = (0xB0<<0) ; Timer/Counter D0 event 0
                                 .equ EVSYS_CHANNEL7_TCD0_CMPASET_gc = (0xB1<<0) ; Timer/Counter D0 event 1
                                 .equ EVSYS_CHANNEL7_TCD0_CMPBSET_gc = (0xB2<<0) ; Timer/Counter D0 event 2
                                 .equ EVSYS_CHANNEL7_TCD0_PROGEV_gc = (0xB3<<0) ; Timer/Counter D0 event 3
                                 
                                 ; Channel 8 generator select select
                                 .equ EVSYS_CHANNEL8_OFF_gc = (0x00<<0)   ; Off
                                 .equ EVSYS_CHANNEL8_UPDI_SYNCH_gc = (0x01<<0) ; UPDI SYNCH character
                                 .equ EVSYS_CHANNEL8_MVIO_gc = (0x05<<0)  ; MVIO VDDIO2 OK
                                 .equ EVSYS_CHANNEL8_RTC_OVF_gc = (0x06<<0) ; Real Time Counter overflow
                                 .equ EVSYS_CHANNEL8_RTC_CMP_gc = (0x07<<0) ; Real Time Counter compare
                                 .equ EVSYS_CHANNEL8_RTC_PIT_DIV8192_gc = (0x08<<0) ; Periodic Interrupt Timer output 0
                                 .equ EVSYS_CHANNEL8_RTC_PIT_DIV4096_gc = (0x09<<0) ; Periodic Interrupt Timer output 1
                                 .equ EVSYS_CHANNEL8_RTC_PIT_DIV2048_gc = (0x0A<<0) ; Periodic Interrupt Timer output 2
                                 .equ EVSYS_CHANNEL8_RTC_PIT_DIV1024_gc = (0x0B<<0) ; Periodic Interrupt Timer output 3
                                 .equ EVSYS_CHANNEL8_CCL_LUT0_gc = (0x10<<0) ; Configurable Custom Logic LUT0
                                 .equ EVSYS_CHANNEL8_CCL_LUT1_gc = (0x11<<0) ; Configurable Custom Logic LUT1
                                 .equ EVSYS_CHANNEL8_CCL_LUT2_gc = (0x12<<0) ; Configurable Custom Logic LUT2
                                 .equ EVSYS_CHANNEL8_CCL_LUT3_gc = (0x13<<0) ; Configurable Custom Logic LUT3
                                 .equ EVSYS_CHANNEL8_CCL_LUT4_gc = (0x14<<0) ; Configurable Custom Logic LUT4
                                 .equ EVSYS_CHANNEL8_CCL_LUT5_gc = (0x15<<0) ; Configurable Custom Logic LUT5
                                 .equ EVSYS_CHANNEL8_AC0_OUT_gc = (0x20<<0) ; Analog Comparator 0 out
                                 .equ EVSYS_CHANNEL8_AC1_OUT_gc = (0x21<<0) ; Analog Comparator 1 out
                                 .equ EVSYS_CHANNEL8_AC2_OUT_gc = (0x22<<0) ; Analog Comparator 2 out
                                 .equ EVSYS_CHANNEL8_ADC0_RESRDY_gc = (0x24<<0) ; ADC 0 Result Ready
                                 .equ EVSYS_CHANNEL8_ZCD0_gc = (0x30<<0)  ; Zero Cross Detect 0 out
                                 .equ EVSYS_CHANNEL8_ZCD1_gc = (0x31<<0)  ; Zero Cross Detect 1 out
                                 .equ EVSYS_CHANNEL8_ZCD2_gc = (0x32<<0)  ; Zero Cross Detect 2 out
                                 .equ EVSYS_CHANNEL8_OPAMP0_READY_gc = (0x34<<0) ; OPAMP0 Ready
                                 .equ EVSYS_CHANNEL8_OPAMP1_READY_gc = (0x35<<0) ; OPAMP1 Ready
                                 .equ EVSYS_CHANNEL8_OPAMP2_READY_gc = (0x36<<0) ; OPAMP2 Ready
                                 .equ EVSYS_CHANNEL8_USART0_XCK_gc = (0x60<<0) ; USART 0 XCK
                                 .equ EVSYS_CHANNEL8_USART1_XCK_gc = (0x61<<0) ; USART 1 XCK
                                 .equ EVSYS_CHANNEL8_USART2_XCK_gc = (0x62<<0) ; USART 2 XCK
                                 .equ EVSYS_CHANNEL8_USART3_XCK_gc = (0x63<<0) ; USART 3 XCK
                                 .equ EVSYS_CHANNEL8_USART4_XCK_gc = (0x64<<0) ; USART 4 XCK
                                 .equ EVSYS_CHANNEL8_USART5_XCK_gc = (0x65<<0) ; USART 5 XCK
                                 .equ EVSYS_CHANNEL8_SPI0_SCK_gc = (0x68<<0) ; SPI 0 SCK
                                 .equ EVSYS_CHANNEL8_SPI1_SCK_gc = (0x69<<0) ; SPI 1 SCK
                                 .equ EVSYS_CHANNEL8_TCA0_OVF_LUNF_gc = (0x80<<0) ; Timer/Counter A0 overflow / low byte timer underflow
                                 .equ EVSYS_CHANNEL8_TCA0_HUNF_gc = (0x81<<0) ; Timer/Counter A0 high byte timer underflow
                                 .equ EVSYS_CHANNEL8_TCA0_CMP0_LCMP0_gc = (0x84<<0) ; Timer/Counter A0 compare 0 / low byte timer compare 0
                                 .equ EVSYS_CHANNEL8_TCA0_CMP1_LCMP1_gc = (0x85<<0) ; Timer/Counter A0 compare 1 / low byte timer compare 1
                                 .equ EVSYS_CHANNEL8_TCA0_CMP2_LCMP2_gc = (0x86<<0) ; Timer/Counter A0 compare 2 / low byte timer compare 2
                                 .equ EVSYS_CHANNEL8_TCA1_OVF_LUNF_gc = (0x88<<0) ; Timer/Counter A1 overflow / low byte timer underflow
                                 .equ EVSYS_CHANNEL8_TCA1_HUNF_gc = (0x89<<0) ; Timer/Counter A1 high byte timer underflow
                                 .equ EVSYS_CHANNEL8_TCA1_CMP0_LCMP0_gc = (0x8C<<0) ; Timer/Counter A1 compare 0 / low byte timer compare 0
                                 .equ EVSYS_CHANNEL8_TCA1_CMP1_LCMP1_gc = (0x8D<<0) ; Timer/Counter A1 compare 1 / low byte timer compare 1
                                 .equ EVSYS_CHANNEL8_TCA1_CMP2_LCMP2_gc = (0x8E<<0) ; Timer/Counter A1 compare 2 / low byte timer compare 2
                                 .equ EVSYS_CHANNEL8_TCB0_CAPT_gc = (0xA0<<0) ; Timer/Counter B0 capture
                                 .equ EVSYS_CHANNEL8_TCB0_OVF_gc = (0xA1<<0) ; Timer/Counter B0 overflow
                                 .equ EVSYS_CHANNEL8_TCB1_CAPT_gc = (0xA2<<0) ; Timer/Counter B1 capture
                                 .equ EVSYS_CHANNEL8_TCB1_OVF_gc = (0xA3<<0) ; Timer/Counter B1 overflow
                                 .equ EVSYS_CHANNEL8_TCB2_CAPT_gc = (0xA4<<0) ; Timer/Counter B2 capture
                                 .equ EVSYS_CHANNEL8_TCB2_OVF_gc = (0xA5<<0) ; Timer/Counter B2 overflow
                                 .equ EVSYS_CHANNEL8_TCB3_CAPT_gc = (0xA6<<0) ; Timer/Counter B3 capture
                                 .equ EVSYS_CHANNEL8_TCB3_OVF_gc = (0xA7<<0) ; Timer/Counter B3 overflow
                                 .equ EVSYS_CHANNEL8_TCB4_CAPT_gc = (0xA8<<0) ; Timer/Counter B4 capture
                                 .equ EVSYS_CHANNEL8_TCB4_OVF_gc = (0xA9<<0) ; Timer/Counter B4 overflow
                                 .equ EVSYS_CHANNEL8_TCD0_CMPBCLR_gc = (0xB0<<0) ; Timer/Counter D0 event 0
                                 .equ EVSYS_CHANNEL8_TCD0_CMPASET_gc = (0xB1<<0) ; Timer/Counter D0 event 1
                                 .equ EVSYS_CHANNEL8_TCD0_CMPBSET_gc = (0xB2<<0) ; Timer/Counter D0 event 2
                                 .equ EVSYS_CHANNEL8_TCD0_PROGEV_gc = (0xB3<<0) ; Timer/Counter D0 event 3
                                 
                                 ; Channel 9 generator select select
                                 .equ EVSYS_CHANNEL9_OFF_gc = (0x00<<0)   ; Off
                                 .equ EVSYS_CHANNEL9_UPDI_SYNCH_gc = (0x01<<0) ; UPDI SYNCH character
                                 .equ EVSYS_CHANNEL9_MVIO_gc = (0x05<<0)  ; MVIO VDDIO2 OK
                                 .equ EVSYS_CHANNEL9_RTC_OVF_gc = (0x06<<0) ; Real Time Counter overflow
                                 .equ EVSYS_CHANNEL9_RTC_CMP_gc = (0x07<<0) ; Real Time Counter compare
                                 .equ EVSYS_CHANNEL9_RTC_PIT_DIV512_gc = (0x08<<0) ; Periodic Interrupt Timer output 0
                                 .equ EVSYS_CHANNEL9_RTC_PIT_DIV256_gc = (0x09<<0) ; Periodic Interrupt Timer output 1
                                 .equ EVSYS_CHANNEL9_RTC_PIT_DIV128_gc = (0x0A<<0) ; Periodic Interrupt Timer output 2
                                 .equ EVSYS_CHANNEL9_RTC_PIT_DIV64_gc = (0x0B<<0) ; Periodic Interrupt Timer output 3
                                 .equ EVSYS_CHANNEL9_CCL_LUT0_gc = (0x10<<0) ; Configurable Custom Logic LUT0
                                 .equ EVSYS_CHANNEL9_CCL_LUT1_gc = (0x11<<0) ; Configurable Custom Logic LUT1
                                 .equ EVSYS_CHANNEL9_CCL_LUT2_gc = (0x12<<0) ; Configurable Custom Logic LUT2
                                 .equ EVSYS_CHANNEL9_CCL_LUT3_gc = (0x13<<0) ; Configurable Custom Logic LUT3
                                 .equ EVSYS_CHANNEL9_CCL_LUT4_gc = (0x14<<0) ; Configurable Custom Logic LUT4
                                 .equ EVSYS_CHANNEL9_CCL_LUT5_gc = (0x15<<0) ; Configurable Custom Logic LUT5
                                 .equ EVSYS_CHANNEL9_AC0_OUT_gc = (0x20<<0) ; Analog Comparator 0 out
                                 .equ EVSYS_CHANNEL9_AC1_OUT_gc = (0x21<<0) ; Analog Comparator 1 out
                                 .equ EVSYS_CHANNEL9_AC2_OUT_gc = (0x22<<0) ; Analog Comparator 2 out
                                 .equ EVSYS_CHANNEL9_ADC0_RESRDY_gc = (0x24<<0) ; ADC 0 Result Ready
                                 .equ EVSYS_CHANNEL9_ZCD0_gc = (0x30<<0)  ; Zero Cross Detect 0 out
                                 .equ EVSYS_CHANNEL9_ZCD1_gc = (0x31<<0)  ; Zero Cross Detect 1 out
                                 .equ EVSYS_CHANNEL9_ZCD2_gc = (0x32<<0)  ; Zero Cross Detect 2 out
                                 .equ EVSYS_CHANNEL9_OPAMP0_READY_gc = (0x34<<0) ; OPAMP0 Ready
                                 .equ EVSYS_CHANNEL9_OPAMP1_READY_gc = (0x35<<0) ; OPAMP1 Ready
                                 .equ EVSYS_CHANNEL9_OPAMP2_READY_gc = (0x36<<0) ; OPAMP2 Ready
                                 .equ EVSYS_CHANNEL9_USART0_XCK_gc = (0x60<<0) ; USART 0 XCK
                                 .equ EVSYS_CHANNEL9_USART1_XCK_gc = (0x61<<0) ; USART 1 XCK
                                 .equ EVSYS_CHANNEL9_USART2_XCK_gc = (0x62<<0) ; USART 2 XCK
                                 .equ EVSYS_CHANNEL9_USART3_XCK_gc = (0x63<<0) ; USART 3 XCK
                                 .equ EVSYS_CHANNEL9_USART4_XCK_gc = (0x64<<0) ; USART 4 XCK
                                 .equ EVSYS_CHANNEL9_USART5_XCK_gc = (0x65<<0) ; USART 5 XCK
                                 .equ EVSYS_CHANNEL9_SPI0_SCK_gc = (0x68<<0) ; SPI 0 SCK
                                 .equ EVSYS_CHANNEL9_SPI1_SCK_gc = (0x69<<0) ; SPI 1 SCK
                                 .equ EVSYS_CHANNEL9_TCA0_OVF_LUNF_gc = (0x80<<0) ; Timer/Counter A0 overflow / low byte timer underflow
                                 .equ EVSYS_CHANNEL9_TCA0_HUNF_gc = (0x81<<0) ; Timer/Counter A0 high byte timer underflow
                                 .equ EVSYS_CHANNEL9_TCA0_CMP0_LCMP0_gc = (0x84<<0) ; Timer/Counter A0 compare 0 / low byte timer compare 0
                                 .equ EVSYS_CHANNEL9_TCA0_CMP1_LCMP1_gc = (0x85<<0) ; Timer/Counter A0 compare 1 / low byte timer compare 1
                                 .equ EVSYS_CHANNEL9_TCA0_CMP2_LCMP2_gc = (0x86<<0) ; Timer/Counter A0 compare 2 / low byte timer compare 2
                                 .equ EVSYS_CHANNEL9_TCA1_OVF_LUNF_gc = (0x88<<0) ; Timer/Counter A1 overflow / low byte timer underflow
                                 .equ EVSYS_CHANNEL9_TCA1_HUNF_gc = (0x89<<0) ; Timer/Counter A1 high byte timer underflow
                                 .equ EVSYS_CHANNEL9_TCA1_CMP0_LCMP0_gc = (0x8C<<0) ; Timer/Counter A1 compare 0 / low byte timer compare 0
                                 .equ EVSYS_CHANNEL9_TCA1_CMP1_LCMP1_gc = (0x8D<<0) ; Timer/Counter A1 compare 1 / low byte timer compare 1
                                 .equ EVSYS_CHANNEL9_TCA1_CMP2_LCMP2_gc = (0x8E<<0) ; Timer/Counter A1 compare 2 / low byte timer compare 2
                                 .equ EVSYS_CHANNEL9_TCB0_CAPT_gc = (0xA0<<0) ; Timer/Counter B0 capture
                                 .equ EVSYS_CHANNEL9_TCB0_OVF_gc = (0xA1<<0) ; Timer/Counter B0 overflow
                                 .equ EVSYS_CHANNEL9_TCB1_CAPT_gc = (0xA2<<0) ; Timer/Counter B1 capture
                                 .equ EVSYS_CHANNEL9_TCB1_OVF_gc = (0xA3<<0) ; Timer/Counter B1 overflow
                                 .equ EVSYS_CHANNEL9_TCB2_CAPT_gc = (0xA4<<0) ; Timer/Counter B2 capture
                                 .equ EVSYS_CHANNEL9_TCB2_OVF_gc = (0xA5<<0) ; Timer/Counter B2 overflow
                                 .equ EVSYS_CHANNEL9_TCB3_CAPT_gc = (0xA6<<0) ; Timer/Counter B3 capture
                                 .equ EVSYS_CHANNEL9_TCB3_OVF_gc = (0xA7<<0) ; Timer/Counter B3 overflow
                                 .equ EVSYS_CHANNEL9_TCB4_CAPT_gc = (0xA8<<0) ; Timer/Counter B4 capture
                                 .equ EVSYS_CHANNEL9_TCB4_OVF_gc = (0xA9<<0) ; Timer/Counter B4 overflow
                                 .equ EVSYS_CHANNEL9_TCD0_CMPBCLR_gc = (0xB0<<0) ; Timer/Counter D0 event 0
                                 .equ EVSYS_CHANNEL9_TCD0_CMPASET_gc = (0xB1<<0) ; Timer/Counter D0 event 1
                                 .equ EVSYS_CHANNEL9_TCD0_CMPBSET_gc = (0xB2<<0) ; Timer/Counter D0 event 2
                                 .equ EVSYS_CHANNEL9_TCD0_PROGEV_gc = (0xB3<<0) ; Timer/Counter D0 event 3
                                 
                                 ; Software event on channel select select
                                 .equ EVSYS_SWEVENTA_CH0_gc = (0x01<<0)   ; Software event on channel 0
                                 .equ EVSYS_SWEVENTA_CH1_gc = (0x02<<0)   ; Software event on channel 1
                                 .equ EVSYS_SWEVENTA_CH2_gc = (0x04<<0)   ; Software event on channel 2
                                 .equ EVSYS_SWEVENTA_CH3_gc = (0x08<<0)   ; Software event on channel 3
                                 .equ EVSYS_SWEVENTA_CH4_gc = (0x10<<0)   ; Software event on channel 4
                                 .equ EVSYS_SWEVENTA_CH5_gc = (0x20<<0)   ; Software event on channel 5
                                 .equ EVSYS_SWEVENTA_CH6_gc = (0x40<<0)   ; Software event on channel 6
                                 .equ EVSYS_SWEVENTA_CH7_gc = (0x80<<0)   ; Software event on channel 7
                                 
                                 ; Software event on channel select select
                                 .equ EVSYS_SWEVENTB_CH8_gc = (0x00<<0)   ; Software event on channel 8
                                 .equ EVSYS_SWEVENTB_CH9_gc = (0x01<<0)   ; Software event on channel 9
                                 
                                 ; User channel select select
                                 .equ EVSYS_USER_OFF_gc = (0x00<<0)       ; Off
                                 .equ EVSYS_USER_CHANNEL0_gc = (0x01<<0)  ; Connect user to event channel 0
                                 .equ EVSYS_USER_CHANNEL1_gc = (0x02<<0)  ; Connect user to event channel 1
                                 .equ EVSYS_USER_CHANNEL2_gc = (0x03<<0)  ; Connect user to event channel 2
                                 .equ EVSYS_USER_CHANNEL3_gc = (0x04<<0)  ; Connect user to event channel 3
                                 .equ EVSYS_USER_CHANNEL4_gc = (0x05<<0)  ; Connect user to event channel 4
                                 .equ EVSYS_USER_CHANNEL5_gc = (0x06<<0)  ; Connect user to event channel 5
                                 .equ EVSYS_USER_CHANNEL6_gc = (0x07<<0)  ; Connect user to event channel 6
                                 .equ EVSYS_USER_CHANNEL7_gc = (0x08<<0)  ; Connect user to event channel 7
                                 .equ EVSYS_USER_CHANNEL8_gc = (0x09<<0)  ; Connect user to event channel 8
                                 .equ EVSYS_USER_CHANNEL9_gc = (0x0A<<0)  ; Connect user to event channel 9
                                 
                                 
                                 ;*************************************************************************
                                 ;** FUSE - Fuses
                                 ;*************************************************************************
                                 
                                 ; FUSE_BODCFG masks
                                 .equ FUSE_ACTIVE_gm = 0x0C               ; BOD Operation in Active Mode group mask
                                 .equ FUSE_ACTIVE_gp = 2                  ; BOD Operation in Active Mode group position
                                 .equ FUSE_ACTIVE0_bm = (1<<2)            ; BOD Operation in Active Mode bit 0 mask
                                 .equ FUSE_ACTIVE0_bp = 2                 ; BOD Operation in Active Mode bit 0 position
                                 .equ FUSE_ACTIVE1_bm = (1<<3)            ; BOD Operation in Active Mode bit 1 mask
                                 .equ FUSE_ACTIVE1_bp = 3                 ; BOD Operation in Active Mode bit 1 position
                                 .equ FUSE_LVL_gm = 0xE0                  ; BOD Level group mask
                                 .equ FUSE_LVL_gp = 5                     ; BOD Level group position
                                 .equ FUSE_LVL0_bm = (1<<5)               ; BOD Level bit 0 mask
                                 .equ FUSE_LVL0_bp = 5                    ; BOD Level bit 0 position
                                 .equ FUSE_LVL1_bm = (1<<6)               ; BOD Level bit 1 mask
                                 .equ FUSE_LVL1_bp = 6                    ; BOD Level bit 1 position
                                 .equ FUSE_LVL2_bm = (1<<7)               ; BOD Level bit 2 mask
                                 .equ FUSE_LVL2_bp = 7                    ; BOD Level bit 2 position
                                 .equ FUSE_SAMPFREQ_bm = 0x10             ; BOD Sample Frequency bit mask
                                 .equ FUSE_SAMPFREQ_bp = 4                ; BOD Sample Frequency bit position
                                 .equ FUSE_SLEEP_gm = 0x03                ; BOD Operation in Sleep Mode group mask
                                 .equ FUSE_SLEEP_gp = 0                   ; BOD Operation in Sleep Mode group position
                                 .equ FUSE_SLEEP0_bm = (1<<0)             ; BOD Operation in Sleep Mode bit 0 mask
                                 .equ FUSE_SLEEP0_bp = 0                  ; BOD Operation in Sleep Mode bit 0 position
                                 .equ FUSE_SLEEP1_bm = (1<<1)             ; BOD Operation in Sleep Mode bit 1 mask
                                 .equ FUSE_SLEEP1_bp = 1                  ; BOD Operation in Sleep Mode bit 1 position
                                 
                                 ; FUSE_OSCCFG masks
                                 .equ FUSE_CLKSEL_gm = 0x07               ; Frequency Select group mask
                                 .equ FUSE_CLKSEL_gp = 0                  ; Frequency Select group position
                                 .equ FUSE_CLKSEL0_bm = (1<<0)            ; Frequency Select bit 0 mask
                                 .equ FUSE_CLKSEL0_bp = 0                 ; Frequency Select bit 0 position
                                 .equ FUSE_CLKSEL1_bm = (1<<1)            ; Frequency Select bit 1 mask
                                 .equ FUSE_CLKSEL1_bp = 1                 ; Frequency Select bit 1 position
                                 .equ FUSE_CLKSEL2_bm = (1<<2)            ; Frequency Select bit 2 mask
                                 .equ FUSE_CLKSEL2_bp = 2                 ; Frequency Select bit 2 position
                                 
                                 ; FUSE_SYSCFG0 masks
                                 .equ FUSE_CRCSEL_bm = 0x20               ; CRC Select bit mask
                                 .equ FUSE_CRCSEL_bp = 5                  ; CRC Select bit position
                                 .equ FUSE_CRCSRC_gm = 0xC0               ; CRC Source group mask
                                 .equ FUSE_CRCSRC_gp = 6                  ; CRC Source group position
                                 .equ FUSE_CRCSRC0_bm = (1<<6)            ; CRC Source bit 0 mask
                                 .equ FUSE_CRCSRC0_bp = 6                 ; CRC Source bit 0 position
                                 .equ FUSE_CRCSRC1_bm = (1<<7)            ; CRC Source bit 1 mask
                                 .equ FUSE_CRCSRC1_bp = 7                 ; CRC Source bit 1 position
                                 .equ FUSE_EESAVE_bm = 0x01               ; EEPROM Save bit mask
                                 .equ FUSE_EESAVE_bp = 0                  ; EEPROM Save bit position
                                 .equ FUSE_RSTPINCFG_gm = 0x0C            ; Reset Pin Configuration group mask
                                 .equ FUSE_RSTPINCFG_gp = 2               ; Reset Pin Configuration group position
                                 .equ FUSE_RSTPINCFG0_bm = (1<<2)         ; Reset Pin Configuration bit 0 mask
                                 .equ FUSE_RSTPINCFG0_bp = 2              ; Reset Pin Configuration bit 0 position
                                 .equ FUSE_RSTPINCFG1_bm = (1<<3)         ; Reset Pin Configuration bit 1 mask
                                 .equ FUSE_RSTPINCFG1_bp = 3              ; Reset Pin Configuration bit 1 position
                                 
                                 ; FUSE_SYSCFG1 masks
                                 .equ FUSE_MVSYSCFG_gm = 0x18             ; MVIO System Configuration group mask
                                 .equ FUSE_MVSYSCFG_gp = 3                ; MVIO System Configuration group position
                                 .equ FUSE_MVSYSCFG0_bm = (1<<3)          ; MVIO System Configuration bit 0 mask
                                 .equ FUSE_MVSYSCFG0_bp = 3               ; MVIO System Configuration bit 0 position
                                 .equ FUSE_MVSYSCFG1_bm = (1<<4)          ; MVIO System Configuration bit 1 mask
                                 .equ FUSE_MVSYSCFG1_bp = 4               ; MVIO System Configuration bit 1 position
                                 .equ FUSE_SUT_gm = 0x07                  ; Startup Time group mask
                                 .equ FUSE_SUT_gp = 0                     ; Startup Time group position
                                 .equ FUSE_SUT0_bm = (1<<0)               ; Startup Time bit 0 mask
                                 .equ FUSE_SUT0_bp = 0                    ; Startup Time bit 0 position
                                 .equ FUSE_SUT1_bm = (1<<1)               ; Startup Time bit 1 mask
                                 .equ FUSE_SUT1_bp = 1                    ; Startup Time bit 1 position
                                 .equ FUSE_SUT2_bm = (1<<2)               ; Startup Time bit 2 mask
                                 .equ FUSE_SUT2_bp = 2                    ; Startup Time bit 2 position
                                 
                                 ; FUSE_WDTCFG masks
                                 .equ FUSE_PERIOD_gm = 0x0F               ; Watchdog Timeout Period group mask
                                 .equ FUSE_PERIOD_gp = 0                  ; Watchdog Timeout Period group position
                                 .equ FUSE_PERIOD0_bm = (1<<0)            ; Watchdog Timeout Period bit 0 mask
                                 .equ FUSE_PERIOD0_bp = 0                 ; Watchdog Timeout Period bit 0 position
                                 .equ FUSE_PERIOD1_bm = (1<<1)            ; Watchdog Timeout Period bit 1 mask
                                 .equ FUSE_PERIOD1_bp = 1                 ; Watchdog Timeout Period bit 1 position
                                 .equ FUSE_PERIOD2_bm = (1<<2)            ; Watchdog Timeout Period bit 2 mask
                                 .equ FUSE_PERIOD2_bp = 2                 ; Watchdog Timeout Period bit 2 position
                                 .equ FUSE_PERIOD3_bm = (1<<3)            ; Watchdog Timeout Period bit 3 mask
                                 .equ FUSE_PERIOD3_bp = 3                 ; Watchdog Timeout Period bit 3 position
                                 .equ FUSE_WINDOW_gm = 0xF0               ; Watchdog Window Timeout Period group mask
                                 .equ FUSE_WINDOW_gp = 4                  ; Watchdog Window Timeout Period group position
                                 .equ FUSE_WINDOW0_bm = (1<<4)            ; Watchdog Window Timeout Period bit 0 mask
                                 .equ FUSE_WINDOW0_bp = 4                 ; Watchdog Window Timeout Period bit 0 position
                                 .equ FUSE_WINDOW1_bm = (1<<5)            ; Watchdog Window Timeout Period bit 1 mask
                                 .equ FUSE_WINDOW1_bp = 5                 ; Watchdog Window Timeout Period bit 1 position
                                 .equ FUSE_WINDOW2_bm = (1<<6)            ; Watchdog Window Timeout Period bit 2 mask
                                 .equ FUSE_WINDOW2_bp = 6                 ; Watchdog Window Timeout Period bit 2 position
                                 .equ FUSE_WINDOW3_bm = (1<<7)            ; Watchdog Window Timeout Period bit 3 mask
                                 .equ FUSE_WINDOW3_bp = 7                 ; Watchdog Window Timeout Period bit 3 position
                                 
                                 ; BOD Operation in Active Mode select
                                 .equ FUSE_ACTIVE_DISABLE_gc = (0x00<<2)  ; BOD disabled
                                 .equ FUSE_ACTIVE_ENABLE_gc = (0x01<<2)   ; BOD enabled in continuous mode
                                 .equ FUSE_ACTIVE_SAMPLE_gc = (0x02<<2)   ; BOD enabled in sampled mode
                                 .equ FUSE_ACTIVE_ENABLEWAIT_gc = (0x03<<2) ; BOD enabled in continuous mode. Execution is halted at wake-up until BOD is running.
                                 
                                 ; BOD Level select
                                 .equ FUSE_LVL_BODLEVEL0_gc = (0x00<<5)   ; 1.9V
                                 .equ FUSE_LVL_BODLEVEL1_gc = (0x01<<5)   ; 2.45V
                                 .equ FUSE_LVL_BODLEVEL2_gc = (0x02<<5)   ; 2.7V
                                 .equ FUSE_LVL_BODLEVEL3_gc = (0x03<<5)   ; 2.85V
                                 
                                 ; BOD Sample Frequency select
                                 .equ FUSE_SAMPFREQ_128Hz_gc = (0x00<<4)  ; Sample frequency is 128 Hz
                                 .equ FUSE_SAMPFREQ_32Hz_gc = (0x01<<4)   ; Sample frequency is 32 Hz
                                 
                                 ; BOD Operation in Sleep Mode select
                                 .equ FUSE_SLEEP_DISABLE_gc = (0x00<<0)   ; BOD disabled
                                 .equ FUSE_SLEEP_ENABLE_gc = (0x01<<0)    ; BOD enabled in continuous mode
                                 .equ FUSE_SLEEP_SAMPLE_gc = (0x02<<0)    ; BOD enabled in sampled mode
                                 
                                 ; Frequency Select select
                                 .equ FUSE_CLKSEL_OSCHF_gc = (0x00<<0)    ; 1-32MHz internal oscillator
                                 .equ FUSE_CLKSEL_OSC32K_gc = (0x01<<0)   ; 32.768kHz internal oscillator
                                 
                                 ; CRC Select select
                                 .equ FUSE_CRCSEL_CRC16_gc = (0x00<<5)    ; Enable CRC16
                                 .equ FUSE_CRCSEL_CRC32_gc = (0x01<<5)    ; Enable CRC32
                                 
                                 ; CRC Source select
                                 .equ FUSE_CRCSRC_FLASH_gc = (0x00<<6)    ; CRC of full Flash (boot, application code and application data)
                                 .equ FUSE_CRCSRC_BOOT_gc = (0x01<<6)     ; CRC of boot section
                                 .equ FUSE_CRCSRC_BOOTAPP_gc = (0x02<<6)  ; CRC of application code and boot sections
                                 .equ FUSE_CRCSRC_NOCRC_gc = (0x03<<6)    ; No CRC
                                 
                                 ; Reset Pin Configuration select
                                 .equ FUSE_RSTPINCFG_GPIO_gc = (0x00<<2)  ; GPIO mode
                                 .equ FUSE_RSTPINCFG_RST_gc = (0x02<<2)   ; Reset mode
                                 
                                 ; MVIO System Configuration select
                                 .equ FUSE_MVSYSCFG_DUAL_gc = (0x01<<3)   ; Device used in a dual supply configuration
                                 .equ FUSE_MVSYSCFG_SINGLE_gc = (0x02<<3) ; Device used in a single supply configuration
                                 
                                 ; Startup Time select
                                 .equ FUSE_SUT_0MS_gc = (0x00<<0)         ; 0 ms
                                 .equ FUSE_SUT_1MS_gc = (0x01<<0)         ; 1 ms
                                 .equ FUSE_SUT_2MS_gc = (0x02<<0)         ; 2 ms
                                 .equ FUSE_SUT_4MS_gc = (0x03<<0)         ; 4 ms
                                 .equ FUSE_SUT_8MS_gc = (0x04<<0)         ; 8 ms
                                 .equ FUSE_SUT_16MS_gc = (0x05<<0)        ; 16 ms
                                 .equ FUSE_SUT_32MS_gc = (0x06<<0)        ; 32 ms
                                 .equ FUSE_SUT_64MS_gc = (0x07<<0)        ; 64 ms
                                 
                                 ; Watchdog Timeout Period select
                                 .equ FUSE_PERIOD_OFF_gc = (0x00<<0)      ; Watch-Dog timer Off
                                 .equ FUSE_PERIOD_8CLK_gc = (0x01<<0)     ; 8 cycles (8ms)
                                 .equ FUSE_PERIOD_16CLK_gc = (0x02<<0)    ; 16 cycles (16ms)
                                 .equ FUSE_PERIOD_32CLK_gc = (0x03<<0)    ; 32 cycles (32ms)
                                 .equ FUSE_PERIOD_64CLK_gc = (0x04<<0)    ; 64 cycles (64ms)
                                 .equ FUSE_PERIOD_128CLK_gc = (0x05<<0)   ; 128 cycles (0.128s)
                                 .equ FUSE_PERIOD_256CLK_gc = (0x06<<0)   ; 256 cycles (0.256s)
                                 .equ FUSE_PERIOD_512CLK_gc = (0x07<<0)   ; 512 cycles (0.512s)
                                 .equ FUSE_PERIOD_1KCLK_gc = (0x08<<0)    ; 1K cycles (1.0s)
                                 .equ FUSE_PERIOD_2KCLK_gc = (0x09<<0)    ; 2K cycles (2.0s)
                                 .equ FUSE_PERIOD_4KCLK_gc = (0x0A<<0)    ; 4K cycles (4.0s)
                                 .equ FUSE_PERIOD_8KCLK_gc = (0x0B<<0)    ; 8K cycles (8.0s)
                                 
                                 ; Watchdog Window Timeout Period select
                                 .equ FUSE_WINDOW_OFF_gc = (0x00<<4)      ; Window mode off
                                 .equ FUSE_WINDOW_8CLK_gc = (0x01<<4)     ; 8 cycles (8ms)
                                 .equ FUSE_WINDOW_16CLK_gc = (0x02<<4)    ; 16 cycles (16ms)
                                 .equ FUSE_WINDOW_32CLK_gc = (0x03<<4)    ; 32 cycles (32ms)
                                 .equ FUSE_WINDOW_64CLK_gc = (0x04<<4)    ; 64 cycles (64ms)
                                 .equ FUSE_WINDOW_128CLK_gc = (0x05<<4)   ; 128 cycles (0.128s)
                                 .equ FUSE_WINDOW_256CLK_gc = (0x06<<4)   ; 256 cycles (0.256s)
                                 .equ FUSE_WINDOW_512CLK_gc = (0x07<<4)   ; 512 cycles (0.512s)
                                 .equ FUSE_WINDOW_1KCLK_gc = (0x08<<4)    ; 1K cycles (1.0s)
                                 .equ FUSE_WINDOW_2KCLK_gc = (0x09<<4)    ; 2K cycles (2.0s)
                                 .equ FUSE_WINDOW_4KCLK_gc = (0x0A<<4)    ; 4K cycles (4.0s)
                                 .equ FUSE_WINDOW_8KCLK_gc = (0x0B<<4)    ; 8K cycles (8.0s)
                                 
                                 
                                 ;*************************************************************************
                                 ;** GPR - General Purpose Registers
                                 ;*************************************************************************
                                 
                                 
                                 ;*************************************************************************
                                 ;** LOCK - Lockbits
                                 ;*************************************************************************
                                 
                                 ; LOCK_KEY masks
                                 .equ LOCK_KEY_gm = 0xFFFFFFFF            ; Lock Key group mask
                                 .equ LOCK_KEY_gp = 0                     ; Lock Key group position
                                 .equ LOCK_KEY0_bm = (1<<0)               ; Lock Key bit 0 mask
                                 .equ LOCK_KEY0_bp = 0                    ; Lock Key bit 0 position
                                 .equ LOCK_KEY1_bm = (1<<1)               ; Lock Key bit 1 mask
                                 .equ LOCK_KEY1_bp = 1                    ; Lock Key bit 1 position
                                 .equ LOCK_KEY2_bm = (1<<2)               ; Lock Key bit 2 mask
                                 .equ LOCK_KEY2_bp = 2                    ; Lock Key bit 2 position
                                 .equ LOCK_KEY3_bm = (1<<3)               ; Lock Key bit 3 mask
                                 .equ LOCK_KEY3_bp = 3                    ; Lock Key bit 3 position
                                 .equ LOCK_KEY4_bm = (1<<4)               ; Lock Key bit 4 mask
                                 .equ LOCK_KEY4_bp = 4                    ; Lock Key bit 4 position
                                 .equ LOCK_KEY5_bm = (1<<5)               ; Lock Key bit 5 mask
                                 .equ LOCK_KEY5_bp = 5                    ; Lock Key bit 5 position
                                 .equ LOCK_KEY6_bm = (1<<6)               ; Lock Key bit 6 mask
                                 .equ LOCK_KEY6_bp = 6                    ; Lock Key bit 6 position
                                 .equ LOCK_KEY7_bm = (1<<7)               ; Lock Key bit 7 mask
                                 .equ LOCK_KEY7_bp = 7                    ; Lock Key bit 7 position
                                 .equ LOCK_KEY8_bm = (1<<8)               ; Lock Key bit 8 mask
                                 .equ LOCK_KEY8_bp = 8                    ; Lock Key bit 8 position
                                 .equ LOCK_KEY9_bm = (1<<9)               ; Lock Key bit 9 mask
                                 .equ LOCK_KEY9_bp = 9                    ; Lock Key bit 9 position
                                 .equ LOCK_KEY10_bm = (1<<10)             ; Lock Key bit 10 mask
                                 .equ LOCK_KEY10_bp = 10                  ; Lock Key bit 10 position
                                 .equ LOCK_KEY11_bm = (1<<11)             ; Lock Key bit 11 mask
                                 .equ LOCK_KEY11_bp = 11                  ; Lock Key bit 11 position
                                 .equ LOCK_KEY12_bm = (1<<12)             ; Lock Key bit 12 mask
                                 .equ LOCK_KEY12_bp = 12                  ; Lock Key bit 12 position
                                 .equ LOCK_KEY13_bm = (1<<13)             ; Lock Key bit 13 mask
                                 .equ LOCK_KEY13_bp = 13                  ; Lock Key bit 13 position
                                 .equ LOCK_KEY14_bm = (1<<14)             ; Lock Key bit 14 mask
                                 .equ LOCK_KEY14_bp = 14                  ; Lock Key bit 14 position
                                 .equ LOCK_KEY15_bm = (1<<15)             ; Lock Key bit 15 mask
                                 .equ LOCK_KEY15_bp = 15                  ; Lock Key bit 15 position
                                 .equ LOCK_KEY16_bm = (1<<16)             ; Lock Key bit 16 mask
                                 .equ LOCK_KEY16_bp = 16                  ; Lock Key bit 16 position
                                 .equ LOCK_KEY17_bm = (1<<17)             ; Lock Key bit 17 mask
                                 .equ LOCK_KEY17_bp = 17                  ; Lock Key bit 17 position
                                 .equ LOCK_KEY18_bm = (1<<18)             ; Lock Key bit 18 mask
                                 .equ LOCK_KEY18_bp = 18                  ; Lock Key bit 18 position
                                 .equ LOCK_KEY19_bm = (1<<19)             ; Lock Key bit 19 mask
                                 .equ LOCK_KEY19_bp = 19                  ; Lock Key bit 19 position
                                 .equ LOCK_KEY20_bm = (1<<20)             ; Lock Key bit 20 mask
                                 .equ LOCK_KEY20_bp = 20                  ; Lock Key bit 20 position
                                 .equ LOCK_KEY21_bm = (1<<21)             ; Lock Key bit 21 mask
                                 .equ LOCK_KEY21_bp = 21                  ; Lock Key bit 21 position
                                 .equ LOCK_KEY22_bm = (1<<22)             ; Lock Key bit 22 mask
                                 .equ LOCK_KEY22_bp = 22                  ; Lock Key bit 22 position
                                 .equ LOCK_KEY23_bm = (1<<23)             ; Lock Key bit 23 mask
                                 .equ LOCK_KEY23_bp = 23                  ; Lock Key bit 23 position
                                 .equ LOCK_KEY24_bm = (1<<24)             ; Lock Key bit 24 mask
                                 .equ LOCK_KEY24_bp = 24                  ; Lock Key bit 24 position
                                 .equ LOCK_KEY25_bm = (1<<25)             ; Lock Key bit 25 mask
                                 .equ LOCK_KEY25_bp = 25                  ; Lock Key bit 25 position
                                 .equ LOCK_KEY26_bm = (1<<26)             ; Lock Key bit 26 mask
                                 .equ LOCK_KEY26_bp = 26                  ; Lock Key bit 26 position
                                 .equ LOCK_KEY27_bm = (1<<27)             ; Lock Key bit 27 mask
                                 .equ LOCK_KEY27_bp = 27                  ; Lock Key bit 27 position
                                 .equ LOCK_KEY28_bm = (1<<28)             ; Lock Key bit 28 mask
                                 .equ LOCK_KEY28_bp = 28                  ; Lock Key bit 28 position
                                 .equ LOCK_KEY29_bm = (1<<29)             ; Lock Key bit 29 mask
                                 .equ LOCK_KEY29_bp = 29                  ; Lock Key bit 29 position
                                 .equ LOCK_KEY30_bm = (1<<30)             ; Lock Key bit 30 mask
                                 .equ LOCK_KEY30_bp = 30                  ; Lock Key bit 30 position
                                 .equ LOCK_KEY31_bm = (1<<31)             ; Lock Key bit 31 mask
                                 .equ LOCK_KEY31_bp = 31                  ; Lock Key bit 31 position
                                 
                                 ; Lock Key select
                                 .equ LOCK_KEY_NOLOCK_gc = (0x5CC5C55C<<0) ; No locks
                                 .equ LOCK_KEY_RWLOCK_gc = (0xA33A3AA3<<0) ; Read and write lock
                                 
                                 
                                 ;*************************************************************************
                                 ;** MVIO - Multi-Voltage I/O
                                 ;*************************************************************************
                                 
                                 ; MVIO_INTCTRL masks
                                 .equ MVIO_VDDIO2IE_bm = 0x01             ; VDDIO2 Interrupt Enable bit mask
                                 .equ MVIO_VDDIO2IE_bp = 0                ; VDDIO2 Interrupt Enable bit position
                                 
                                 ; MVIO_INTFLAGS masks
                                 .equ MVIO_VDDIO2IF_bm = 0x01             ; VDDIO2 Interrupt Flag bit mask
                                 .equ MVIO_VDDIO2IF_bp = 0                ; VDDIO2 Interrupt Flag bit position
                                 
                                 ; MVIO_STATUS masks
                                 .equ MVIO_VDDIO2S_bm = 0x01              ; VDDIO2 Status bit mask
                                 .equ MVIO_VDDIO2S_bp = 0                 ; VDDIO2 Status bit position
                                 
                                 
                                 ;*************************************************************************
                                 ;** NVMCTRL - Non-volatile Memory Controller
                                 ;*************************************************************************
                                 
                                 ; NVMCTRL_CTRLA masks
                                 .equ NVMCTRL_CMD_gm = 0x7F               ; Command group mask
                                 .equ NVMCTRL_CMD_gp = 0                  ; Command group position
                                 .equ NVMCTRL_CMD0_bm = (1<<0)            ; Command bit 0 mask
                                 .equ NVMCTRL_CMD0_bp = 0                 ; Command bit 0 position
                                 .equ NVMCTRL_CMD1_bm = (1<<1)            ; Command bit 1 mask
                                 .equ NVMCTRL_CMD1_bp = 1                 ; Command bit 1 position
                                 .equ NVMCTRL_CMD2_bm = (1<<2)            ; Command bit 2 mask
                                 .equ NVMCTRL_CMD2_bp = 2                 ; Command bit 2 position
                                 .equ NVMCTRL_CMD3_bm = (1<<3)            ; Command bit 3 mask
                                 .equ NVMCTRL_CMD3_bp = 3                 ; Command bit 3 position
                                 .equ NVMCTRL_CMD4_bm = (1<<4)            ; Command bit 4 mask
                                 .equ NVMCTRL_CMD4_bp = 4                 ; Command bit 4 position
                                 .equ NVMCTRL_CMD5_bm = (1<<5)            ; Command bit 5 mask
                                 .equ NVMCTRL_CMD5_bp = 5                 ; Command bit 5 position
                                 .equ NVMCTRL_CMD6_bm = (1<<6)            ; Command bit 6 mask
                                 .equ NVMCTRL_CMD6_bp = 6                 ; Command bit 6 position
                                 
                                 ; NVMCTRL_CTRLB masks
                                 .equ NVMCTRL_APPCODEWP_bm = 0x01         ; Application Code Write Protect bit mask
                                 .equ NVMCTRL_APPCODEWP_bp = 0            ; Application Code Write Protect bit position
                                 .equ NVMCTRL_APPDATAWP_bm = 0x04         ; Application Data Write Protect bit mask
                                 .equ NVMCTRL_APPDATAWP_bp = 2            ; Application Data Write Protect bit position
                                 .equ NVMCTRL_BOOTRP_bm = 0x02            ; Boot Read Protect bit mask
                                 .equ NVMCTRL_BOOTRP_bp = 1               ; Boot Read Protect bit position
                                 .equ NVMCTRL_FLMAP_gm = 0x30             ; Flash Mapping in Data space group mask
                                 .equ NVMCTRL_FLMAP_gp = 4                ; Flash Mapping in Data space group position
                                 .equ NVMCTRL_FLMAP0_bm = (1<<4)          ; Flash Mapping in Data space bit 0 mask
                                 .equ NVMCTRL_FLMAP0_bp = 4               ; Flash Mapping in Data space bit 0 position
                                 .equ NVMCTRL_FLMAP1_bm = (1<<5)          ; Flash Mapping in Data space bit 1 mask
                                 .equ NVMCTRL_FLMAP1_bp = 5               ; Flash Mapping in Data space bit 1 position
                                 .equ NVMCTRL_FLMAPLOCK_bm = 0x80         ; Flash Mapping Lock bit mask
                                 .equ NVMCTRL_FLMAPLOCK_bp = 7            ; Flash Mapping Lock bit position
                                 
                                 ; NVMCTRL_INTCTRL masks
                                 .equ NVMCTRL_EEREADY_bm = 0x01           ; EEPROM Ready bit mask
                                 .equ NVMCTRL_EEREADY_bp = 0              ; EEPROM Ready bit position
                                 
                                 ; NVMCTRL_INTFLAGS masks
                                 ; Masks for NVMCTRL_EEREADY already defined
                                 
                                 ; NVMCTRL_STATUS masks
                                 .equ NVMCTRL_EEBUSY_bm = 0x02            ; EEPROM busy bit mask
                                 .equ NVMCTRL_EEBUSY_bp = 1               ; EEPROM busy bit position
                                 .equ NVMCTRL_ERROR_gm = 0x70             ; Write error group mask
                                 .equ NVMCTRL_ERROR_gp = 4                ; Write error group position
                                 .equ NVMCTRL_ERROR0_bm = (1<<4)          ; Write error bit 0 mask
                                 .equ NVMCTRL_ERROR0_bp = 4               ; Write error bit 0 position
                                 .equ NVMCTRL_ERROR1_bm = (1<<5)          ; Write error bit 1 mask
                                 .equ NVMCTRL_ERROR1_bp = 5               ; Write error bit 1 position
                                 .equ NVMCTRL_ERROR2_bm = (1<<6)          ; Write error bit 2 mask
                                 .equ NVMCTRL_ERROR2_bp = 6               ; Write error bit 2 position
                                 .equ NVMCTRL_FBUSY_bm = 0x01             ; Flash busy bit mask
                                 .equ NVMCTRL_FBUSY_bp = 0                ; Flash busy bit position
                                 
                                 ; Command select
                                 .equ NVMCTRL_CMD_NONE_gc = (0x00<<0)     ; No Command
                                 .equ NVMCTRL_CMD_NOOP_gc = (0x01<<0)     ; No Operation
                                 .equ NVMCTRL_CMD_FLWR_gc = (0x02<<0)     ; Flash Write
                                 .equ NVMCTRL_CMD_FLPER_gc = (0x08<<0)    ; Flash Page Erase
                                 .equ NVMCTRL_CMD_FLMPER2_gc = (0x09<<0)  ; Flash Multi-Page Erase 2 pages
                                 .equ NVMCTRL_CMD_FLMPER4_gc = (0x0A<<0)  ; Flash Multi-Page Erase 4 pages
                                 .equ NVMCTRL_CMD_FLMPER8_gc = (0x0B<<0)  ; Flash Multi-Page Erase 8 pages
                                 .equ NVMCTRL_CMD_FLMPER16_gc = (0x0C<<0) ; Flash Multi-Page Erase 16 pages
                                 .equ NVMCTRL_CMD_FLMPER32_gc = (0x0D<<0) ; Flash Multi-Page Erase 32 pages
                                 .equ NVMCTRL_CMD_EEWR_gc = (0x12<<0)     ; EEPROM Write
                                 .equ NVMCTRL_CMD_EEERWR_gc = (0x13<<0)   ; EEPROM Erase and Write
                                 .equ NVMCTRL_CMD_EEBER_gc = (0x18<<0)    ; EEPROM Byte Erase
                                 .equ NVMCTRL_CMD_EEMBER2_gc = (0x19<<0)  ; EEPROM Multi-Byte Erase 2 bytes
                                 .equ NVMCTRL_CMD_EEMBER4_gc = (0x1A<<0)  ; EEPROM Multi-Byte Erase 4 bytes
                                 .equ NVMCTRL_CMD_EEMBER8_gc = (0x1B<<0)  ; EEPROM Multi-Byte Erase 8 bytes
                                 .equ NVMCTRL_CMD_EEMBER16_gc = (0x1C<<0) ; EEPROM Multi-Byte Erase 16 bytes
                                 .equ NVMCTRL_CMD_EEMBER32_gc = (0x1D<<0) ; EEPROM Multi-Byte Erase 32 bytes
                                 .equ NVMCTRL_CMD_CHER_gc = (0x20<<0)     ; Chip Erase Command
                                 .equ NVMCTRL_CMD_EECHER_gc = (0x30<<0)   ; EEPROM Erase Command
                                 
                                 ; Flash Mapping in Data space select
                                 .equ NVMCTRL_FLMAP_SECTION0_gc = (0x00<<4) ; Flash section 0
                                 .equ NVMCTRL_FLMAP_SECTION1_gc = (0x01<<4) ; Flash section 1
                                 .equ NVMCTRL_FLMAP_SECTION2_gc = (0x02<<4) ; Flash section 2
                                 .equ NVMCTRL_FLMAP_SECTION3_gc = (0x03<<4) ; Flash section 3
                                 
                                 ; Write error select
                                 .equ NVMCTRL_ERROR_NOERROR_gc = (0x00<<4) ; No Error
                                 .equ NVMCTRL_ERROR_ILLEGALCMD_gc = (0x01<<4) ; Write command not selected
                                 .equ NVMCTRL_ERROR_ILLEGALSADDR_gc = (0x02<<4) ; Write to section not allowed
                                 .equ NVMCTRL_ERROR_DOUBLESELECT_gc = (0x03<<4) ; Selecting new write command while write command already seleted
                                 .equ NVMCTRL_ERROR_ONGOINGPROG_gc = (0x04<<4) ; Starting a new programming operation before previous is completed
                                 
                                 
                                 ;*************************************************************************
                                 ;** OPAMP - Operational Amplifier System
                                 ;*************************************************************************
                                 
                                 ; OPAMP_CTRLA masks
                                 .equ OPAMP_ENABLE_bm = 0x01              ; Op Amp System Enable bit mask
                                 .equ OPAMP_ENABLE_bp = 0                 ; Op Amp System Enable bit position
                                 
                                 ; OPAMP_DBGCTRL masks
                                 .equ OPAMP_DBGRUN_bm = 0x01              ; Run in Debug Mode bit mask
                                 .equ OPAMP_DBGRUN_bp = 0                 ; Run in Debug Mode bit position
                                 
                                 ; OPAMP_OP0CAL masks
                                 .equ OPAMP_CAL_gm = 0xFF                 ; Calibration (for input offset voltage) group mask
                                 .equ OPAMP_CAL_gp = 0                    ; Calibration (for input offset voltage) group position
                                 .equ OPAMP_CAL0_bm = (1<<0)              ; Calibration (for input offset voltage) bit 0 mask
                                 .equ OPAMP_CAL0_bp = 0                   ; Calibration (for input offset voltage) bit 0 position
                                 .equ OPAMP_CAL1_bm = (1<<1)              ; Calibration (for input offset voltage) bit 1 mask
                                 .equ OPAMP_CAL1_bp = 1                   ; Calibration (for input offset voltage) bit 1 position
                                 .equ OPAMP_CAL2_bm = (1<<2)              ; Calibration (for input offset voltage) bit 2 mask
                                 .equ OPAMP_CAL2_bp = 2                   ; Calibration (for input offset voltage) bit 2 position
                                 .equ OPAMP_CAL3_bm = (1<<3)              ; Calibration (for input offset voltage) bit 3 mask
                                 .equ OPAMP_CAL3_bp = 3                   ; Calibration (for input offset voltage) bit 3 position
                                 .equ OPAMP_CAL4_bm = (1<<4)              ; Calibration (for input offset voltage) bit 4 mask
                                 .equ OPAMP_CAL4_bp = 4                   ; Calibration (for input offset voltage) bit 4 position
                                 .equ OPAMP_CAL5_bm = (1<<5)              ; Calibration (for input offset voltage) bit 5 mask
                                 .equ OPAMP_CAL5_bp = 5                   ; Calibration (for input offset voltage) bit 5 position
                                 .equ OPAMP_CAL6_bm = (1<<6)              ; Calibration (for input offset voltage) bit 6 mask
                                 .equ OPAMP_CAL6_bp = 6                   ; Calibration (for input offset voltage) bit 6 position
                                 .equ OPAMP_CAL7_bm = (1<<7)              ; Calibration (for input offset voltage) bit 7 mask
                                 .equ OPAMP_CAL7_bp = 7                   ; Calibration (for input offset voltage) bit 7 position
                                 
                                 ; OPAMP_OP0CTRLA masks
                                 .equ OPAMP_ALWAYSON_bm = 0x01            ; Always On bit mask
                                 .equ OPAMP_ALWAYSON_bp = 0               ; Always On bit position
                                 .equ OPAMP_EVENTEN_bm = 0x02             ; Enable Events bit mask
                                 .equ OPAMP_EVENTEN_bp = 1                ; Enable Events bit position
                                 .equ OPAMP_OUTMODE_gm = 0x0C             ; Output Mode group mask
                                 .equ OPAMP_OUTMODE_gp = 2                ; Output Mode group position
                                 .equ OPAMP_OUTMODE0_bm = (1<<2)          ; Output Mode bit 0 mask
                                 .equ OPAMP_OUTMODE0_bp = 2               ; Output Mode bit 0 position
                                 .equ OPAMP_OUTMODE1_bm = (1<<3)          ; Output Mode bit 1 mask
                                 .equ OPAMP_OUTMODE1_bp = 3               ; Output Mode bit 1 position
                                 .equ OPAMP_RUNSTBY_bm = 0x80             ; Run in Standby Mode bit mask
                                 .equ OPAMP_RUNSTBY_bp = 7                ; Run in Standby Mode bit position
                                 
                                 ; OPAMP_OP0INMUX masks
                                 .equ OPAMP_MUXNEG_gm = 0x70              ; Negative Input Multiplexer group mask
                                 .equ OPAMP_MUXNEG_gp = 4                 ; Negative Input Multiplexer group position
                                 .equ OPAMP_MUXNEG0_bm = (1<<4)           ; Negative Input Multiplexer bit 0 mask
                                 .equ OPAMP_MUXNEG0_bp = 4                ; Negative Input Multiplexer bit 0 position
                                 .equ OPAMP_MUXNEG1_bm = (1<<5)           ; Negative Input Multiplexer bit 1 mask
                                 .equ OPAMP_MUXNEG1_bp = 5                ; Negative Input Multiplexer bit 1 position
                                 .equ OPAMP_MUXNEG2_bm = (1<<6)           ; Negative Input Multiplexer bit 2 mask
                                 .equ OPAMP_MUXNEG2_bp = 6                ; Negative Input Multiplexer bit 2 position
                                 .equ OPAMP_MUXPOS_gm = 0x07              ; Positive Input Multiplexer group mask
                                 .equ OPAMP_MUXPOS_gp = 0                 ; Positive Input Multiplexer group position
                                 .equ OPAMP_MUXPOS0_bm = (1<<0)           ; Positive Input Multiplexer bit 0 mask
                                 .equ OPAMP_MUXPOS0_bp = 0                ; Positive Input Multiplexer bit 0 position
                                 .equ OPAMP_MUXPOS1_bm = (1<<1)           ; Positive Input Multiplexer bit 1 mask
                                 .equ OPAMP_MUXPOS1_bp = 1                ; Positive Input Multiplexer bit 1 position
                                 .equ OPAMP_MUXPOS2_bm = (1<<2)           ; Positive Input Multiplexer bit 2 mask
                                 .equ OPAMP_MUXPOS2_bp = 2                ; Positive Input Multiplexer bit 2 position
                                 
                                 ; OPAMP_OP0RESMUX masks
                                 .equ OPAMP_MUXBOT_gm = 0x1C              ; Multiplexer Bottom group mask
                                 .equ OPAMP_MUXBOT_gp = 2                 ; Multiplexer Bottom group position
                                 .equ OPAMP_MUXBOT0_bm = (1<<2)           ; Multiplexer Bottom bit 0 mask
                                 .equ OPAMP_MUXBOT0_bp = 2                ; Multiplexer Bottom bit 0 position
                                 .equ OPAMP_MUXBOT1_bm = (1<<3)           ; Multiplexer Bottom bit 1 mask
                                 .equ OPAMP_MUXBOT1_bp = 3                ; Multiplexer Bottom bit 1 position
                                 .equ OPAMP_MUXBOT2_bm = (1<<4)           ; Multiplexer Bottom bit 2 mask
                                 .equ OPAMP_MUXBOT2_bp = 4                ; Multiplexer Bottom bit 2 position
                                 .equ OPAMP_MUXTOP_gm = 0x03              ; Multiplexer Top group mask
                                 .equ OPAMP_MUXTOP_gp = 0                 ; Multiplexer Top group position
                                 .equ OPAMP_MUXTOP0_bm = (1<<0)           ; Multiplexer Top bit 0 mask
                                 .equ OPAMP_MUXTOP0_bp = 0                ; Multiplexer Top bit 0 position
                                 .equ OPAMP_MUXTOP1_bm = (1<<1)           ; Multiplexer Top bit 1 mask
                                 .equ OPAMP_MUXTOP1_bp = 1                ; Multiplexer Top bit 1 position
                                 .equ OPAMP_MUXWIP_gm = 0xE0              ; Multiplexer Wiper selector group mask
                                 .equ OPAMP_MUXWIP_gp = 5                 ; Multiplexer Wiper selector group position
                                 .equ OPAMP_MUXWIP0_bm = (1<<5)           ; Multiplexer Wiper selector bit 0 mask
                                 .equ OPAMP_MUXWIP0_bp = 5                ; Multiplexer Wiper selector bit 0 position
                                 .equ OPAMP_MUXWIP1_bm = (1<<6)           ; Multiplexer Wiper selector bit 1 mask
                                 .equ OPAMP_MUXWIP1_bp = 6                ; Multiplexer Wiper selector bit 1 position
                                 .equ OPAMP_MUXWIP2_bm = (1<<7)           ; Multiplexer Wiper selector bit 2 mask
                                 .equ OPAMP_MUXWIP2_bp = 7                ; Multiplexer Wiper selector bit 2 position
                                 
                                 ; OPAMP_OP0SETTLE masks
                                 .equ OPAMP_SETTLE_gm = 0x7F              ; Settle Time group mask
                                 .equ OPAMP_SETTLE_gp = 0                 ; Settle Time group position
                                 .equ OPAMP_SETTLE0_bm = (1<<0)           ; Settle Time bit 0 mask
                                 .equ OPAMP_SETTLE0_bp = 0                ; Settle Time bit 0 position
                                 .equ OPAMP_SETTLE1_bm = (1<<1)           ; Settle Time bit 1 mask
                                 .equ OPAMP_SETTLE1_bp = 1                ; Settle Time bit 1 position
                                 .equ OPAMP_SETTLE2_bm = (1<<2)           ; Settle Time bit 2 mask
                                 .equ OPAMP_SETTLE2_bp = 2                ; Settle Time bit 2 position
                                 .equ OPAMP_SETTLE3_bm = (1<<3)           ; Settle Time bit 3 mask
                                 .equ OPAMP_SETTLE3_bp = 3                ; Settle Time bit 3 position
                                 .equ OPAMP_SETTLE4_bm = (1<<4)           ; Settle Time bit 4 mask
                                 .equ OPAMP_SETTLE4_bp = 4                ; Settle Time bit 4 position
                                 .equ OPAMP_SETTLE5_bm = (1<<5)           ; Settle Time bit 5 mask
                                 .equ OPAMP_SETTLE5_bp = 5                ; Settle Time bit 5 position
                                 .equ OPAMP_SETTLE6_bm = (1<<6)           ; Settle Time bit 6 mask
                                 .equ OPAMP_SETTLE6_bp = 6                ; Settle Time bit 6 position
                                 
                                 ; OPAMP_OP0STATUS masks
                                 .equ OPAMP_SETTLED_bm = 0x01             ; Settled bit mask
                                 .equ OPAMP_SETTLED_bp = 0                ; Settled bit position
                                 
                                 ; OPAMP_OP1CAL masks
                                 ; Masks for OPAMP_CAL already defined
                                 
                                 ; OPAMP_OP1CTRLA masks
                                 ; Masks for OPAMP_ALWAYSON already defined
                                 ; Masks for OPAMP_EVENTEN already defined
                                 ; Masks for OPAMP_OUTMODE already defined
                                 ; Masks for OPAMP_RUNSTBY already defined
                                 
                                 ; OPAMP_OP1INMUX masks
                                 ; Masks for OPAMP_MUXNEG already defined
                                 ; Masks for OPAMP_MUXPOS already defined
                                 
                                 ; OPAMP_OP1RESMUX masks
                                 ; Masks for OPAMP_MUXBOT already defined
                                 ; Masks for OPAMP_MUXTOP already defined
                                 ; Masks for OPAMP_MUXWIP already defined
                                 
                                 ; OPAMP_OP1SETTLE masks
                                 ; Masks for OPAMP_SETTLE already defined
                                 
                                 ; OPAMP_OP1STATUS masks
                                 ; Masks for OPAMP_SETTLED already defined
                                 
                                 ; OPAMP_OP2CAL masks
                                 ; Masks for OPAMP_CAL already defined
                                 
                                 ; OPAMP_OP2CTRLA masks
                                 ; Masks for OPAMP_ALWAYSON already defined
                                 ; Masks for OPAMP_EVENTEN already defined
                                 ; Masks for OPAMP_OUTMODE already defined
                                 ; Masks for OPAMP_RUNSTBY already defined
                                 
                                 ; OPAMP_OP2INMUX masks
                                 ; Masks for OPAMP_MUXNEG already defined
                                 ; Masks for OPAMP_MUXPOS already defined
                                 
                                 ; OPAMP_OP2RESMUX masks
                                 ; Masks for OPAMP_MUXBOT already defined
                                 ; Masks for OPAMP_MUXTOP already defined
                                 ; Masks for OPAMP_MUXWIP already defined
                                 
                                 ; OPAMP_OP2SETTLE masks
                                 ; Masks for OPAMP_SETTLE already defined
                                 
                                 ; OPAMP_OP2STATUS masks
                                 ; Masks for OPAMP_SETTLED already defined
                                 
                                 ; OPAMP_PWRCTRL masks
                                 .equ OPAMP_IRSEL_bm = 0x01               ; Input Range Select bit mask
                                 .equ OPAMP_IRSEL_bp = 0                  ; Input Range Select bit position
                                 
                                 ; OPAMP_TIMEBASE masks
                                 .equ OPAMP_TIMEBASE_gm = 0x7F            ; Timebase Value group mask
                                 .equ OPAMP_TIMEBASE_gp = 0               ; Timebase Value group position
                                 .equ OPAMP_TIMEBASE0_bm = (1<<0)         ; Timebase Value bit 0 mask
                                 .equ OPAMP_TIMEBASE0_bp = 0              ; Timebase Value bit 0 position
                                 .equ OPAMP_TIMEBASE1_bm = (1<<1)         ; Timebase Value bit 1 mask
                                 .equ OPAMP_TIMEBASE1_bp = 1              ; Timebase Value bit 1 position
                                 .equ OPAMP_TIMEBASE2_bm = (1<<2)         ; Timebase Value bit 2 mask
                                 .equ OPAMP_TIMEBASE2_bp = 2              ; Timebase Value bit 2 position
                                 .equ OPAMP_TIMEBASE3_bm = (1<<3)         ; Timebase Value bit 3 mask
                                 .equ OPAMP_TIMEBASE3_bp = 3              ; Timebase Value bit 3 position
                                 .equ OPAMP_TIMEBASE4_bm = (1<<4)         ; Timebase Value bit 4 mask
                                 .equ OPAMP_TIMEBASE4_bp = 4              ; Timebase Value bit 4 position
                                 .equ OPAMP_TIMEBASE5_bm = (1<<5)         ; Timebase Value bit 5 mask
                                 .equ OPAMP_TIMEBASE5_bp = 5              ; Timebase Value bit 5 position
                                 .equ OPAMP_TIMEBASE6_bm = (1<<6)         ; Timebase Value bit 6 mask
                                 .equ OPAMP_TIMEBASE6_bp = 6              ; Timebase Value bit 6 position
                                 
                                 ; Output Mode select
                                 .equ OPAMP_OUTMODE_OFF_gc = (0x00<<2)    ; Output Driver Off
                                 .equ OPAMP_OUTMODE_NORMAL_gc = (0x01<<2) ; Output Driver in Normal Mode
                                 
                                 ; Negative Input Multiplexer select
                                 .equ OPAMP_MUXNEG_INN_gc = (0x00<<4)     ; Negative input pin for OPn
                                 .equ OPAMP_MUXNEG_WIP_gc = (0x01<<4)     ; Wiper from OPn's resistor ladder
                                 .equ OPAMP_MUXNEG_OUT_gc = (0x02<<4)     ; OPn output (unity gain)
                                 .equ OPAMP_MUXNEG_DAC_gc = (0x03<<4)     ; DAC output
                                 
                                 ; Positive Input Multiplexer select
                                 .equ OPAMP_MUXPOS_INP_gc = (0x00<<0)     ; Positive input pin for OPn
                                 .equ OPAMP_MUXPOS_WIP_gc = (0x01<<0)     ; Wiper from OPn's resistor ladder
                                 .equ OPAMP_MUXPOS_DAC_gc = (0x02<<0)     ; DAC output
                                 .equ OPAMP_MUXPOS_GND_gc = (0x03<<0)     ; Ground
                                 .equ OPAMP_MUXPOS_VDDDIV2_gc = (0x04<<0) ; VDD/2
                                 
                                 ; Positive Input Multiplexer select
                                 .equ OPAMP_MUXPOS_LINKOUT_gc = (0x05<<0) ; Output from OP0
                                 
                                 ; Positive Input Multiplexer select
                                 .equ OPAMP_MUXPOS_LINKWIP_gc = (0x06<<0) ; Wiper from OP0's resistor ladder
                                 
                                 ; Multiplexer Bottom select
                                 .equ OPAMP_MUXBOT_OFF_gc = (0x00<<2)     ; Multiplexer off
                                 .equ OPAMP_MUXBOT_INP_gc = (0x01<<2)     ; Positive input pin for OPn
                                 .equ OPAMP_MUXBOT_INN_gc = (0x02<<2)     ; Negative input pin for OPn
                                 .equ OPAMP_MUXBOT_DAC_gc = (0x03<<2)     ; DAC output
                                 .equ OPAMP_MUXBOT_LINKOUT_gc = (0x04<<2) ; Link OP[n-1] output
                                 .equ OPAMP_MUXBOT_GND_gc = (0x05<<2)     ; Ground
                                 
                                 ; Multiplexer Top select
                                 .equ OPAMP_MUXTOP_OFF_gc = (0x00<<0)     ; Multiplexer off
                                 .equ OPAMP_MUXTOP_OUT_gc = (0x01<<0)     ; OPn output
                                 .equ OPAMP_MUXTOP_VDD_gc = (0x02<<0)     ; VDD
                                 
                                 ; Multiplexer Wiper selector select
                                 .equ OPAMP_MUXWIP_WIP0_gc = (0x00<<5)    ; R1 = 15R, R2 = 1R, R2/R1 = 0.07
                                 .equ OPAMP_MUXWIP_WIP1_gc = (0x01<<5)    ; R1 = 14R, R2 = 2R, R2/R1 = 0.14
                                 .equ OPAMP_MUXWIP_WIP2_gc = (0x02<<5)    ; R1 = 12R, R2 = 4R, R2/R1 = 0.33
                                 .equ OPAMP_MUXWIP_WIP3_gc = (0x03<<5)    ; R1 = 8R, R2 = 8R, R2/R1 = 1
                                 .equ OPAMP_MUXWIP_WIP4_gc = (0x04<<5)    ; R1 = 6R, R2 = 10R, R2/R1 = 1.67
                                 .equ OPAMP_MUXWIP_WIP5_gc = (0x05<<5)    ; R1 = 4R, R2 = 12R, R2/R1 = 3
                                 .equ OPAMP_MUXWIP_WIP6_gc = (0x06<<5)    ; R1 = 2R, R2 = 14R, R2/R1 = 7
                                 .equ OPAMP_MUXWIP_WIP7_gc = (0x07<<5)    ; R1 = 1R, R2 = 15R, R2/R1 = 15
                                 
                                 ; Input Range Select select
                                 .equ OPAMP_IRSEL_FULL_gc = (0x00<<0)     ; Full Input Range
                                 .equ OPAMP_IRSEL_REDUCED_gc = (0x01<<0)  ; Reduced Input Range
                                 
                                 
                                 ;*************************************************************************
                                 ;** PORT - I/O Ports
                                 ;*************************************************************************
                                 
                                 ; PORT_INTFLAGS masks
                                 .equ PORT_INT_gm = 0xFF                  ; Pin Interrupt group mask
                                 .equ PORT_INT_gp = 0                     ; Pin Interrupt group position
                                 .equ PORT_INT0_bm = (1<<0)               ; Pin Interrupt bit 0 mask
                                 .equ PORT_INT0_bp = 0                    ; Pin Interrupt bit 0 position
                                 .equ PORT_INT1_bm = (1<<1)               ; Pin Interrupt bit 1 mask
                                 .equ PORT_INT1_bp = 1                    ; Pin Interrupt bit 1 position
                                 .equ PORT_INT2_bm = (1<<2)               ; Pin Interrupt bit 2 mask
                                 .equ PORT_INT2_bp = 2                    ; Pin Interrupt bit 2 position
                                 .equ PORT_INT3_bm = (1<<3)               ; Pin Interrupt bit 3 mask
                                 .equ PORT_INT3_bp = 3                    ; Pin Interrupt bit 3 position
                                 .equ PORT_INT4_bm = (1<<4)               ; Pin Interrupt bit 4 mask
                                 .equ PORT_INT4_bp = 4                    ; Pin Interrupt bit 4 position
                                 .equ PORT_INT5_bm = (1<<5)               ; Pin Interrupt bit 5 mask
                                 .equ PORT_INT5_bp = 5                    ; Pin Interrupt bit 5 position
                                 .equ PORT_INT6_bm = (1<<6)               ; Pin Interrupt bit 6 mask
                                 .equ PORT_INT6_bp = 6                    ; Pin Interrupt bit 6 position
                                 .equ PORT_INT7_bm = (1<<7)               ; Pin Interrupt bit 7 mask
                                 .equ PORT_INT7_bp = 7                    ; Pin Interrupt bit 7 position
                                 
                                 ; PORT_PINCONFIG masks
                                 .equ PORT_INLVL_bm = 0x40                ; Input level select bit mask
                                 .equ PORT_INLVL_bp = 6                   ; Input level select bit position
                                 .equ PORT_INVEN_bm = 0x80                ; Inverted I/O Enable bit mask
                                 .equ PORT_INVEN_bp = 7                   ; Inverted I/O Enable bit position
                                 .equ PORT_ISC_gm = 0x07                  ; Input/Sense Configuration group mask
                                 .equ PORT_ISC_gp = 0                     ; Input/Sense Configuration group position
                                 .equ PORT_ISC0_bm = (1<<0)               ; Input/Sense Configuration bit 0 mask
                                 .equ PORT_ISC0_bp = 0                    ; Input/Sense Configuration bit 0 position
                                 .equ PORT_ISC1_bm = (1<<1)               ; Input/Sense Configuration bit 1 mask
                                 .equ PORT_ISC1_bp = 1                    ; Input/Sense Configuration bit 1 position
                                 .equ PORT_ISC2_bm = (1<<2)               ; Input/Sense Configuration bit 2 mask
                                 .equ PORT_ISC2_bp = 2                    ; Input/Sense Configuration bit 2 position
                                 .equ PORT_PULLUPEN_bm = 0x08             ; Pullup enable bit mask
                                 .equ PORT_PULLUPEN_bp = 3                ; Pullup enable bit position
                                 
                                 ; PORT_PINCTRLCLR masks
                                 .equ PORT_PINCTRLCLR_gm = 0xFF           ; Pin control clear mask group mask
                                 .equ PORT_PINCTRLCLR_gp = 0              ; Pin control clear mask group position
                                 .equ PORT_PINCTRLCLR0_bm = (1<<0)        ; Pin control clear mask bit 0 mask
                                 .equ PORT_PINCTRLCLR0_bp = 0             ; Pin control clear mask bit 0 position
                                 .equ PORT_PINCTRLCLR1_bm = (1<<1)        ; Pin control clear mask bit 1 mask
                                 .equ PORT_PINCTRLCLR1_bp = 1             ; Pin control clear mask bit 1 position
                                 .equ PORT_PINCTRLCLR2_bm = (1<<2)        ; Pin control clear mask bit 2 mask
                                 .equ PORT_PINCTRLCLR2_bp = 2             ; Pin control clear mask bit 2 position
                                 .equ PORT_PINCTRLCLR3_bm = (1<<3)        ; Pin control clear mask bit 3 mask
                                 .equ PORT_PINCTRLCLR3_bp = 3             ; Pin control clear mask bit 3 position
                                 .equ PORT_PINCTRLCLR4_bm = (1<<4)        ; Pin control clear mask bit 4 mask
                                 .equ PORT_PINCTRLCLR4_bp = 4             ; Pin control clear mask bit 4 position
                                 .equ PORT_PINCTRLCLR5_bm = (1<<5)        ; Pin control clear mask bit 5 mask
                                 .equ PORT_PINCTRLCLR5_bp = 5             ; Pin control clear mask bit 5 position
                                 .equ PORT_PINCTRLCLR6_bm = (1<<6)        ; Pin control clear mask bit 6 mask
                                 .equ PORT_PINCTRLCLR6_bp = 6             ; Pin control clear mask bit 6 position
                                 .equ PORT_PINCTRLCLR7_bm = (1<<7)        ; Pin control clear mask bit 7 mask
                                 .equ PORT_PINCTRLCLR7_bp = 7             ; Pin control clear mask bit 7 position
                                 
                                 ; PORT_PINCTRLSET masks
                                 .equ PORT_PINCTRLSET_gm = 0xFF           ; Pin control set mask group mask
                                 .equ PORT_PINCTRLSET_gp = 0              ; Pin control set mask group position
                                 .equ PORT_PINCTRLSET0_bm = (1<<0)        ; Pin control set mask bit 0 mask
                                 .equ PORT_PINCTRLSET0_bp = 0             ; Pin control set mask bit 0 position
                                 .equ PORT_PINCTRLSET1_bm = (1<<1)        ; Pin control set mask bit 1 mask
                                 .equ PORT_PINCTRLSET1_bp = 1             ; Pin control set mask bit 1 position
                                 .equ PORT_PINCTRLSET2_bm = (1<<2)        ; Pin control set mask bit 2 mask
                                 .equ PORT_PINCTRLSET2_bp = 2             ; Pin control set mask bit 2 position
                                 .equ PORT_PINCTRLSET3_bm = (1<<3)        ; Pin control set mask bit 3 mask
                                 .equ PORT_PINCTRLSET3_bp = 3             ; Pin control set mask bit 3 position
                                 .equ PORT_PINCTRLSET4_bm = (1<<4)        ; Pin control set mask bit 4 mask
                                 .equ PORT_PINCTRLSET4_bp = 4             ; Pin control set mask bit 4 position
                                 .equ PORT_PINCTRLSET5_bm = (1<<5)        ; Pin control set mask bit 5 mask
                                 .equ PORT_PINCTRLSET5_bp = 5             ; Pin control set mask bit 5 position
                                 .equ PORT_PINCTRLSET6_bm = (1<<6)        ; Pin control set mask bit 6 mask
                                 .equ PORT_PINCTRLSET6_bp = 6             ; Pin control set mask bit 6 position
                                 .equ PORT_PINCTRLSET7_bm = (1<<7)        ; Pin control set mask bit 7 mask
                                 .equ PORT_PINCTRLSET7_bp = 7             ; Pin control set mask bit 7 position
                                 
                                 ; PORT_PINCTRLUPD masks
                                 .equ PORT_PINCTRLUPD_gm = 0xFF           ; Pin control update mask group mask
                                 .equ PORT_PINCTRLUPD_gp = 0              ; Pin control update mask group position
                                 .equ PORT_PINCTRLUPD0_bm = (1<<0)        ; Pin control update mask bit 0 mask
                                 .equ PORT_PINCTRLUPD0_bp = 0             ; Pin control update mask bit 0 position
                                 .equ PORT_PINCTRLUPD1_bm = (1<<1)        ; Pin control update mask bit 1 mask
                                 .equ PORT_PINCTRLUPD1_bp = 1             ; Pin control update mask bit 1 position
                                 .equ PORT_PINCTRLUPD2_bm = (1<<2)        ; Pin control update mask bit 2 mask
                                 .equ PORT_PINCTRLUPD2_bp = 2             ; Pin control update mask bit 2 position
                                 .equ PORT_PINCTRLUPD3_bm = (1<<3)        ; Pin control update mask bit 3 mask
                                 .equ PORT_PINCTRLUPD3_bp = 3             ; Pin control update mask bit 3 position
                                 .equ PORT_PINCTRLUPD4_bm = (1<<4)        ; Pin control update mask bit 4 mask
                                 .equ PORT_PINCTRLUPD4_bp = 4             ; Pin control update mask bit 4 position
                                 .equ PORT_PINCTRLUPD5_bm = (1<<5)        ; Pin control update mask bit 5 mask
                                 .equ PORT_PINCTRLUPD5_bp = 5             ; Pin control update mask bit 5 position
                                 .equ PORT_PINCTRLUPD6_bm = (1<<6)        ; Pin control update mask bit 6 mask
                                 .equ PORT_PINCTRLUPD6_bp = 6             ; Pin control update mask bit 6 position
                                 .equ PORT_PINCTRLUPD7_bm = (1<<7)        ; Pin control update mask bit 7 mask
                                 .equ PORT_PINCTRLUPD7_bp = 7             ; Pin control update mask bit 7 position
                                 
                                 ; PORT_PIN0CTRL masks
                                 ; Masks for PORT_INLVL already defined
                                 ; Masks for PORT_INVEN already defined
                                 ; Masks for PORT_ISC already defined
                                 ; Masks for PORT_PULLUPEN already defined
                                 
                                 ; PORT_PIN1CTRL masks
                                 ; Masks for PORT_INLVL already defined
                                 ; Masks for PORT_INVEN already defined
                                 ; Masks for PORT_ISC already defined
                                 ; Masks for PORT_PULLUPEN already defined
                                 
                                 ; PORT_PIN2CTRL masks
                                 ; Masks for PORT_INLVL already defined
                                 ; Masks for PORT_INVEN already defined
                                 ; Masks for PORT_ISC already defined
                                 ; Masks for PORT_PULLUPEN already defined
                                 
                                 ; PORT_PIN3CTRL masks
                                 ; Masks for PORT_INLVL already defined
                                 ; Masks for PORT_INVEN already defined
                                 ; Masks for PORT_ISC already defined
                                 ; Masks for PORT_PULLUPEN already defined
                                 
                                 ; PORT_PIN4CTRL masks
                                 ; Masks for PORT_INLVL already defined
                                 ; Masks for PORT_INVEN already defined
                                 ; Masks for PORT_ISC already defined
                                 ; Masks for PORT_PULLUPEN already defined
                                 
                                 ; PORT_PIN5CTRL masks
                                 ; Masks for PORT_INLVL already defined
                                 ; Masks for PORT_INVEN already defined
                                 ; Masks for PORT_ISC already defined
                                 ; Masks for PORT_PULLUPEN already defined
                                 
                                 ; PORT_PIN6CTRL masks
                                 ; Masks for PORT_INLVL already defined
                                 ; Masks for PORT_INVEN already defined
                                 ; Masks for PORT_ISC already defined
                                 ; Masks for PORT_PULLUPEN already defined
                                 
                                 ; PORT_PIN7CTRL masks
                                 ; Masks for PORT_INLVL already defined
                                 ; Masks for PORT_INVEN already defined
                                 ; Masks for PORT_ISC already defined
                                 ; Masks for PORT_PULLUPEN already defined
                                 
                                 ; PORT_PORTCTRL masks
                                 .equ PORT_SRL_bm = 0x01                  ; Slew Rate Limit Enable bit mask
                                 .equ PORT_SRL_bp = 0                     ; Slew Rate Limit Enable bit position
                                 
                                 ; Input/Sense Configuration select
                                 .equ PORT_ISC_INTDISABLE_gc = (0x00<<0)  ; Interrupt disabled but input buffer enabled
                                 .equ PORT_ISC_BOTHEDGES_gc = (0x01<<0)   ; Sense Both Edges
                                 .equ PORT_ISC_RISING_gc = (0x02<<0)      ; Sense Rising Edge
                                 .equ PORT_ISC_FALLING_gc = (0x03<<0)     ; Sense Falling Edge
                                 .equ PORT_ISC_INPUT_DISABLE_gc = (0x04<<0) ; Digital Input Buffer disabled
                                 .equ PORT_ISC_LEVEL_gc = (0x05<<0)       ; Sense low Level
                                 
                                 
                                 ;*************************************************************************
                                 ;** PORTMUX - Port Multiplexer
                                 ;*************************************************************************
                                 
                                 ; PORTMUX_ACROUTEA masks
                                 .equ PORTMUX_AC0_bm = 0x01               ; Analog Comparator 0 Output bit mask
                                 .equ PORTMUX_AC0_bp = 0                  ; Analog Comparator 0 Output bit position
                                 .equ PORTMUX_AC1_bm = 0x02               ; Analog Comparator 1 Output bit mask
                                 .equ PORTMUX_AC1_bp = 1                  ; Analog Comparator 1 Output bit position
                                 .equ PORTMUX_AC2_bm = 0x04               ; Analog Comparator 2 Output bit mask
                                 .equ PORTMUX_AC2_bp = 2                  ; Analog Comparator 2 Output bit position
                                 
                                 ; PORTMUX_CCLROUTEA masks
                                 .equ PORTMUX_LUT0_bm = 0x01              ; CCL Look-Up Table 0 Signals bit mask
                                 .equ PORTMUX_LUT0_bp = 0                 ; CCL Look-Up Table 0 Signals bit position
                                 .equ PORTMUX_LUT1_bm = 0x02              ; CCL Look-Up Table 1 Signals bit mask
                                 .equ PORTMUX_LUT1_bp = 1                 ; CCL Look-Up Table 1 Signals bit position
                                 .equ PORTMUX_LUT2_bm = 0x04              ; CCL Look-Up Table 2 Signals bit mask
                                 .equ PORTMUX_LUT2_bp = 2                 ; CCL Look-Up Table 2 Signals bit position
                                 .equ PORTMUX_LUT3_bm = 0x08              ; CCL Look-Up Table 3 Signals bit mask
                                 .equ PORTMUX_LUT3_bp = 3                 ; CCL Look-Up Table 3 Signals bit position
                                 .equ PORTMUX_LUT4_bm = 0x10              ; CCL Look-Up Table 4 Signals bit mask
                                 .equ PORTMUX_LUT4_bp = 4                 ; CCL Look-Up Table 4 Signals bit position
                                 .equ PORTMUX_LUT5_bm = 0x20              ; CCL Look-Up Table 5 Signals bit mask
                                 .equ PORTMUX_LUT5_bp = 5                 ; CCL Look-Up Table 5 Signals bit position
                                 
                                 ; PORTMUX_EVSYSROUTEA masks
                                 .equ PORTMUX_EVOUTA_bm = 0x01            ; Event Output A bit mask
                                 .equ PORTMUX_EVOUTA_bp = 0               ; Event Output A bit position
                                 .equ PORTMUX_EVOUTB_bm = 0x02            ; Event Output B bit mask
                                 .equ PORTMUX_EVOUTB_bp = 1               ; Event Output B bit position
                                 .equ PORTMUX_EVOUTC_bm = 0x04            ; Event Output C bit mask
                                 .equ PORTMUX_EVOUTC_bp = 2               ; Event Output C bit position
                                 .equ PORTMUX_EVOUTD_bm = 0x08            ; Event Output D bit mask
                                 .equ PORTMUX_EVOUTD_bp = 3               ; Event Output D bit position
                                 .equ PORTMUX_EVOUTE_bm = 0x10            ; Event Output E bit mask
                                 .equ PORTMUX_EVOUTE_bp = 4               ; Event Output E bit position
                                 .equ PORTMUX_EVOUTF_bm = 0x20            ; Event Output F bit mask
                                 .equ PORTMUX_EVOUTF_bp = 5               ; Event Output F bit position
                                 .equ PORTMUX_EVOUTG_bm = 0x40            ; Event Output G bit mask
                                 .equ PORTMUX_EVOUTG_bp = 6               ; Event Output G bit position
                                 
                                 ; PORTMUX_SPIROUTEA masks
                                 .equ PORTMUX_SPI0_gm = 0x03              ; SPI0 Signals group mask
                                 .equ PORTMUX_SPI0_gp = 0                 ; SPI0 Signals group position
                                 .equ PORTMUX_SPI00_bm = (1<<0)           ; SPI0 Signals bit 0 mask
                                 .equ PORTMUX_SPI00_bp = 0                ; SPI0 Signals bit 0 position
                                 .equ PORTMUX_SPI01_bm = (1<<1)           ; SPI0 Signals bit 1 mask
                                 .equ PORTMUX_SPI01_bp = 1                ; SPI0 Signals bit 1 position
                                 .equ PORTMUX_SPI1_gm = 0x0C              ; SPI1 Signals group mask
                                 .equ PORTMUX_SPI1_gp = 2                 ; SPI1 Signals group position
                                 .equ PORTMUX_SPI10_bm = (1<<2)           ; SPI1 Signals bit 0 mask
                                 .equ PORTMUX_SPI10_bp = 2                ; SPI1 Signals bit 0 position
                                 .equ PORTMUX_SPI11_bm = (1<<3)           ; SPI1 Signals bit 1 mask
                                 .equ PORTMUX_SPI11_bp = 3                ; SPI1 Signals bit 1 position
                                 
                                 ; PORTMUX_TCAROUTEA masks
                                 .equ PORTMUX_TCA0_gm = 0x07              ; TCA0 Signals group mask
                                 .equ PORTMUX_TCA0_gp = 0                 ; TCA0 Signals group position
                                 .equ PORTMUX_TCA00_bm = (1<<0)           ; TCA0 Signals bit 0 mask
                                 .equ PORTMUX_TCA00_bp = 0                ; TCA0 Signals bit 0 position
                                 .equ PORTMUX_TCA01_bm = (1<<1)           ; TCA0 Signals bit 1 mask
                                 .equ PORTMUX_TCA01_bp = 1                ; TCA0 Signals bit 1 position
                                 .equ PORTMUX_TCA02_bm = (1<<2)           ; TCA0 Signals bit 2 mask
                                 .equ PORTMUX_TCA02_bp = 2                ; TCA0 Signals bit 2 position
                                 .equ PORTMUX_TCA1_gm = 0x38              ; TCA1 Signals group mask
                                 .equ PORTMUX_TCA1_gp = 3                 ; TCA1 Signals group position
                                 .equ PORTMUX_TCA10_bm = (1<<3)           ; TCA1 Signals bit 0 mask
                                 .equ PORTMUX_TCA10_bp = 3                ; TCA1 Signals bit 0 position
                                 .equ PORTMUX_TCA11_bm = (1<<4)           ; TCA1 Signals bit 1 mask
                                 .equ PORTMUX_TCA11_bp = 4                ; TCA1 Signals bit 1 position
                                 .equ PORTMUX_TCA12_bm = (1<<5)           ; TCA1 Signals bit 2 mask
                                 .equ PORTMUX_TCA12_bp = 5                ; TCA1 Signals bit 2 position
                                 
                                 ; PORTMUX_TCBROUTEA masks
                                 .equ PORTMUX_TCB0_bm = 0x01              ; TCB0 Output bit mask
                                 .equ PORTMUX_TCB0_bp = 0                 ; TCB0 Output bit position
                                 .equ PORTMUX_TCB1_bm = 0x02              ; TCB1 Output bit mask
                                 .equ PORTMUX_TCB1_bp = 1                 ; TCB1 Output bit position
                                 .equ PORTMUX_TCB2_bm = 0x04              ; TCB2 Output bit mask
                                 .equ PORTMUX_TCB2_bp = 2                 ; TCB2 Output bit position
                                 .equ PORTMUX_TCB3_bm = 0x08              ; TCB3 Output bit mask
                                 .equ PORTMUX_TCB3_bp = 3                 ; TCB3 Output bit position
                                 .equ PORTMUX_TCB4_bm = 0x10              ; TCB4 Output bit mask
                                 .equ PORTMUX_TCB4_bp = 4                 ; TCB4 Output bit position
                                 
                                 ; PORTMUX_TCDROUTEA masks
                                 .equ PORTMUX_TCD0_gm = 0x07              ; TCD0 Signals group mask
                                 .equ PORTMUX_TCD0_gp = 0                 ; TCD0 Signals group position
                                 .equ PORTMUX_TCD00_bm = (1<<0)           ; TCD0 Signals bit 0 mask
                                 .equ PORTMUX_TCD00_bp = 0                ; TCD0 Signals bit 0 position
                                 .equ PORTMUX_TCD01_bm = (1<<1)           ; TCD0 Signals bit 1 mask
                                 .equ PORTMUX_TCD01_bp = 1                ; TCD0 Signals bit 1 position
                                 .equ PORTMUX_TCD02_bm = (1<<2)           ; TCD0 Signals bit 2 mask
                                 .equ PORTMUX_TCD02_bp = 2                ; TCD0 Signals bit 2 position
                                 
                                 ; PORTMUX_TWIROUTEA masks
                                 .equ PORTMUX_TWI0_gm = 0x03              ; TWI0 Signals group mask
                                 .equ PORTMUX_TWI0_gp = 0                 ; TWI0 Signals group position
                                 .equ PORTMUX_TWI00_bm = (1<<0)           ; TWI0 Signals bit 0 mask
                                 .equ PORTMUX_TWI00_bp = 0                ; TWI0 Signals bit 0 position
                                 .equ PORTMUX_TWI01_bm = (1<<1)           ; TWI0 Signals bit 1 mask
                                 .equ PORTMUX_TWI01_bp = 1                ; TWI0 Signals bit 1 position
                                 .equ PORTMUX_TWI1_gm = 0x0C              ; TWI1 Signals group mask
                                 .equ PORTMUX_TWI1_gp = 2                 ; TWI1 Signals group position
                                 .equ PORTMUX_TWI10_bm = (1<<2)           ; TWI1 Signals bit 0 mask
                                 .equ PORTMUX_TWI10_bp = 2                ; TWI1 Signals bit 0 position
                                 .equ PORTMUX_TWI11_bm = (1<<3)           ; TWI1 Signals bit 1 mask
                                 .equ PORTMUX_TWI11_bp = 3                ; TWI1 Signals bit 1 position
                                 
                                 ; PORTMUX_USARTROUTEA masks
                                 .equ PORTMUX_USART0_gm = 0x03            ; USART0 Signals group mask
                                 .equ PORTMUX_USART0_gp = 0               ; USART0 Signals group position
                                 .equ PORTMUX_USART00_bm = (1<<0)         ; USART0 Signals bit 0 mask
                                 .equ PORTMUX_USART00_bp = 0              ; USART0 Signals bit 0 position
                                 .equ PORTMUX_USART01_bm = (1<<1)         ; USART0 Signals bit 1 mask
                                 .equ PORTMUX_USART01_bp = 1              ; USART0 Signals bit 1 position
                                 .equ PORTMUX_USART1_gm = 0x0C            ; USART1 Signals group mask
                                 .equ PORTMUX_USART1_gp = 2               ; USART1 Signals group position
                                 .equ PORTMUX_USART10_bm = (1<<2)         ; USART1 Signals bit 0 mask
                                 .equ PORTMUX_USART10_bp = 2              ; USART1 Signals bit 0 position
                                 .equ PORTMUX_USART11_bm = (1<<3)         ; USART1 Signals bit 1 mask
                                 .equ PORTMUX_USART11_bp = 3              ; USART1 Signals bit 1 position
                                 .equ PORTMUX_USART2_gm = 0x30            ; USART2 Signals group mask
                                 .equ PORTMUX_USART2_gp = 4               ; USART2 Signals group position
                                 .equ PORTMUX_USART20_bm = (1<<4)         ; USART2 Signals bit 0 mask
                                 .equ PORTMUX_USART20_bp = 4              ; USART2 Signals bit 0 position
                                 .equ PORTMUX_USART21_bm = (1<<5)         ; USART2 Signals bit 1 mask
                                 .equ PORTMUX_USART21_bp = 5              ; USART2 Signals bit 1 position
                                 .equ PORTMUX_USART3_gm = 0xC0            ; USART3  Signals group mask
                                 .equ PORTMUX_USART3_gp = 6               ; USART3  Signals group position
                                 .equ PORTMUX_USART30_bm = (1<<6)         ; USART3  Signals bit 0 mask
                                 .equ PORTMUX_USART30_bp = 6              ; USART3  Signals bit 0 position
                                 .equ PORTMUX_USART31_bm = (1<<7)         ; USART3  Signals bit 1 mask
                                 .equ PORTMUX_USART31_bp = 7              ; USART3  Signals bit 1 position
                                 
                                 ; PORTMUX_USARTROUTEB masks
                                 .equ PORTMUX_USART4_gm = 0x03            ; USART4 Signals group mask
                                 .equ PORTMUX_USART4_gp = 0               ; USART4 Signals group position
                                 .equ PORTMUX_USART40_bm = (1<<0)         ; USART4 Signals bit 0 mask
                                 .equ PORTMUX_USART40_bp = 0              ; USART4 Signals bit 0 position
                                 .equ PORTMUX_USART41_bm = (1<<1)         ; USART4 Signals bit 1 mask
                                 .equ PORTMUX_USART41_bp = 1              ; USART4 Signals bit 1 position
                                 .equ PORTMUX_USART5_gm = 0x0C            ; USART5 Signals group mask
                                 .equ PORTMUX_USART5_gp = 2               ; USART5 Signals group position
                                 .equ PORTMUX_USART50_bm = (1<<2)         ; USART5 Signals bit 0 mask
                                 .equ PORTMUX_USART50_bp = 2              ; USART5 Signals bit 0 position
                                 .equ PORTMUX_USART51_bm = (1<<3)         ; USART5 Signals bit 1 mask
                                 .equ PORTMUX_USART51_bp = 3              ; USART5 Signals bit 1 position
                                 
                                 ; PORTMUX_ZCDROUTEA masks
                                 .equ PORTMUX_ZCD0_bm = 0x01              ; Zero Cross Detector 0 Output bit mask
                                 .equ PORTMUX_ZCD0_bp = 0                 ; Zero Cross Detector 0 Output bit position
                                 .equ PORTMUX_ZCD1_bm = 0x02              ; Zero Cross Detector 1 Output bit mask
                                 .equ PORTMUX_ZCD1_bp = 1                 ; Zero Cross Detector 1 Output bit position
                                 .equ PORTMUX_ZCD2_bm = 0x04              ; Zero Cross Detector 2 Output bit mask
                                 .equ PORTMUX_ZCD2_bp = 2                 ; Zero Cross Detector 2 Output bit position
                                 
                                 ; Analog Comparator 0 Output select
                                 .equ PORTMUX_AC0_DEFAULT_gc = (0x00<<0)  ; OUT on PA7
                                 .equ PORTMUX_AC0_ALT1_gc = (0x01<<0)     ; OUT on PC6
                                 
                                 ; Analog Comparator 1 Output select
                                 .equ PORTMUX_AC1_DEFAULT_gc = (0x00<<1)  ; OUT on PA7
                                 .equ PORTMUX_AC1_ALT1_gc = (0x01<<1)     ; OUT on PC6
                                 
                                 ; Analog Comparator 2 Output select
                                 .equ PORTMUX_AC2_DEFAULT_gc = (0x00<<2)  ; OUT on PA7
                                 .equ PORTMUX_AC2_ALT1_gc = (0x01<<2)     ; OUT on PC6
                                 
                                 ; CCL Look-Up Table 0 Signals select
                                 .equ PORTMUX_LUT0_DEFAULT_gc = (0x00<<0) ; Out: PA3 In: PA0, PA1, PA2
                                 .equ PORTMUX_LUT0_ALT1_gc = (0x01<<0)    ; Out: PA6 In: PA0, PA1, PA2
                                 
                                 ; CCL Look-Up Table 1 Signals select
                                 .equ PORTMUX_LUT1_DEFAULT_gc = (0x00<<1) ; Out: PC3 In: PC0, PC1, PC2
                                 .equ PORTMUX_LUT1_ALT1_gc = (0x01<<1)    ; Out: PC6 In: PC0, PC1, PC2
                                 
                                 ; CCL Look-Up Table 2 Signals select
                                 .equ PORTMUX_LUT2_DEFAULT_gc = (0x00<<2) ; Out: PD3 In: PD0, PD1, PD2
                                 .equ PORTMUX_LUT2_ALT1_gc = (0x01<<2)    ; Out: PD6 In: PD0, PD1, PD2
                                 
                                 ; CCL Look-Up Table 3 Signals select
                                 .equ PORTMUX_LUT3_DEFAULT_gc = (0x00<<3) ; Out: PF3 In: PF0, PF1, PF2
                                 
                                 ; CCL Look-Up Table 4 Signals select
                                 .equ PORTMUX_LUT4_DEFAULT_gc = (0x00<<4) ; Out: PB3 In: PB0, PB1, PB2
                                 .equ PORTMUX_LUT4_ALT1_gc = (0x01<<4)    ; Out: PB6 In: PB0, PB1, PB2
                                 
                                 ; CCL Look-Up Table 5 Signals select
                                 .equ PORTMUX_LUT5_DEFAULT_gc = (0x00<<5) ; Out: PG3 In: PG0, PG1, PG2
                                 .equ PORTMUX_LUT5_ALT1_gc = (0x01<<5)    ; Out: PG6 In: PG0, PG1, PG2
                                 
                                 ; Event Output A select
                                 .equ PORTMUX_EVOUTA_DEFAULT_gc = (0x00<<0) ; EVOUT on PA2
                                 .equ PORTMUX_EVOUTA_ALT1_gc = (0x01<<0)  ; EVOUT on PA7
                                 
                                 ; Event Output B select
                                 .equ PORTMUX_EVOUTB_DEFAULT_gc = (0x00<<1) ; EVOUT on PB2
                                 .equ PORTMUX_EVOUTB_ALT1_gc = (0x01<<1)  ; EVOUT on PB7
                                 
                                 ; Event Output C select
                                 .equ PORTMUX_EVOUTC_DEFAULT_gc = (0x00<<2) ; EVOUT on PC2
                                 .equ PORTMUX_EVOUTC_ALT1_gc = (0x01<<2)  ; EVOUT on PC7
                                 
                                 ; Event Output D select
                                 .equ PORTMUX_EVOUTD_DEFAULT_gc = (0x00<<3) ; EVOUT on PD2
                                 .equ PORTMUX_EVOUTD_ALT1_gc = (0x01<<3)  ; EVOUT on PD7
                                 
                                 ; Event Output E select
                                 .equ PORTMUX_EVOUTE_DEFAULT_gc = (0x00<<4) ; EVOUT on PE2
                                 .equ PORTMUX_EVOUTE_ALT1_gc = (0x01<<4)  ; EVOUT on PE7
                                 
                                 ; Event Output F select
                                 .equ PORTMUX_EVOUTF_DEFAULT_gc = (0x00<<5) ; EVOUT on PF2
                                 
                                 ; Event Output G select
                                 .equ PORTMUX_EVOUTG_DEFAULT_gc = (0x00<<6) ; EVOUT on PG2
                                 .equ PORTMUX_EVOUTG_ALT1_gc = (0x01<<6)  ; EVOUT on PG7
                                 
                                 ; SPI0 Signals select
                                 .equ PORTMUX_SPI0_DEFAULT_gc = (0x00<<0) ; PA4, PA5, PA6, PA7
                                 .equ PORTMUX_SPI0_ALT1_gc = (0x01<<0)    ; PE0, PE1, PE2, PE3
                                 .equ PORTMUX_SPI0_ALT2_gc = (0x02<<0)    ; PG4, PG5, PG6, PG7
                                 .equ PORTMUX_SPI0_NONE_gc = (0x03<<0)    ; Not connected to any pins
                                 
                                 ; SPI1 Signals select
                                 .equ PORTMUX_SPI1_DEFAULT_gc = (0x00<<2) ; PC0, PC1, PC2, PC3
                                 .equ PORTMUX_SPI1_ALT1_gc = (0x01<<2)    ; PC4, PC5, PC6, PC7
                                 .equ PORTMUX_SPI1_ALT2_gc = (0x02<<2)    ; PB4, PB5, PB6, PB7
                                 .equ PORTMUX_SPI1_NONE_gc = (0x03<<2)    ; Not connected to any pins
                                 
                                 ; TCA0 Signals select
                                 .equ PORTMUX_TCA0_PORTA_gc = (0x00<<0)   ; PA0, PA1, PA2, PA3, PA4, PA5
                                 .equ PORTMUX_TCA0_PORTB_gc = (0x01<<0)   ; PB0, PB1, PB2, PB3, PB4, PB5
                                 .equ PORTMUX_TCA0_PORTC_gc = (0x02<<0)   ; PC0, PC1, PC2, PC3, PC4, PC5
                                 .equ PORTMUX_TCA0_PORTD_gc = (0x03<<0)   ; PD0, PD1, PD2, PD3, PD4, PD5
                                 .equ PORTMUX_TCA0_PORTE_gc = (0x04<<0)   ; PE0, PE1, PE2, PE3, PE4, PE5
                                 .equ PORTMUX_TCA0_PORTF_gc = (0x05<<0)   ; PF0, PF1, PF2, PF3, PF4, PF5
                                 .equ PORTMUX_TCA0_PORTG_gc = (0x06<<0)   ; PG0, PG1, PG2, PG3, PG4, PG5
                                 
                                 ; TCA1 Signals select
                                 .equ PORTMUX_TCA1_PORTB_gc = (0x00<<3)   ; PB0, PB1, PB2, PB3, PB4, PB5
                                 .equ PORTMUX_TCA1_PORTC_gc = (0x01<<3)   ; PC4, PC5, PC6
                                 .equ PORTMUX_TCA1_PORTE_gc = (0x02<<3)   ; PE4, PE5, PE6
                                 .equ PORTMUX_TCA1_PORTG_gc = (0x03<<3)   ; PG0, PG1, PG2, PG3, PG4, PG5
                                 
                                 ; TCB0 Output select
                                 .equ PORTMUX_TCB0_DEFAULT_gc = (0x00<<0) ; WO on PA2
                                 .equ PORTMUX_TCB0_ALT1_gc = (0x01<<0)    ; WO on PF4
                                 
                                 ; TCB1 Output select
                                 .equ PORTMUX_TCB1_DEFAULT_gc = (0x00<<1) ; WO on PA3
                                 .equ PORTMUX_TCB1_ALT1_gc = (0x01<<1)    ; WO on PF5
                                 
                                 ; TCB2 Output select
                                 .equ PORTMUX_TCB2_DEFAULT_gc = (0x00<<2) ; WO on PC0
                                 .equ PORTMUX_TCB2_ALT1_gc = (0x01<<2)    ; WO on PB4
                                 
                                 ; TCB3 Output select
                                 .equ PORTMUX_TCB3_DEFAULT_gc = (0x00<<3) ; WO on PB5
                                 .equ PORTMUX_TCB3_ALT1_gc = (0x01<<3)    ; WO on PC1
                                 
                                 ; TCB4 Output select
                                 .equ PORTMUX_TCB4_DEFAULT_gc = (0x00<<4) ; WO on PG3
                                 .equ PORTMUX_TCB4_ALT1_gc = (0x01<<4)    ; WO on PC6
                                 
                                 ; TCD0 Signals select
                                 .equ PORTMUX_TCD0_DEFAULT_gc = (0x00<<0) ; PA4, PA5, PA6, PA7
                                 .equ PORTMUX_TCD0_ALT1_gc = (0x01<<0)    ; PB4, PB5, PB6, PB7
                                 .equ PORTMUX_TCD0_ALT2_gc = (0x02<<0)    ; PF0, PF1, PF2, PF3
                                 .equ PORTMUX_TCD0_ALT3_gc = (0x03<<0)    ; PG4, PG5, PG6, PG7
                                 
                                 ; TWI0 Signals select
                                 .equ PORTMUX_TWI0_DEFAULT_gc = (0x00<<0) ; PA2, PA3, PC2, PC3
                                 .equ PORTMUX_TWI0_ALT1_gc = (0x01<<0)    ; PA2, PA3, PC6, PC7
                                 .equ PORTMUX_TWI0_ALT2_gc = (0x02<<0)    ; PC2, PC3, PC6, PC7
                                 
                                 ; TWI1 Signals select
                                 .equ PORTMUX_TWI1_DEFAULT_gc = (0x00<<2) ; PF2, PF3, PB2, PB3
                                 .equ PORTMUX_TWI1_ALT1_gc = (0x01<<2)    ; PF2, PF3, PB6, PB7
                                 .equ PORTMUX_TWI1_ALT2_gc = (0x02<<2)    ; PB2, PB3, PB6, PB7
                                 
                                 ; USART0 Signals select
                                 .equ PORTMUX_USART0_DEFAULT_gc = (0x00<<0) ; PA0, PA1, PA2, PA3
                                 .equ PORTMUX_USART0_ALT1_gc = (0x01<<0)  ; PA4, PA5, PA6, PA7
                                 .equ PORTMUX_USART0_NONE_gc = (0x03<<0)  ; Not connected to any pins
                                 
                                 ; USART1 Signals select
                                 .equ PORTMUX_USART1_DEFAULT_gc = (0x00<<2) ; PC0, PC1, PC2, PC3
                                 .equ PORTMUX_USART1_ALT1_gc = (0x01<<2)  ; PC4, PC5, PC6, PC7
                                 .equ PORTMUX_USART1_NONE_gc = (0x03<<2)  ; Not connected to any pins
                                 
                                 ; USART2 Signals select
                                 .equ PORTMUX_USART2_DEFAULT_gc = (0x00<<4) ; PF0, PF1, PF2, PF3
                                 .equ PORTMUX_USART2_ALT1_gc = (0x01<<4)  ; PF4, PF5
                                 .equ PORTMUX_USART2_NONE_gc = (0x03<<4)  ; Not connected to any pins
                                 
                                 ; USART3  Signals select
                                 .equ PORTMUX_USART3_DEFAULT_gc = (0x00<<6) ; PB0, PB1, PB2, PB3
                                 .equ PORTMUX_USART3_ALT1_gc = (0x01<<6)  ; PB4, PB5, PB6, PB7
                                 .equ PORTMUX_USART3_NONE_gc = (0x03<<6)  ; Not connected to any pins
                                 
                                 ; USART4 Signals select
                                 .equ PORTMUX_USART4_DEFAULT_gc = (0x00<<0) ; PE0, PE1, PE2, PE3
                                 .equ PORTMUX_USART4_ALT1_gc = (0x01<<0)  ; PE4, PE5, PE6, PE7
                                 .equ PORTMUX_USART4_NONE_gc = (0x03<<0)  ; Not connected to any pins
                                 
                                 ; USART5 Signals select
                                 .equ PORTMUX_USART5_DEFAULT_gc = (0x00<<2) ; PG0, PG1, PG2, PG3
                                 .equ PORTMUX_USART5_ALT1_gc = (0x01<<2)  ; PG4, PG5, PG6, PG7
                                 .equ PORTMUX_USART5_NONE_gc = (0x03<<2)  ; Not connected to any pins
                                 
                                 ; Zero Cross Detector 0 Output select
                                 .equ PORTMUX_ZCD0_DEFAULT_gc = (0x00<<0) ; OUT on PA7
                                 .equ PORTMUX_ZCD0_ALT1_gc = (0x01<<0)    ; OUT on PC7
                                 
                                 ; Zero Cross Detector 1 Output select
                                 .equ PORTMUX_ZCD1_DEFAULT_gc = (0x00<<1) ; OUT on PA7
                                 .equ PORTMUX_ZCD1_ALT1_gc = (0x01<<1)    ; OUT on PC7
                                 
                                 ; Zero Cross Detector 2 Output select
                                 .equ PORTMUX_ZCD2_DEFAULT_gc = (0x00<<2) ; OUT on PA7
                                 .equ PORTMUX_ZCD2_ALT1_gc = (0x01<<2)    ; OUT on PC7
                                 
                                 
                                 ;*************************************************************************
                                 ;** RSTCTRL - Reset controller
                                 ;*************************************************************************
                                 
                                 ; RSTCTRL_RSTFR masks
                                 .equ RSTCTRL_BORF_bm = 0x02              ; Brown out detector Reset flag bit mask
                                 .equ RSTCTRL_BORF_bp = 1                 ; Brown out detector Reset flag bit position
                                 .equ RSTCTRL_EXTRF_bm = 0x04             ; External Reset flag bit mask
                                 .equ RSTCTRL_EXTRF_bp = 2                ; External Reset flag bit position
                                 .equ RSTCTRL_PORF_bm = 0x01              ; Power on Reset flag bit mask
                                 .equ RSTCTRL_PORF_bp = 0                 ; Power on Reset flag bit position
                                 .equ RSTCTRL_SWRF_bm = 0x10              ; Software Reset flag bit mask
                                 .equ RSTCTRL_SWRF_bp = 4                 ; Software Reset flag bit position
                                 .equ RSTCTRL_UPDIRF_bm = 0x20            ; UPDI Reset flag bit mask
                                 .equ RSTCTRL_UPDIRF_bp = 5               ; UPDI Reset flag bit position
                                 .equ RSTCTRL_WDRF_bm = 0x08              ; Watch dog Reset flag bit mask
                                 .equ RSTCTRL_WDRF_bp = 3                 ; Watch dog Reset flag bit position
                                 
                                 ; RSTCTRL_SWRR masks
                                 .equ RSTCTRL_SWRST_bm = 0x01             ; Software reset enable bit mask
                                 .equ RSTCTRL_SWRST_bp = 0                ; Software reset enable bit position
                                 
                                 
                                 ;*************************************************************************
                                 ;** RTC - Real-Time Counter
                                 ;*************************************************************************
                                 
                                 ; RTC_CALIB masks
                                 .equ RTC_ERROR_gm = 0x7F                 ; Error Correction Value group mask
                                 .equ RTC_ERROR_gp = 0                    ; Error Correction Value group position
                                 .equ RTC_ERROR0_bm = (1<<0)              ; Error Correction Value bit 0 mask
                                 .equ RTC_ERROR0_bp = 0                   ; Error Correction Value bit 0 position
                                 .equ RTC_ERROR1_bm = (1<<1)              ; Error Correction Value bit 1 mask
                                 .equ RTC_ERROR1_bp = 1                   ; Error Correction Value bit 1 position
                                 .equ RTC_ERROR2_bm = (1<<2)              ; Error Correction Value bit 2 mask
                                 .equ RTC_ERROR2_bp = 2                   ; Error Correction Value bit 2 position
                                 .equ RTC_ERROR3_bm = (1<<3)              ; Error Correction Value bit 3 mask
                                 .equ RTC_ERROR3_bp = 3                   ; Error Correction Value bit 3 position
                                 .equ RTC_ERROR4_bm = (1<<4)              ; Error Correction Value bit 4 mask
                                 .equ RTC_ERROR4_bp = 4                   ; Error Correction Value bit 4 position
                                 .equ RTC_ERROR5_bm = (1<<5)              ; Error Correction Value bit 5 mask
                                 .equ RTC_ERROR5_bp = 5                   ; Error Correction Value bit 5 position
                                 .equ RTC_ERROR6_bm = (1<<6)              ; Error Correction Value bit 6 mask
                                 .equ RTC_ERROR6_bp = 6                   ; Error Correction Value bit 6 position
                                 .equ RTC_SIGN_bm = 0x80                  ; Error Correction Sign Bit bit mask
                                 .equ RTC_SIGN_bp = 7                     ; Error Correction Sign Bit bit position
                                 
                                 ; RTC_CLKSEL masks
                                 .equ RTC_CLKSEL_gm = 0x03                ; Clock Select group mask
                                 .equ RTC_CLKSEL_gp = 0                   ; Clock Select group position
                                 .equ RTC_CLKSEL0_bm = (1<<0)             ; Clock Select bit 0 mask
                                 .equ RTC_CLKSEL0_bp = 0                  ; Clock Select bit 0 position
                                 .equ RTC_CLKSEL1_bm = (1<<1)             ; Clock Select bit 1 mask
                                 .equ RTC_CLKSEL1_bp = 1                  ; Clock Select bit 1 position
                                 
                                 ; RTC_CTRLA masks
                                 .equ RTC_CORREN_bm = 0x04                ; Correction enable bit mask
                                 .equ RTC_CORREN_bp = 2                   ; Correction enable bit position
                                 .equ RTC_PRESCALER_gm = 0x78             ; Prescaling Factor group mask
                                 .equ RTC_PRESCALER_gp = 3                ; Prescaling Factor group position
                                 .equ RTC_PRESCALER0_bm = (1<<3)          ; Prescaling Factor bit 0 mask
                                 .equ RTC_PRESCALER0_bp = 3               ; Prescaling Factor bit 0 position
                                 .equ RTC_PRESCALER1_bm = (1<<4)          ; Prescaling Factor bit 1 mask
                                 .equ RTC_PRESCALER1_bp = 4               ; Prescaling Factor bit 1 position
                                 .equ RTC_PRESCALER2_bm = (1<<5)          ; Prescaling Factor bit 2 mask
                                 .equ RTC_PRESCALER2_bp = 5               ; Prescaling Factor bit 2 position
                                 .equ RTC_PRESCALER3_bm = (1<<6)          ; Prescaling Factor bit 3 mask
                                 .equ RTC_PRESCALER3_bp = 6               ; Prescaling Factor bit 3 position
                                 .equ RTC_RTCEN_bm = 0x01                 ; Enable bit mask
                                 .equ RTC_RTCEN_bp = 0                    ; Enable bit position
                                 .equ RTC_RUNSTDBY_bm = 0x80              ; Run In Standby bit mask
                                 .equ RTC_RUNSTDBY_bp = 7                 ; Run In Standby bit position
                                 
                                 ; RTC_DBGCTRL masks
                                 .equ RTC_DBGRUN_bm = 0x01                ; Run in debug bit mask
                                 .equ RTC_DBGRUN_bp = 0                   ; Run in debug bit position
                                 
                                 ; RTC_INTCTRL masks
                                 .equ RTC_CMP_bm = 0x02                   ; Compare Match Interrupt enable bit mask
                                 .equ RTC_CMP_bp = 1                      ; Compare Match Interrupt enable bit position
                                 .equ RTC_OVF_bm = 0x01                   ; Overflow Interrupt enable bit mask
                                 .equ RTC_OVF_bp = 0                      ; Overflow Interrupt enable bit position
                                 
                                 ; RTC_INTFLAGS masks
                                 ; Masks for RTC_CMP already defined
                                 ; Masks for RTC_OVF already defined
                                 
                                 ; RTC_PITCTRLA masks
                                 .equ RTC_PERIOD_gm = 0x78                ; Period group mask
                                 .equ RTC_PERIOD_gp = 3                   ; Period group position
                                 .equ RTC_PERIOD0_bm = (1<<3)             ; Period bit 0 mask
                                 .equ RTC_PERIOD0_bp = 3                  ; Period bit 0 position
                                 .equ RTC_PERIOD1_bm = (1<<4)             ; Period bit 1 mask
                                 .equ RTC_PERIOD1_bp = 4                  ; Period bit 1 position
                                 .equ RTC_PERIOD2_bm = (1<<5)             ; Period bit 2 mask
                                 .equ RTC_PERIOD2_bp = 5                  ; Period bit 2 position
                                 .equ RTC_PERIOD3_bm = (1<<6)             ; Period bit 3 mask
                                 .equ RTC_PERIOD3_bp = 6                  ; Period bit 3 position
                                 .equ RTC_PITEN_bm = 0x01                 ; Enable bit mask
                                 .equ RTC_PITEN_bp = 0                    ; Enable bit position
                                 
                                 ; RTC_PITDBGCTRL masks
                                 ; Masks for RTC_DBGRUN already defined
                                 
                                 ; RTC_PITINTCTRL masks
                                 .equ RTC_PI_bm = 0x01                    ; Periodic Interrupt bit mask
                                 .equ RTC_PI_bp = 0                       ; Periodic Interrupt bit position
                                 
                                 ; RTC_PITINTFLAGS masks
                                 ; Masks for RTC_PI already defined
                                 
                                 ; RTC_PITSTATUS masks
                                 .equ RTC_CTRLBUSY_bm = 0x01              ; CTRLA Synchronization Busy Flag bit mask
                                 .equ RTC_CTRLBUSY_bp = 0                 ; CTRLA Synchronization Busy Flag bit position
                                 
                                 ; RTC_STATUS masks
                                 .equ RTC_CMPBUSY_bm = 0x08               ; Comparator Synchronization Busy Flag bit mask
                                 .equ RTC_CMPBUSY_bp = 3                  ; Comparator Synchronization Busy Flag bit position
                                 .equ RTC_CNTBUSY_bm = 0x02               ; Count Synchronization Busy Flag bit mask
                                 .equ RTC_CNTBUSY_bp = 1                  ; Count Synchronization Busy Flag bit position
                                 .equ RTC_CTRLABUSY_bm = 0x01             ; CTRLA Synchronization Busy Flag bit mask
                                 .equ RTC_CTRLABUSY_bp = 0                ; CTRLA Synchronization Busy Flag bit position
                                 .equ RTC_PERBUSY_bm = 0x04               ; Period Synchronization Busy Flag bit mask
                                 .equ RTC_PERBUSY_bp = 2                  ; Period Synchronization Busy Flag bit position
                                 
                                 ; Clock Select select
                                 .equ RTC_CLKSEL_OSC32K_gc = (0x00<<0)    ; 32.768 kHz from OSC32K
                                 .equ RTC_CLKSEL_OSC1K_gc = (0x01<<0)     ; 1.024 kHz from OSC32K
                                 .equ RTC_CLKSEL_XOSC32K_gc = (0x02<<0)   ; 32.768 kHz from XOSC32K
                                 .equ RTC_CLKSEL_EXTCLK_gc = (0x03<<0)    ; External Clock
                                 
                                 ; Prescaling Factor select
                                 .equ RTC_PRESCALER_DIV1_gc = (0x00<<3)   ; RTC Clock / 1
                                 .equ RTC_PRESCALER_DIV2_gc = (0x01<<3)   ; RTC Clock / 2
                                 .equ RTC_PRESCALER_DIV4_gc = (0x02<<3)   ; RTC Clock / 4
                                 .equ RTC_PRESCALER_DIV8_gc = (0x03<<3)   ; RTC Clock / 8
                                 .equ RTC_PRESCALER_DIV16_gc = (0x04<<3)  ; RTC Clock / 16
                                 .equ RTC_PRESCALER_DIV32_gc = (0x05<<3)  ; RTC Clock / 32
                                 .equ RTC_PRESCALER_DIV64_gc = (0x06<<3)  ; RTC Clock / 64
                                 .equ RTC_PRESCALER_DIV128_gc = (0x07<<3) ; RTC Clock / 128
                                 .equ RTC_PRESCALER_DIV256_gc = (0x08<<3) ; RTC Clock / 256
                                 .equ RTC_PRESCALER_DIV512_gc = (0x09<<3) ; RTC Clock / 512
                                 .equ RTC_PRESCALER_DIV1024_gc = (0x0A<<3) ; RTC Clock / 1024
                                 .equ RTC_PRESCALER_DIV2048_gc = (0x0B<<3) ; RTC Clock / 2048
                                 .equ RTC_PRESCALER_DIV4096_gc = (0x0C<<3) ; RTC Clock / 4096
                                 .equ RTC_PRESCALER_DIV8192_gc = (0x0D<<3) ; RTC Clock / 8192
                                 .equ RTC_PRESCALER_DIV16384_gc = (0x0E<<3) ; RTC Clock / 16384
                                 .equ RTC_PRESCALER_DIV32768_gc = (0x0F<<3) ; RTC Clock / 32768
                                 
                                 ; Period select
                                 .equ RTC_PERIOD_OFF_gc = (0x00<<3)       ; Off
                                 .equ RTC_PERIOD_CYC4_gc = (0x01<<3)      ; RTC Clock Cycles 4
                                 .equ RTC_PERIOD_CYC8_gc = (0x02<<3)      ; RTC Clock Cycles 8
                                 .equ RTC_PERIOD_CYC16_gc = (0x03<<3)     ; RTC Clock Cycles 16
                                 .equ RTC_PERIOD_CYC32_gc = (0x04<<3)     ; RTC Clock Cycles 32
                                 .equ RTC_PERIOD_CYC64_gc = (0x05<<3)     ; RTC Clock Cycles 64
                                 .equ RTC_PERIOD_CYC128_gc = (0x06<<3)    ; RTC Clock Cycles 128
                                 .equ RTC_PERIOD_CYC256_gc = (0x07<<3)    ; RTC Clock Cycles 256
                                 .equ RTC_PERIOD_CYC512_gc = (0x08<<3)    ; RTC Clock Cycles 512
                                 .equ RTC_PERIOD_CYC1024_gc = (0x09<<3)   ; RTC Clock Cycles 1024
                                 .equ RTC_PERIOD_CYC2048_gc = (0x0A<<3)   ; RTC Clock Cycles 2048
                                 .equ RTC_PERIOD_CYC4096_gc = (0x0B<<3)   ; RTC Clock Cycles 4096
                                 .equ RTC_PERIOD_CYC8192_gc = (0x0C<<3)   ; RTC Clock Cycles 8192
                                 .equ RTC_PERIOD_CYC16384_gc = (0x0D<<3)  ; RTC Clock Cycles 16384
                                 .equ RTC_PERIOD_CYC32768_gc = (0x0E<<3)  ; RTC Clock Cycles 32768
                                 
                                 
                                 ;*************************************************************************
                                 ;** SIGROW - Signature row
                                 ;*************************************************************************
                                 
                                 ; SIGROW_TEMPSENSE0 masks
                                 .equ SIGROW_TEMPSENSE0_gm = 0xFFFF       ; Temperature Calibration 0 group mask
                                 .equ SIGROW_TEMPSENSE0_gp = 0            ; Temperature Calibration 0 group position
                                 .equ SIGROW_TEMPSENSE00_bm = (1<<0)      ; Temperature Calibration 0 bit 0 mask
                                 .equ SIGROW_TEMPSENSE00_bp = 0           ; Temperature Calibration 0 bit 0 position
                                 .equ SIGROW_TEMPSENSE01_bm = (1<<1)      ; Temperature Calibration 0 bit 1 mask
                                 .equ SIGROW_TEMPSENSE01_bp = 1           ; Temperature Calibration 0 bit 1 position
                                 .equ SIGROW_TEMPSENSE02_bm = (1<<2)      ; Temperature Calibration 0 bit 2 mask
                                 .equ SIGROW_TEMPSENSE02_bp = 2           ; Temperature Calibration 0 bit 2 position
                                 .equ SIGROW_TEMPSENSE03_bm = (1<<3)      ; Temperature Calibration 0 bit 3 mask
                                 .equ SIGROW_TEMPSENSE03_bp = 3           ; Temperature Calibration 0 bit 3 position
                                 .equ SIGROW_TEMPSENSE04_bm = (1<<4)      ; Temperature Calibration 0 bit 4 mask
                                 .equ SIGROW_TEMPSENSE04_bp = 4           ; Temperature Calibration 0 bit 4 position
                                 .equ SIGROW_TEMPSENSE05_bm = (1<<5)      ; Temperature Calibration 0 bit 5 mask
                                 .equ SIGROW_TEMPSENSE05_bp = 5           ; Temperature Calibration 0 bit 5 position
                                 .equ SIGROW_TEMPSENSE06_bm = (1<<6)      ; Temperature Calibration 0 bit 6 mask
                                 .equ SIGROW_TEMPSENSE06_bp = 6           ; Temperature Calibration 0 bit 6 position
                                 .equ SIGROW_TEMPSENSE07_bm = (1<<7)      ; Temperature Calibration 0 bit 7 mask
                                 .equ SIGROW_TEMPSENSE07_bp = 7           ; Temperature Calibration 0 bit 7 position
                                 .equ SIGROW_TEMPSENSE08_bm = (1<<8)      ; Temperature Calibration 0 bit 8 mask
                                 .equ SIGROW_TEMPSENSE08_bp = 8           ; Temperature Calibration 0 bit 8 position
                                 .equ SIGROW_TEMPSENSE09_bm = (1<<9)      ; Temperature Calibration 0 bit 9 mask
                                 .equ SIGROW_TEMPSENSE09_bp = 9           ; Temperature Calibration 0 bit 9 position
                                 .equ SIGROW_TEMPSENSE010_bm = (1<<10)    ; Temperature Calibration 0 bit 10 mask
                                 .equ SIGROW_TEMPSENSE010_bp = 10         ; Temperature Calibration 0 bit 10 position
                                 .equ SIGROW_TEMPSENSE011_bm = (1<<11)    ; Temperature Calibration 0 bit 11 mask
                                 .equ SIGROW_TEMPSENSE011_bp = 11         ; Temperature Calibration 0 bit 11 position
                                 .equ SIGROW_TEMPSENSE012_bm = (1<<12)    ; Temperature Calibration 0 bit 12 mask
                                 .equ SIGROW_TEMPSENSE012_bp = 12         ; Temperature Calibration 0 bit 12 position
                                 .equ SIGROW_TEMPSENSE013_bm = (1<<13)    ; Temperature Calibration 0 bit 13 mask
                                 .equ SIGROW_TEMPSENSE013_bp = 13         ; Temperature Calibration 0 bit 13 position
                                 .equ SIGROW_TEMPSENSE014_bm = (1<<14)    ; Temperature Calibration 0 bit 14 mask
                                 .equ SIGROW_TEMPSENSE014_bp = 14         ; Temperature Calibration 0 bit 14 position
                                 .equ SIGROW_TEMPSENSE015_bm = (1<<15)    ; Temperature Calibration 0 bit 15 mask
                                 .equ SIGROW_TEMPSENSE015_bp = 15         ; Temperature Calibration 0 bit 15 position
                                 
                                 ; SIGROW_TEMPSENSE1 masks
                                 .equ SIGROW_TEMPSENSE1_gm = 0xFFFF       ; Temperature Calibration 1 group mask
                                 .equ SIGROW_TEMPSENSE1_gp = 0            ; Temperature Calibration 1 group position
                                 .equ SIGROW_TEMPSENSE10_bm = (1<<0)      ; Temperature Calibration 1 bit 0 mask
                                 .equ SIGROW_TEMPSENSE10_bp = 0           ; Temperature Calibration 1 bit 0 position
                                 .equ SIGROW_TEMPSENSE11_bm = (1<<1)      ; Temperature Calibration 1 bit 1 mask
                                 .equ SIGROW_TEMPSENSE11_bp = 1           ; Temperature Calibration 1 bit 1 position
                                 .equ SIGROW_TEMPSENSE12_bm = (1<<2)      ; Temperature Calibration 1 bit 2 mask
                                 .equ SIGROW_TEMPSENSE12_bp = 2           ; Temperature Calibration 1 bit 2 position
                                 .equ SIGROW_TEMPSENSE13_bm = (1<<3)      ; Temperature Calibration 1 bit 3 mask
                                 .equ SIGROW_TEMPSENSE13_bp = 3           ; Temperature Calibration 1 bit 3 position
                                 .equ SIGROW_TEMPSENSE14_bm = (1<<4)      ; Temperature Calibration 1 bit 4 mask
                                 .equ SIGROW_TEMPSENSE14_bp = 4           ; Temperature Calibration 1 bit 4 position
                                 .equ SIGROW_TEMPSENSE15_bm = (1<<5)      ; Temperature Calibration 1 bit 5 mask
                                 .equ SIGROW_TEMPSENSE15_bp = 5           ; Temperature Calibration 1 bit 5 position
                                 .equ SIGROW_TEMPSENSE16_bm = (1<<6)      ; Temperature Calibration 1 bit 6 mask
                                 .equ SIGROW_TEMPSENSE16_bp = 6           ; Temperature Calibration 1 bit 6 position
                                 .equ SIGROW_TEMPSENSE17_bm = (1<<7)      ; Temperature Calibration 1 bit 7 mask
                                 .equ SIGROW_TEMPSENSE17_bp = 7           ; Temperature Calibration 1 bit 7 position
                                 .equ SIGROW_TEMPSENSE18_bm = (1<<8)      ; Temperature Calibration 1 bit 8 mask
                                 .equ SIGROW_TEMPSENSE18_bp = 8           ; Temperature Calibration 1 bit 8 position
                                 .equ SIGROW_TEMPSENSE19_bm = (1<<9)      ; Temperature Calibration 1 bit 9 mask
                                 .equ SIGROW_TEMPSENSE19_bp = 9           ; Temperature Calibration 1 bit 9 position
                                 .equ SIGROW_TEMPSENSE110_bm = (1<<10)    ; Temperature Calibration 1 bit 10 mask
                                 .equ SIGROW_TEMPSENSE110_bp = 10         ; Temperature Calibration 1 bit 10 position
                                 .equ SIGROW_TEMPSENSE111_bm = (1<<11)    ; Temperature Calibration 1 bit 11 mask
                                 .equ SIGROW_TEMPSENSE111_bp = 11         ; Temperature Calibration 1 bit 11 position
                                 .equ SIGROW_TEMPSENSE112_bm = (1<<12)    ; Temperature Calibration 1 bit 12 mask
                                 .equ SIGROW_TEMPSENSE112_bp = 12         ; Temperature Calibration 1 bit 12 position
                                 .equ SIGROW_TEMPSENSE113_bm = (1<<13)    ; Temperature Calibration 1 bit 13 mask
                                 .equ SIGROW_TEMPSENSE113_bp = 13         ; Temperature Calibration 1 bit 13 position
                                 .equ SIGROW_TEMPSENSE114_bm = (1<<14)    ; Temperature Calibration 1 bit 14 mask
                                 .equ SIGROW_TEMPSENSE114_bp = 14         ; Temperature Calibration 1 bit 14 position
                                 .equ SIGROW_TEMPSENSE115_bm = (1<<15)    ; Temperature Calibration 1 bit 15 mask
                                 .equ SIGROW_TEMPSENSE115_bp = 15         ; Temperature Calibration 1 bit 15 position
                                 
                                 
                                 ;*************************************************************************
                                 ;** SLPCTRL - Sleep Controller
                                 ;*************************************************************************
                                 
                                 ; SLPCTRL_CTRLA masks
                                 .equ SLPCTRL_SEN_bm = 0x01               ; Sleep enable bit mask
                                 .equ SLPCTRL_SEN_bp = 0                  ; Sleep enable bit position
                                 .equ SLPCTRL_SMODE_gm = 0x06             ; Sleep mode group mask
                                 .equ SLPCTRL_SMODE_gp = 1                ; Sleep mode group position
                                 .equ SLPCTRL_SMODE0_bm = (1<<1)          ; Sleep mode bit 0 mask
                                 .equ SLPCTRL_SMODE0_bp = 1               ; Sleep mode bit 0 position
                                 .equ SLPCTRL_SMODE1_bm = (1<<2)          ; Sleep mode bit 1 mask
                                 .equ SLPCTRL_SMODE1_bp = 2               ; Sleep mode bit 1 position
                                 
                                 ; SLPCTRL_VREGCTRL masks
                                 .equ SLPCTRL_HTLLEN_bm = 0x10            ; High Temperature Low Leakage Enable bit mask
                                 .equ SLPCTRL_HTLLEN_bp = 4               ; High Temperature Low Leakage Enable bit position
                                 .equ SLPCTRL_PMODE_gm = 0x07             ; Performance Mode group mask
                                 .equ SLPCTRL_PMODE_gp = 0                ; Performance Mode group position
                                 .equ SLPCTRL_PMODE0_bm = (1<<0)          ; Performance Mode bit 0 mask
                                 .equ SLPCTRL_PMODE0_bp = 0               ; Performance Mode bit 0 position
                                 .equ SLPCTRL_PMODE1_bm = (1<<1)          ; Performance Mode bit 1 mask
                                 .equ SLPCTRL_PMODE1_bp = 1               ; Performance Mode bit 1 position
                                 .equ SLPCTRL_PMODE2_bm = (1<<2)          ; Performance Mode bit 2 mask
                                 .equ SLPCTRL_PMODE2_bp = 2               ; Performance Mode bit 2 position
                                 
                                 ; Sleep mode select
                                 .equ SLPCTRL_SMODE_IDLE_gc = (0x00<<1)   ; Idle mode
                                 .equ SLPCTRL_SMODE_STDBY_gc = (0x01<<1)  ; Standby Mode
                                 .equ SLPCTRL_SMODE_PDOWN_gc = (0x02<<1)  ; Power-down Mode
                                 
                                 ; High Temperature Low Leakage Enable select
                                 .equ SLPCTRL_HTLLEN_OFF_gc = (0x00<<4)   ; Disabled
                                 .equ SLPCTRL_HTLLEN_ON_gc = (0x01<<4)    ; Enabled
                                 
                                 ; Performance Mode select
                                 .equ SLPCTRL_PMODE_AUTO_gc = (0x00<<0)   ; 
                                 .equ SLPCTRL_PMODE_FULL_gc = (0x01<<0)   ; 
                                 
                                 
                                 ;*************************************************************************
                                 ;** SPI - Serial Peripheral Interface
                                 ;*************************************************************************
                                 
                                 ; SPI_CTRLA masks
                                 .equ SPI_CLK2X_bm = 0x10                 ; Enable Double Speed bit mask
                                 .equ SPI_CLK2X_bp = 4                    ; Enable Double Speed bit position
                                 .equ SPI_DORD_bm = 0x40                  ; Data Order Setting bit mask
                                 .equ SPI_DORD_bp = 6                     ; Data Order Setting bit position
                                 .equ SPI_ENABLE_bm = 0x01                ; Enable Module bit mask
                                 .equ SPI_ENABLE_bp = 0                   ; Enable Module bit position
                                 .equ SPI_MASTER_bm = 0x20                ; Host Operation Enable bit mask
                                 .equ SPI_MASTER_bp = 5                   ; Host Operation Enable bit position
                                 .equ SPI_PRESC_gm = 0x06                 ; Prescaler group mask
                                 .equ SPI_PRESC_gp = 1                    ; Prescaler group position
                                 .equ SPI_PRESC0_bm = (1<<1)              ; Prescaler bit 0 mask
                                 .equ SPI_PRESC0_bp = 1                   ; Prescaler bit 0 position
                                 .equ SPI_PRESC1_bm = (1<<2)              ; Prescaler bit 1 mask
                                 .equ SPI_PRESC1_bp = 2                   ; Prescaler bit 1 position
                                 
                                 ; SPI_CTRLB masks
                                 .equ SPI_BUFEN_bm = 0x80                 ; Buffer Mode Enable bit mask
                                 .equ SPI_BUFEN_bp = 7                    ; Buffer Mode Enable bit position
                                 .equ SPI_BUFWR_bm = 0x40                 ; Buffer Mode Wait for Receive bit mask
                                 .equ SPI_BUFWR_bp = 6                    ; Buffer Mode Wait for Receive bit position
                                 .equ SPI_MODE_gm = 0x03                  ; SPI Mode group mask
                                 .equ SPI_MODE_gp = 0                     ; SPI Mode group position
                                 .equ SPI_MODE0_bm = (1<<0)               ; SPI Mode bit 0 mask
                                 .equ SPI_MODE0_bp = 0                    ; SPI Mode bit 0 position
                                 .equ SPI_MODE1_bm = (1<<1)               ; SPI Mode bit 1 mask
                                 .equ SPI_MODE1_bp = 1                    ; SPI Mode bit 1 position
                                 .equ SPI_SSD_bm = 0x04                   ; SPI Select Disable bit mask
                                 .equ SPI_SSD_bp = 2                      ; SPI Select Disable bit position
                                 
                                 ; SPI_INTCTRL masks
                                 .equ SPI_DREIE_bm = 0x20                 ; Data Register Empty Interrupt Enable bit mask
                                 .equ SPI_DREIE_bp = 5                    ; Data Register Empty Interrupt Enable bit position
                                 .equ SPI_IE_bm = 0x01                    ; Interrupt Enable bit mask
                                 .equ SPI_IE_bp = 0                       ; Interrupt Enable bit position
                                 .equ SPI_RXCIE_bm = 0x80                 ; Receive Complete Interrupt Enable bit mask
                                 .equ SPI_RXCIE_bp = 7                    ; Receive Complete Interrupt Enable bit position
                                 .equ SPI_SSIE_bm = 0x10                  ; SPI Select Trigger Interrupt Enable bit mask
                                 .equ SPI_SSIE_bp = 4                     ; SPI Select Trigger Interrupt Enable bit position
                                 .equ SPI_TXCIE_bm = 0x40                 ; Transfer Complete Interrupt Enable bit mask
                                 .equ SPI_TXCIE_bp = 6                    ; Transfer Complete Interrupt Enable bit position
                                 
                                 ; SPI_INTFLAGS masks
                                 .equ SPI_BUFOVF_bm = 0x01                ; Buffer Overflow bit mask
                                 .equ SPI_BUFOVF_bp = 0                   ; Buffer Overflow bit position
                                 .equ SPI_DREIF_bm = 0x20                 ; Data Register Empty Interrupt Flag bit mask
                                 .equ SPI_DREIF_bp = 5                    ; Data Register Empty Interrupt Flag bit position
                                 .equ SPI_RXCIF_bm = 0x80                 ; Receive Complete Interrupt Flag bit mask
                                 .equ SPI_RXCIF_bp = 7                    ; Receive Complete Interrupt Flag bit position
                                 .equ SPI_SSIF_bm = 0x10                  ; SPI Select Trigger Interrupt Flag bit mask
                                 .equ SPI_SSIF_bp = 4                     ; SPI Select Trigger Interrupt Flag bit position
                                 .equ SPI_TXCIF_bm = 0x40                 ; Transfer Complete Interrupt Flag bit mask
                                 .equ SPI_TXCIF_bp = 6                    ; Transfer Complete Interrupt Flag bit position
                                 .equ SPI_IF_bm = 0x80                    ; Interrupt Flag bit mask
                                 .equ SPI_IF_bp = 7                       ; Interrupt Flag bit position
                                 .equ SPI_WRCOL_bm = 0x40                 ; Write Collision bit mask
                                 .equ SPI_WRCOL_bp = 6                    ; Write Collision bit position
                                 
                                 ; Prescaler select
                                 .equ SPI_PRESC_DIV4_gc = (0x00<<1)       ; System Clock / 4
                                 .equ SPI_PRESC_DIV16_gc = (0x01<<1)      ; System Clock / 16
                                 .equ SPI_PRESC_DIV64_gc = (0x02<<1)      ; System Clock / 64
                                 .equ SPI_PRESC_DIV128_gc = (0x03<<1)     ; System Clock / 128
                                 
                                 ; SPI Mode select
                                 .equ SPI_MODE_0_gc = (0x00<<0)           ; SPI Mode 0
                                 .equ SPI_MODE_1_gc = (0x01<<0)           ; SPI Mode 1
                                 .equ SPI_MODE_2_gc = (0x02<<0)           ; SPI Mode 2
                                 .equ SPI_MODE_3_gc = (0x03<<0)           ; SPI Mode 3
                                 
                                 
                                 ;*************************************************************************
                                 ;** SYSCFG - System Configuration Registers
                                 ;*************************************************************************
                                 
                                 ; SYSCFG_OCDMSTATUS masks
                                 .equ SYSCFG_OCDMR_bm = 0x01              ; OCD Message Read bit mask
                                 .equ SYSCFG_OCDMR_bp = 0                 ; OCD Message Read bit position
                                 
                                 
                                 ;*************************************************************************
                                 ;** TCA - 16-bit Timer/Counter Type A
                                 ;*************************************************************************
                                 
                                 ; TCA_SINGLE_CTRLA masks
                                 .equ TCA_SINGLE_CLKSEL_gm = 0x0E         ; Clock Selection group mask
                                 .equ TCA_SINGLE_CLKSEL_gp = 1            ; Clock Selection group position
                                 .equ TCA_SINGLE_CLKSEL0_bm = (1<<1)      ; Clock Selection bit 0 mask
                                 .equ TCA_SINGLE_CLKSEL0_bp = 1           ; Clock Selection bit 0 position
                                 .equ TCA_SINGLE_CLKSEL1_bm = (1<<2)      ; Clock Selection bit 1 mask
                                 .equ TCA_SINGLE_CLKSEL1_bp = 2           ; Clock Selection bit 1 position
                                 .equ TCA_SINGLE_CLKSEL2_bm = (1<<3)      ; Clock Selection bit 2 mask
                                 .equ TCA_SINGLE_CLKSEL2_bp = 3           ; Clock Selection bit 2 position
                                 .equ TCA_SINGLE_ENABLE_bm = 0x01         ; Module Enable bit mask
                                 .equ TCA_SINGLE_ENABLE_bp = 0            ; Module Enable bit position
                                 .equ TCA_SINGLE_RUNSTDBY_bm = 0x80       ; Run in Standby bit mask
                                 .equ TCA_SINGLE_RUNSTDBY_bp = 7          ; Run in Standby bit position
                                 
                                 ; TCA_SINGLE_CTRLB masks
                                 .equ TCA_SINGLE_ALUPD_bm = 0x08          ; Auto Lock Update bit mask
                                 .equ TCA_SINGLE_ALUPD_bp = 3             ; Auto Lock Update bit position
                                 .equ TCA_SINGLE_CMP0EN_bm = 0x10         ; Compare 0 Enable bit mask
                                 .equ TCA_SINGLE_CMP0EN_bp = 4            ; Compare 0 Enable bit position
                                 .equ TCA_SINGLE_CMP1EN_bm = 0x20         ; Compare 1 Enable bit mask
                                 .equ TCA_SINGLE_CMP1EN_bp = 5            ; Compare 1 Enable bit position
                                 .equ TCA_SINGLE_CMP2EN_bm = 0x40         ; Compare 2 Enable bit mask
                                 .equ TCA_SINGLE_CMP2EN_bp = 6            ; Compare 2 Enable bit position
                                 .equ TCA_SINGLE_WGMODE_gm = 0x07         ; Waveform generation mode group mask
                                 .equ TCA_SINGLE_WGMODE_gp = 0            ; Waveform generation mode group position
                                 .equ TCA_SINGLE_WGMODE0_bm = (1<<0)      ; Waveform generation mode bit 0 mask
                                 .equ TCA_SINGLE_WGMODE0_bp = 0           ; Waveform generation mode bit 0 position
                                 .equ TCA_SINGLE_WGMODE1_bm = (1<<1)      ; Waveform generation mode bit 1 mask
                                 .equ TCA_SINGLE_WGMODE1_bp = 1           ; Waveform generation mode bit 1 position
                                 .equ TCA_SINGLE_WGMODE2_bm = (1<<2)      ; Waveform generation mode bit 2 mask
                                 .equ TCA_SINGLE_WGMODE2_bp = 2           ; Waveform generation mode bit 2 position
                                 
                                 ; TCA_SINGLE_CTRLC masks
                                 .equ TCA_SINGLE_CMP0OV_bm = 0x01         ; Compare 0 Waveform Output Value bit mask
                                 .equ TCA_SINGLE_CMP0OV_bp = 0            ; Compare 0 Waveform Output Value bit position
                                 .equ TCA_SINGLE_CMP1OV_bm = 0x02         ; Compare 1 Waveform Output Value bit mask
                                 .equ TCA_SINGLE_CMP1OV_bp = 1            ; Compare 1 Waveform Output Value bit position
                                 .equ TCA_SINGLE_CMP2OV_bm = 0x04         ; Compare 2 Waveform Output Value bit mask
                                 .equ TCA_SINGLE_CMP2OV_bp = 2            ; Compare 2 Waveform Output Value bit position
                                 
                                 ; TCA_SINGLE_CTRLD masks
                                 .equ TCA_SINGLE_SPLITM_bm = 0x01         ; Split Mode Enable bit mask
                                 .equ TCA_SINGLE_SPLITM_bp = 0            ; Split Mode Enable bit position
                                 
                                 ; TCA_SINGLE_CTRLECLR masks
                                 .equ TCA_SINGLE_CMD_gm = 0x0C            ; Command group mask
                                 .equ TCA_SINGLE_CMD_gp = 2               ; Command group position
                                 .equ TCA_SINGLE_CMD0_bm = (1<<2)         ; Command bit 0 mask
                                 .equ TCA_SINGLE_CMD0_bp = 2              ; Command bit 0 position
                                 .equ TCA_SINGLE_CMD1_bm = (1<<3)         ; Command bit 1 mask
                                 .equ TCA_SINGLE_CMD1_bp = 3              ; Command bit 1 position
                                 .equ TCA_SINGLE_DIR_bm = 0x01            ; Direction bit mask
                                 .equ TCA_SINGLE_DIR_bp = 0               ; Direction bit position
                                 .equ TCA_SINGLE_LUPD_bm = 0x02           ; Lock Update bit mask
                                 .equ TCA_SINGLE_LUPD_bp = 1              ; Lock Update bit position
                                 
                                 ; TCA_SINGLE_CTRLESET masks
                                 ; Masks for TCA_SINGLE_CMD already defined
                                 ; Masks for TCA_SINGLE_DIR already defined
                                 ; Masks for TCA_SINGLE_LUPD already defined
                                 
                                 ; TCA_SINGLE_CTRLFCLR masks
                                 .equ TCA_SINGLE_CMP0BV_bm = 0x02         ; Compare 0 Buffer Valid bit mask
                                 .equ TCA_SINGLE_CMP0BV_bp = 1            ; Compare 0 Buffer Valid bit position
                                 .equ TCA_SINGLE_CMP1BV_bm = 0x04         ; Compare 1 Buffer Valid bit mask
                                 .equ TCA_SINGLE_CMP1BV_bp = 2            ; Compare 1 Buffer Valid bit position
                                 .equ TCA_SINGLE_CMP2BV_bm = 0x08         ; Compare 2 Buffer Valid bit mask
                                 .equ TCA_SINGLE_CMP2BV_bp = 3            ; Compare 2 Buffer Valid bit position
                                 .equ TCA_SINGLE_PERBV_bm = 0x01          ; Period Buffer Valid bit mask
                                 .equ TCA_SINGLE_PERBV_bp = 0             ; Period Buffer Valid bit position
                                 
                                 ; TCA_SINGLE_CTRLFSET masks
                                 ; Masks for TCA_SINGLE_CMP0BV already defined
                                 ; Masks for TCA_SINGLE_CMP1BV already defined
                                 ; Masks for TCA_SINGLE_CMP2BV already defined
                                 ; Masks for TCA_SINGLE_PERBV already defined
                                 
                                 ; TCA_SINGLE_DBGCTRL masks
                                 .equ TCA_SINGLE_DBGRUN_bm = 0x01         ; Debug Run bit mask
                                 .equ TCA_SINGLE_DBGRUN_bp = 0            ; Debug Run bit position
                                 
                                 ; TCA_SINGLE_EVCTRL masks
                                 .equ TCA_SINGLE_CNTAEI_bm = 0x01         ; Count on Event Input A bit mask
                                 .equ TCA_SINGLE_CNTAEI_bp = 0            ; Count on Event Input A bit position
                                 .equ TCA_SINGLE_CNTBEI_bm = 0x10         ; Count on Event Input B bit mask
                                 .equ TCA_SINGLE_CNTBEI_bp = 4            ; Count on Event Input B bit position
                                 .equ TCA_SINGLE_EVACTA_gm = 0x0E         ; Event Action A group mask
                                 .equ TCA_SINGLE_EVACTA_gp = 1            ; Event Action A group position
                                 .equ TCA_SINGLE_EVACTA0_bm = (1<<1)      ; Event Action A bit 0 mask
                                 .equ TCA_SINGLE_EVACTA0_bp = 1           ; Event Action A bit 0 position
                                 .equ TCA_SINGLE_EVACTA1_bm = (1<<2)      ; Event Action A bit 1 mask
                                 .equ TCA_SINGLE_EVACTA1_bp = 2           ; Event Action A bit 1 position
                                 .equ TCA_SINGLE_EVACTA2_bm = (1<<3)      ; Event Action A bit 2 mask
                                 .equ TCA_SINGLE_EVACTA2_bp = 3           ; Event Action A bit 2 position
                                 .equ TCA_SINGLE_EVACTB_gm = 0xE0         ; Event Action B group mask
                                 .equ TCA_SINGLE_EVACTB_gp = 5            ; Event Action B group position
                                 .equ TCA_SINGLE_EVACTB0_bm = (1<<5)      ; Event Action B bit 0 mask
                                 .equ TCA_SINGLE_EVACTB0_bp = 5           ; Event Action B bit 0 position
                                 .equ TCA_SINGLE_EVACTB1_bm = (1<<6)      ; Event Action B bit 1 mask
                                 .equ TCA_SINGLE_EVACTB1_bp = 6           ; Event Action B bit 1 position
                                 .equ TCA_SINGLE_EVACTB2_bm = (1<<7)      ; Event Action B bit 2 mask
                                 .equ TCA_SINGLE_EVACTB2_bp = 7           ; Event Action B bit 2 position
                                 
                                 ; TCA_SINGLE_INTCTRL masks
                                 .equ TCA_SINGLE_CMP0_bm = 0x10           ; Compare 0 Interrupt bit mask
                                 .equ TCA_SINGLE_CMP0_bp = 4              ; Compare 0 Interrupt bit position
                                 .equ TCA_SINGLE_CMP1_bm = 0x20           ; Compare 1 Interrupt bit mask
                                 .equ TCA_SINGLE_CMP1_bp = 5              ; Compare 1 Interrupt bit position
                                 .equ TCA_SINGLE_CMP2_bm = 0x40           ; Compare 2 Interrupt bit mask
                                 .equ TCA_SINGLE_CMP2_bp = 6              ; Compare 2 Interrupt bit position
                                 .equ TCA_SINGLE_OVF_bm = 0x01            ; Overflow Interrupt bit mask
                                 .equ TCA_SINGLE_OVF_bp = 0               ; Overflow Interrupt bit position
                                 
                                 ; TCA_SINGLE_INTFLAGS masks
                                 ; Masks for TCA_SINGLE_CMP0 already defined
                                 ; Masks for TCA_SINGLE_CMP1 already defined
                                 ; Masks for TCA_SINGLE_CMP2 already defined
                                 ; Masks for TCA_SINGLE_OVF already defined
                                 
                                 ; TCA_SPLIT_CTRLA masks
                                 .equ TCA_SPLIT_CLKSEL_gm = 0x0E          ; Clock Selection group mask
                                 .equ TCA_SPLIT_CLKSEL_gp = 1             ; Clock Selection group position
                                 .equ TCA_SPLIT_CLKSEL0_bm = (1<<1)       ; Clock Selection bit 0 mask
                                 .equ TCA_SPLIT_CLKSEL0_bp = 1            ; Clock Selection bit 0 position
                                 .equ TCA_SPLIT_CLKSEL1_bm = (1<<2)       ; Clock Selection bit 1 mask
                                 .equ TCA_SPLIT_CLKSEL1_bp = 2            ; Clock Selection bit 1 position
                                 .equ TCA_SPLIT_CLKSEL2_bm = (1<<3)       ; Clock Selection bit 2 mask
                                 .equ TCA_SPLIT_CLKSEL2_bp = 3            ; Clock Selection bit 2 position
                                 .equ TCA_SPLIT_ENABLE_bm = 0x01          ; Module Enable bit mask
                                 .equ TCA_SPLIT_ENABLE_bp = 0             ; Module Enable bit position
                                 .equ TCA_SPLIT_RUNSTDBY_bm = 0x80        ; Run in Standby bit mask
                                 .equ TCA_SPLIT_RUNSTDBY_bp = 7           ; Run in Standby bit position
                                 
                                 ; TCA_SPLIT_CTRLB masks
                                 .equ TCA_SPLIT_HCMP0EN_bm = 0x10         ; High Compare 0 Enable bit mask
                                 .equ TCA_SPLIT_HCMP0EN_bp = 4            ; High Compare 0 Enable bit position
                                 .equ TCA_SPLIT_HCMP1EN_bm = 0x20         ; High Compare 1 Enable bit mask
                                 .equ TCA_SPLIT_HCMP1EN_bp = 5            ; High Compare 1 Enable bit position
                                 .equ TCA_SPLIT_HCMP2EN_bm = 0x40         ; High Compare 2 Enable bit mask
                                 .equ TCA_SPLIT_HCMP2EN_bp = 6            ; High Compare 2 Enable bit position
                                 .equ TCA_SPLIT_LCMP0EN_bm = 0x01         ; Low Compare 0 Enable bit mask
                                 .equ TCA_SPLIT_LCMP0EN_bp = 0            ; Low Compare 0 Enable bit position
                                 .equ TCA_SPLIT_LCMP1EN_bm = 0x02         ; Low Compare 1 Enable bit mask
                                 .equ TCA_SPLIT_LCMP1EN_bp = 1            ; Low Compare 1 Enable bit position
                                 .equ TCA_SPLIT_LCMP2EN_bm = 0x04         ; Low Compare 2 Enable bit mask
                                 .equ TCA_SPLIT_LCMP2EN_bp = 2            ; Low Compare 2 Enable bit position
                                 
                                 ; TCA_SPLIT_CTRLC masks
                                 .equ TCA_SPLIT_HCMP0OV_bm = 0x10         ; High Compare 0 Output Value bit mask
                                 .equ TCA_SPLIT_HCMP0OV_bp = 4            ; High Compare 0 Output Value bit position
                                 .equ TCA_SPLIT_HCMP1OV_bm = 0x20         ; High Compare 1 Output Value bit mask
                                 .equ TCA_SPLIT_HCMP1OV_bp = 5            ; High Compare 1 Output Value bit position
                                 .equ TCA_SPLIT_HCMP2OV_bm = 0x40         ; High Compare 2 Output Value bit mask
                                 .equ TCA_SPLIT_HCMP2OV_bp = 6            ; High Compare 2 Output Value bit position
                                 .equ TCA_SPLIT_LCMP0OV_bm = 0x01         ; Low Compare 0 Output Value bit mask
                                 .equ TCA_SPLIT_LCMP0OV_bp = 0            ; Low Compare 0 Output Value bit position
                                 .equ TCA_SPLIT_LCMP1OV_bm = 0x02         ; Low Compare 1 Output Value bit mask
                                 .equ TCA_SPLIT_LCMP1OV_bp = 1            ; Low Compare 1 Output Value bit position
                                 .equ TCA_SPLIT_LCMP2OV_bm = 0x04         ; Low Compare 2 Output Value bit mask
                                 .equ TCA_SPLIT_LCMP2OV_bp = 2            ; Low Compare 2 Output Value bit position
                                 
                                 ; TCA_SPLIT_CTRLD masks
                                 .equ TCA_SPLIT_SPLITM_bm = 0x01          ; Split Mode Enable bit mask
                                 .equ TCA_SPLIT_SPLITM_bp = 0             ; Split Mode Enable bit position
                                 
                                 ; TCA_SPLIT_CTRLECLR masks
                                 .equ TCA_SPLIT_CMD_gm = 0x0C             ; Command group mask
                                 .equ TCA_SPLIT_CMD_gp = 2                ; Command group position
                                 .equ TCA_SPLIT_CMD0_bm = (1<<2)          ; Command bit 0 mask
                                 .equ TCA_SPLIT_CMD0_bp = 2               ; Command bit 0 position
                                 .equ TCA_SPLIT_CMD1_bm = (1<<3)          ; Command bit 1 mask
                                 .equ TCA_SPLIT_CMD1_bp = 3               ; Command bit 1 position
                                 .equ TCA_SPLIT_CMDEN_gm = 0x03           ; Command Enable group mask
                                 .equ TCA_SPLIT_CMDEN_gp = 0              ; Command Enable group position
                                 .equ TCA_SPLIT_CMDEN0_bm = (1<<0)        ; Command Enable bit 0 mask
                                 .equ TCA_SPLIT_CMDEN0_bp = 0             ; Command Enable bit 0 position
                                 .equ TCA_SPLIT_CMDEN1_bm = (1<<1)        ; Command Enable bit 1 mask
                                 .equ TCA_SPLIT_CMDEN1_bp = 1             ; Command Enable bit 1 position
                                 
                                 ; TCA_SPLIT_CTRLESET masks
                                 ; Masks for TCA_SPLIT_CMD already defined
                                 ; Masks for TCA_SPLIT_CMDEN already defined
                                 
                                 ; TCA_SPLIT_DBGCTRL masks
                                 .equ TCA_SPLIT_DBGRUN_bm = 0x01          ; Debug Run bit mask
                                 .equ TCA_SPLIT_DBGRUN_bp = 0             ; Debug Run bit position
                                 
                                 ; TCA_SPLIT_INTCTRL masks
                                 .equ TCA_SPLIT_HUNF_bm = 0x02            ; High Underflow Interrupt Enable bit mask
                                 .equ TCA_SPLIT_HUNF_bp = 1               ; High Underflow Interrupt Enable bit position
                                 .equ TCA_SPLIT_LCMP0_bm = 0x10           ; Low Compare 0 Interrupt Enable bit mask
                                 .equ TCA_SPLIT_LCMP0_bp = 4              ; Low Compare 0 Interrupt Enable bit position
                                 .equ TCA_SPLIT_LCMP1_bm = 0x20           ; Low Compare 1 Interrupt Enable bit mask
                                 .equ TCA_SPLIT_LCMP1_bp = 5              ; Low Compare 1 Interrupt Enable bit position
                                 .equ TCA_SPLIT_LCMP2_bm = 0x40           ; Low Compare 2 Interrupt Enable bit mask
                                 .equ TCA_SPLIT_LCMP2_bp = 6              ; Low Compare 2 Interrupt Enable bit position
                                 .equ TCA_SPLIT_LUNF_bm = 0x01            ; Low Underflow Interrupt Enable bit mask
                                 .equ TCA_SPLIT_LUNF_bp = 0               ; Low Underflow Interrupt Enable bit position
                                 
                                 ; TCA_SPLIT_INTFLAGS masks
                                 ; Masks for TCA_SPLIT_HUNF already defined
                                 ; Masks for TCA_SPLIT_LCMP0 already defined
                                 ; Masks for TCA_SPLIT_LCMP1 already defined
                                 ; Masks for TCA_SPLIT_LCMP2 already defined
                                 ; Masks for TCA_SPLIT_LUNF already defined
                                 
                                 ; Clock Selection select
                                 .equ TCA_SINGLE_CLKSEL_DIV1_gc = (0x00<<1) ; System Clock
                                 .equ TCA_SINGLE_CLKSEL_DIV2_gc = (0x01<<1) ; System Clock / 2
                                 .equ TCA_SINGLE_CLKSEL_DIV4_gc = (0x02<<1) ; System Clock / 4
                                 .equ TCA_SINGLE_CLKSEL_DIV8_gc = (0x03<<1) ; System Clock / 8
                                 .equ TCA_SINGLE_CLKSEL_DIV16_gc = (0x04<<1) ; System Clock / 16
                                 .equ TCA_SINGLE_CLKSEL_DIV64_gc = (0x05<<1) ; System Clock / 64
                                 .equ TCA_SINGLE_CLKSEL_DIV256_gc = (0x06<<1) ; System Clock / 256
                                 .equ TCA_SINGLE_CLKSEL_DIV1024_gc = (0x07<<1) ; System Clock / 1024
                                 
                                 ; Waveform generation mode select
                                 .equ TCA_SINGLE_WGMODE_NORMAL_gc = (0x00<<0) ; Normal Mode
                                 .equ TCA_SINGLE_WGMODE_FRQ_gc = (0x01<<0) ; Frequency Generation Mode
                                 .equ TCA_SINGLE_WGMODE_SINGLESLOPE_gc = (0x03<<0) ; Single Slope PWM
                                 .equ TCA_SINGLE_WGMODE_DSTOP_gc = (0x05<<0) ; Dual Slope PWM, overflow on TOP
                                 .equ TCA_SINGLE_WGMODE_DSBOTH_gc = (0x06<<0) ; Dual Slope PWM, overflow on TOP and BOTTOM
                                 .equ TCA_SINGLE_WGMODE_DSBOTTOM_gc = (0x07<<0) ; Dual Slope PWM, overflow on BOTTOM
                                 
                                 ; Command select
                                 .equ TCA_SINGLE_CMD_NONE_gc = (0x00<<2)  ; No Command
                                 .equ TCA_SINGLE_CMD_UPDATE_gc = (0x01<<2) ; Force Update
                                 .equ TCA_SINGLE_CMD_RESTART_gc = (0x02<<2) ; Force Restart
                                 .equ TCA_SINGLE_CMD_RESET_gc = (0x03<<2) ; Force Hard Reset
                                 
                                 ; Direction select
                                 .equ TCA_SINGLE_DIR_UP_gc = (0x00<<0)    ; Count up
                                 .equ TCA_SINGLE_DIR_DOWN_gc = (0x01<<0)  ; Count down
                                 
                                 ; Event Action A select
                                 .equ TCA_SINGLE_EVACTA_CNT_POSEDGE_gc = (0x00<<1) ; Count on positive edge event
                                 .equ TCA_SINGLE_EVACTA_CNT_ANYEDGE_gc = (0x01<<1) ; Count on any edge event
                                 .equ TCA_SINGLE_EVACTA_CNT_HIGHLVL_gc = (0x02<<1) ; Count on prescaled clock while event line is 1.
                                 .equ TCA_SINGLE_EVACTA_UPDOWN_gc = (0x03<<1) ; Count on prescaled clock. Event controls count direction. Up-count when event line is 0, down-count when event line is 1.
                                 
                                 ; Event Action B select
                                 .equ TCA_SINGLE_EVACTB_NONE_gc = (0x00<<5) ; No Action
                                 .equ TCA_SINGLE_EVACTB_UPDOWN_gc = (0x03<<5) ; Count on prescaled clock. Event controls count direction. Up-count when event line is 0, down-count when event line is 1.
                                 .equ TCA_SINGLE_EVACTB_RESTART_POSEDGE_gc = (0x04<<5) ; Restart counter at positive edge event
                                 .equ TCA_SINGLE_EVACTB_RESTART_ANYEDGE_gc = (0x05<<5) ; Restart counter on any edge event
                                 .equ TCA_SINGLE_EVACTB_RESTART_HIGHLVL_gc = (0x06<<5) ; Restart counter while event line is 1.
                                 
                                 ; Clock Selection select
                                 .equ TCA_SPLIT_CLKSEL_DIV1_gc = (0x00<<1) ; System Clock
                                 .equ TCA_SPLIT_CLKSEL_DIV2_gc = (0x01<<1) ; System Clock / 2
                                 .equ TCA_SPLIT_CLKSEL_DIV4_gc = (0x02<<1) ; System Clock / 4
                                 .equ TCA_SPLIT_CLKSEL_DIV8_gc = (0x03<<1) ; System Clock / 8
                                 .equ TCA_SPLIT_CLKSEL_DIV16_gc = (0x04<<1) ; System Clock / 16
                                 .equ TCA_SPLIT_CLKSEL_DIV64_gc = (0x05<<1) ; System Clock / 64
                                 .equ TCA_SPLIT_CLKSEL_DIV256_gc = (0x06<<1) ; System Clock / 256
                                 .equ TCA_SPLIT_CLKSEL_DIV1024_gc = (0x07<<1) ; System Clock / 1024
                                 
                                 ; Command select
                                 .equ TCA_SPLIT_CMD_NONE_gc = (0x00<<2)   ; No Command
                                 .equ TCA_SPLIT_CMD_UPDATE_gc = (0x01<<2) ; Force Update
                                 .equ TCA_SPLIT_CMD_RESTART_gc = (0x02<<2) ; Force Restart
                                 .equ TCA_SPLIT_CMD_RESET_gc = (0x03<<2)  ; Force Hard Reset
                                 
                                 ; Command Enable select
                                 .equ TCA_SPLIT_CMDEN_NONE_gc = (0x00<<0) ; None
                                 .equ TCA_SPLIT_CMDEN_BOTH_gc = (0x03<<0) ; Both low byte and high byte counter
                                 
                                 
                                 ;*************************************************************************
                                 ;** TCB - 16-bit Timer Type B
                                 ;*************************************************************************
                                 
                                 ; TCB_CTRLA masks
                                 .equ TCB_CASCADE_bm = 0x20               ; Cascade two timers bit mask
                                 .equ TCB_CASCADE_bp = 5                  ; Cascade two timers bit position
                                 .equ TCB_CLKSEL_gm = 0x0E                ; Clock Select group mask
                                 .equ TCB_CLKSEL_gp = 1                   ; Clock Select group position
                                 .equ TCB_CLKSEL0_bm = (1<<1)             ; Clock Select bit 0 mask
                                 .equ TCB_CLKSEL0_bp = 1                  ; Clock Select bit 0 position
                                 .equ TCB_CLKSEL1_bm = (1<<2)             ; Clock Select bit 1 mask
                                 .equ TCB_CLKSEL1_bp = 2                  ; Clock Select bit 1 position
                                 .equ TCB_CLKSEL2_bm = (1<<3)             ; Clock Select bit 2 mask
                                 .equ TCB_CLKSEL2_bp = 3                  ; Clock Select bit 2 position
                                 .equ TCB_ENABLE_bm = 0x01                ; Enable bit mask
                                 .equ TCB_ENABLE_bp = 0                   ; Enable bit position
                                 .equ TCB_RUNSTDBY_bm = 0x40              ; Run Standby bit mask
                                 .equ TCB_RUNSTDBY_bp = 6                 ; Run Standby bit position
                                 .equ TCB_SYNCUPD_bm = 0x10               ; Synchronize Update bit mask
                                 .equ TCB_SYNCUPD_bp = 4                  ; Synchronize Update bit position
                                 
                                 ; TCB_CTRLB masks
                                 .equ TCB_ASYNC_bm = 0x40                 ; Asynchronous Enable bit mask
                                 .equ TCB_ASYNC_bp = 6                    ; Asynchronous Enable bit position
                                 .equ TCB_CCMPEN_bm = 0x10                ; Pin Output Enable bit mask
                                 .equ TCB_CCMPEN_bp = 4                   ; Pin Output Enable bit position
                                 .equ TCB_CCMPINIT_bm = 0x20              ; Pin Initial State bit mask
                                 .equ TCB_CCMPINIT_bp = 5                 ; Pin Initial State bit position
                                 .equ TCB_CNTMODE_gm = 0x07               ; Timer Mode group mask
                                 .equ TCB_CNTMODE_gp = 0                  ; Timer Mode group position
                                 .equ TCB_CNTMODE0_bm = (1<<0)            ; Timer Mode bit 0 mask
                                 .equ TCB_CNTMODE0_bp = 0                 ; Timer Mode bit 0 position
                                 .equ TCB_CNTMODE1_bm = (1<<1)            ; Timer Mode bit 1 mask
                                 .equ TCB_CNTMODE1_bp = 1                 ; Timer Mode bit 1 position
                                 .equ TCB_CNTMODE2_bm = (1<<2)            ; Timer Mode bit 2 mask
                                 .equ TCB_CNTMODE2_bp = 2                 ; Timer Mode bit 2 position
                                 
                                 ; TCB_DBGCTRL masks
                                 .equ TCB_DBGRUN_bm = 0x01                ; Debug Run bit mask
                                 .equ TCB_DBGRUN_bp = 0                   ; Debug Run bit position
                                 
                                 ; TCB_EVCTRL masks
                                 .equ TCB_CAPTEI_bm = 0x01                ; Event Input Enable bit mask
                                 .equ TCB_CAPTEI_bp = 0                   ; Event Input Enable bit position
                                 .equ TCB_EDGE_bm = 0x10                  ; Event Edge bit mask
                                 .equ TCB_EDGE_bp = 4                     ; Event Edge bit position
                                 .equ TCB_FILTER_bm = 0x40                ; Input Capture Noise Cancellation Filter bit mask
                                 .equ TCB_FILTER_bp = 6                   ; Input Capture Noise Cancellation Filter bit position
                                 
                                 ; TCB_INTCTRL masks
                                 .equ TCB_CAPT_bm = 0x01                  ; Capture or Timeout bit mask
                                 .equ TCB_CAPT_bp = 0                     ; Capture or Timeout bit position
                                 .equ TCB_OVF_bm = 0x02                   ; Overflow bit mask
                                 .equ TCB_OVF_bp = 1                      ; Overflow bit position
                                 
                                 ; TCB_INTFLAGS masks
                                 ; Masks for TCB_CAPT already defined
                                 ; Masks for TCB_OVF already defined
                                 
                                 ; TCB_STATUS masks
                                 .equ TCB_RUN_bm = 0x01                   ; Run bit mask
                                 .equ TCB_RUN_bp = 0                      ; Run bit position
                                 
                                 ; Clock Select select
                                 .equ TCB_CLKSEL_DIV1_gc = (0x00<<1)      ; CLK_PER
                                 .equ TCB_CLKSEL_DIV2_gc = (0x01<<1)      ; CLK_PER/2
                                 .equ TCB_CLKSEL_TCA0_gc = (0x02<<1)      ; Use CLK_TCA from TCA0
                                 .equ TCB_CLKSEL_TCA1_gc = (0x03<<1)      ; Use CLK_TCA from TCA1
                                 .equ TCB_CLKSEL_EVENT_gc = (0x07<<1)     ; Count on event edge
                                 
                                 ; Timer Mode select
                                 .equ TCB_CNTMODE_INT_gc = (0x00<<0)      ; Periodic Interrupt
                                 .equ TCB_CNTMODE_TIMEOUT_gc = (0x01<<0)  ; Periodic Timeout
                                 .equ TCB_CNTMODE_CAPT_gc = (0x02<<0)     ; Input Capture Event
                                 .equ TCB_CNTMODE_FRQ_gc = (0x03<<0)      ; Input Capture Frequency measurement
                                 .equ TCB_CNTMODE_PW_gc = (0x04<<0)       ; Input Capture Pulse-Width measurement
                                 .equ TCB_CNTMODE_FRQPW_gc = (0x05<<0)    ; Input Capture Frequency and Pulse-Width measurement
                                 .equ TCB_CNTMODE_SINGLE_gc = (0x06<<0)   ; Single Shot
                                 .equ TCB_CNTMODE_PWM8_gc = (0x07<<0)     ; 8-bit PWM
                                 
                                 
                                 ;*************************************************************************
                                 ;** TCD - Timer Counter D
                                 ;*************************************************************************
                                 
                                 ; TCD_CTRLA masks
                                 .equ TCD_CLKSEL_gm = 0x60                ; clock select group mask
                                 .equ TCD_CLKSEL_gp = 5                   ; clock select group position
                                 .equ TCD_CLKSEL0_bm = (1<<5)             ; clock select bit 0 mask
                                 .equ TCD_CLKSEL0_bp = 5                  ; clock select bit 0 position
                                 .equ TCD_CLKSEL1_bm = (1<<6)             ; clock select bit 1 mask
                                 .equ TCD_CLKSEL1_bp = 6                  ; clock select bit 1 position
                                 .equ TCD_CNTPRES_gm = 0x18               ; counter prescaler group mask
                                 .equ TCD_CNTPRES_gp = 3                  ; counter prescaler group position
                                 .equ TCD_CNTPRES0_bm = (1<<3)            ; counter prescaler bit 0 mask
                                 .equ TCD_CNTPRES0_bp = 3                 ; counter prescaler bit 0 position
                                 .equ TCD_CNTPRES1_bm = (1<<4)            ; counter prescaler bit 1 mask
                                 .equ TCD_CNTPRES1_bp = 4                 ; counter prescaler bit 1 position
                                 .equ TCD_ENABLE_bm = 0x01                ; Enable bit mask
                                 .equ TCD_ENABLE_bp = 0                   ; Enable bit position
                                 .equ TCD_SYNCPRES_gm = 0x06              ; Synchronization prescaler group mask
                                 .equ TCD_SYNCPRES_gp = 1                 ; Synchronization prescaler group position
                                 .equ TCD_SYNCPRES0_bm = (1<<1)           ; Synchronization prescaler bit 0 mask
                                 .equ TCD_SYNCPRES0_bp = 1                ; Synchronization prescaler bit 0 position
                                 .equ TCD_SYNCPRES1_bm = (1<<2)           ; Synchronization prescaler bit 1 mask
                                 .equ TCD_SYNCPRES1_bp = 2                ; Synchronization prescaler bit 1 position
                                 
                                 ; TCD_CTRLB masks
                                 .equ TCD_WGMODE_gm = 0x03                ; Waveform generation mode group mask
                                 .equ TCD_WGMODE_gp = 0                   ; Waveform generation mode group position
                                 .equ TCD_WGMODE0_bm = (1<<0)             ; Waveform generation mode bit 0 mask
                                 .equ TCD_WGMODE0_bp = 0                  ; Waveform generation mode bit 0 position
                                 .equ TCD_WGMODE1_bm = (1<<1)             ; Waveform generation mode bit 1 mask
                                 .equ TCD_WGMODE1_bp = 1                  ; Waveform generation mode bit 1 position
                                 
                                 ; TCD_CTRLC masks
                                 .equ TCD_AUPDATE_bm = 0x02               ; Auto update bit mask
                                 .equ TCD_AUPDATE_bp = 1                  ; Auto update bit position
                                 .equ TCD_CMPCSEL_bm = 0x40               ; Compare C output select bit mask
                                 .equ TCD_CMPCSEL_bp = 6                  ; Compare C output select bit position
                                 .equ TCD_CMPDSEL_bm = 0x80               ; Compare D output select bit mask
                                 .equ TCD_CMPDSEL_bp = 7                  ; Compare D output select bit position
                                 .equ TCD_CMPOVR_bm = 0x01                ; Compare output value override bit mask
                                 .equ TCD_CMPOVR_bp = 0                   ; Compare output value override bit position
                                 .equ TCD_FIFTY_bm = 0x08                 ; Fifty percent waveform bit mask
                                 .equ TCD_FIFTY_bp = 3                    ; Fifty percent waveform bit position
                                 
                                 ; TCD_CTRLD masks
                                 .equ TCD_CMPAVAL_gm = 0x0F               ; Compare A value group mask
                                 .equ TCD_CMPAVAL_gp = 0                  ; Compare A value group position
                                 .equ TCD_CMPAVAL0_bm = (1<<0)            ; Compare A value bit 0 mask
                                 .equ TCD_CMPAVAL0_bp = 0                 ; Compare A value bit 0 position
                                 .equ TCD_CMPAVAL1_bm = (1<<1)            ; Compare A value bit 1 mask
                                 .equ TCD_CMPAVAL1_bp = 1                 ; Compare A value bit 1 position
                                 .equ TCD_CMPAVAL2_bm = (1<<2)            ; Compare A value bit 2 mask
                                 .equ TCD_CMPAVAL2_bp = 2                 ; Compare A value bit 2 position
                                 .equ TCD_CMPAVAL3_bm = (1<<3)            ; Compare A value bit 3 mask
                                 .equ TCD_CMPAVAL3_bp = 3                 ; Compare A value bit 3 position
                                 .equ TCD_CMPBVAL_gm = 0xF0               ; Compare B value group mask
                                 .equ TCD_CMPBVAL_gp = 4                  ; Compare B value group position
                                 .equ TCD_CMPBVAL0_bm = (1<<4)            ; Compare B value bit 0 mask
                                 .equ TCD_CMPBVAL0_bp = 4                 ; Compare B value bit 0 position
                                 .equ TCD_CMPBVAL1_bm = (1<<5)            ; Compare B value bit 1 mask
                                 .equ TCD_CMPBVAL1_bp = 5                 ; Compare B value bit 1 position
                                 .equ TCD_CMPBVAL2_bm = (1<<6)            ; Compare B value bit 2 mask
                                 .equ TCD_CMPBVAL2_bp = 6                 ; Compare B value bit 2 position
                                 .equ TCD_CMPBVAL3_bm = (1<<7)            ; Compare B value bit 3 mask
                                 .equ TCD_CMPBVAL3_bp = 7                 ; Compare B value bit 3 position
                                 
                                 ; TCD_CTRLE masks
                                 .equ TCD_DISEOC_bm = 0x80                ; Disable at end of cycle bit mask
                                 .equ TCD_DISEOC_bp = 7                   ; Disable at end of cycle bit position
                                 .equ TCD_RESTART_bm = 0x04               ; Restart strobe bit mask
                                 .equ TCD_RESTART_bp = 2                  ; Restart strobe bit position
                                 .equ TCD_SCAPTUREA_bm = 0x08             ; Software Capture A Strobe bit mask
                                 .equ TCD_SCAPTUREA_bp = 3                ; Software Capture A Strobe bit position
                                 .equ TCD_SCAPTUREB_bm = 0x10             ; Software Capture B Strobe bit mask
                                 .equ TCD_SCAPTUREB_bp = 4                ; Software Capture B Strobe bit position
                                 .equ TCD_SYNC_bm = 0x02                  ; synchronize strobe bit mask
                                 .equ TCD_SYNC_bp = 1                     ; synchronize strobe bit position
                                 .equ TCD_SYNCEOC_bm = 0x01               ; synchronize end of cycle strobe bit mask
                                 .equ TCD_SYNCEOC_bp = 0                  ; synchronize end of cycle strobe bit position
                                 
                                 ; TCD_DBGCTRL masks
                                 .equ TCD_DBGRUN_bm = 0x01                ; Debug run bit mask
                                 .equ TCD_DBGRUN_bp = 0                   ; Debug run bit position
                                 .equ TCD_FAULTDET_bm = 0x04              ; Fault detection bit mask
                                 .equ TCD_FAULTDET_bp = 2                 ; Fault detection bit position
                                 
                                 ; TCD_DITCTRL masks
                                 .equ TCD_DITHERSEL_gm = 0x03             ; dither select group mask
                                 .equ TCD_DITHERSEL_gp = 0                ; dither select group position
                                 .equ TCD_DITHERSEL0_bm = (1<<0)          ; dither select bit 0 mask
                                 .equ TCD_DITHERSEL0_bp = 0               ; dither select bit 0 position
                                 .equ TCD_DITHERSEL1_bm = (1<<1)          ; dither select bit 1 mask
                                 .equ TCD_DITHERSEL1_bp = 1               ; dither select bit 1 position
                                 
                                 ; TCD_DITVAL masks
                                 .equ TCD_DITHER_gm = 0x0F                ; Dither value group mask
                                 .equ TCD_DITHER_gp = 0                   ; Dither value group position
                                 .equ TCD_DITHER0_bm = (1<<0)             ; Dither value bit 0 mask
                                 .equ TCD_DITHER0_bp = 0                  ; Dither value bit 0 position
                                 .equ TCD_DITHER1_bm = (1<<1)             ; Dither value bit 1 mask
                                 .equ TCD_DITHER1_bp = 1                  ; Dither value bit 1 position
                                 .equ TCD_DITHER2_bm = (1<<2)             ; Dither value bit 2 mask
                                 .equ TCD_DITHER2_bp = 2                  ; Dither value bit 2 position
                                 .equ TCD_DITHER3_bm = (1<<3)             ; Dither value bit 3 mask
                                 .equ TCD_DITHER3_bp = 3                  ; Dither value bit 3 position
                                 
                                 ; TCD_DLYCTRL masks
                                 .equ TCD_DLYPRESC_gm = 0x30              ; Delay prescaler group mask
                                 .equ TCD_DLYPRESC_gp = 4                 ; Delay prescaler group position
                                 .equ TCD_DLYPRESC0_bm = (1<<4)           ; Delay prescaler bit 0 mask
                                 .equ TCD_DLYPRESC0_bp = 4                ; Delay prescaler bit 0 position
                                 .equ TCD_DLYPRESC1_bm = (1<<5)           ; Delay prescaler bit 1 mask
                                 .equ TCD_DLYPRESC1_bp = 5                ; Delay prescaler bit 1 position
                                 .equ TCD_DLYSEL_gm = 0x03                ; Delay select group mask
                                 .equ TCD_DLYSEL_gp = 0                   ; Delay select group position
                                 .equ TCD_DLYSEL0_bm = (1<<0)             ; Delay select bit 0 mask
                                 .equ TCD_DLYSEL0_bp = 0                  ; Delay select bit 0 position
                                 .equ TCD_DLYSEL1_bm = (1<<1)             ; Delay select bit 1 mask
                                 .equ TCD_DLYSEL1_bp = 1                  ; Delay select bit 1 position
                                 .equ TCD_DLYTRIG_gm = 0x0C               ; Delay trigger group mask
                                 .equ TCD_DLYTRIG_gp = 2                  ; Delay trigger group position
                                 .equ TCD_DLYTRIG0_bm = (1<<2)            ; Delay trigger bit 0 mask
                                 .equ TCD_DLYTRIG0_bp = 2                 ; Delay trigger bit 0 position
                                 .equ TCD_DLYTRIG1_bm = (1<<3)            ; Delay trigger bit 1 mask
                                 .equ TCD_DLYTRIG1_bp = 3                 ; Delay trigger bit 1 position
                                 
                                 ; TCD_DLYVAL masks
                                 .equ TCD_DLYVAL_gm = 0xFF                ; Delay value group mask
                                 .equ TCD_DLYVAL_gp = 0                   ; Delay value group position
                                 .equ TCD_DLYVAL0_bm = (1<<0)             ; Delay value bit 0 mask
                                 .equ TCD_DLYVAL0_bp = 0                  ; Delay value bit 0 position
                                 .equ TCD_DLYVAL1_bm = (1<<1)             ; Delay value bit 1 mask
                                 .equ TCD_DLYVAL1_bp = 1                  ; Delay value bit 1 position
                                 .equ TCD_DLYVAL2_bm = (1<<2)             ; Delay value bit 2 mask
                                 .equ TCD_DLYVAL2_bp = 2                  ; Delay value bit 2 position
                                 .equ TCD_DLYVAL3_bm = (1<<3)             ; Delay value bit 3 mask
                                 .equ TCD_DLYVAL3_bp = 3                  ; Delay value bit 3 position
                                 .equ TCD_DLYVAL4_bm = (1<<4)             ; Delay value bit 4 mask
                                 .equ TCD_DLYVAL4_bp = 4                  ; Delay value bit 4 position
                                 .equ TCD_DLYVAL5_bm = (1<<5)             ; Delay value bit 5 mask
                                 .equ TCD_DLYVAL5_bp = 5                  ; Delay value bit 5 position
                                 .equ TCD_DLYVAL6_bm = (1<<6)             ; Delay value bit 6 mask
                                 .equ TCD_DLYVAL6_bp = 6                  ; Delay value bit 6 position
                                 .equ TCD_DLYVAL7_bm = (1<<7)             ; Delay value bit 7 mask
                                 .equ TCD_DLYVAL7_bp = 7                  ; Delay value bit 7 position
                                 
                                 ; TCD_EVCTRLA masks
                                 .equ TCD_ACTION_bm = 0x04                ; event action bit mask
                                 .equ TCD_ACTION_bp = 2                   ; event action bit position
                                 .equ TCD_CFG_gm = 0xC0                   ; event config group mask
                                 .equ TCD_CFG_gp = 6                      ; event config group position
                                 .equ TCD_CFG0_bm = (1<<6)                ; event config bit 0 mask
                                 .equ TCD_CFG0_bp = 6                     ; event config bit 0 position
                                 .equ TCD_CFG1_bm = (1<<7)                ; event config bit 1 mask
                                 .equ TCD_CFG1_bp = 7                     ; event config bit 1 position
                                 .equ TCD_EDGE_bm = 0x10                  ; edge select bit mask
                                 .equ TCD_EDGE_bp = 4                     ; edge select bit position
                                 .equ TCD_TRIGEI_bm = 0x01                ; Trigger event enable bit mask
                                 .equ TCD_TRIGEI_bp = 0                   ; Trigger event enable bit position
                                 
                                 ; TCD_EVCTRLB masks
                                 ; Masks for TCD_ACTION already defined
                                 ; Masks for TCD_CFG already defined
                                 ; Masks for TCD_EDGE already defined
                                 ; Masks for TCD_TRIGEI already defined
                                 
                                 ; TCD_FAULTCTRL masks
                                 .equ TCD_CMPA_bm = 0x01                  ; Compare A value bit mask
                                 .equ TCD_CMPA_bp = 0                     ; Compare A value bit position
                                 .equ TCD_CMPAEN_bm = 0x10                ; Compare A enable bit mask
                                 .equ TCD_CMPAEN_bp = 4                   ; Compare A enable bit position
                                 .equ TCD_CMPB_bm = 0x02                  ; Compare B value bit mask
                                 .equ TCD_CMPB_bp = 1                     ; Compare B value bit position
                                 .equ TCD_CMPBEN_bm = 0x20                ; Compare B enable bit mask
                                 .equ TCD_CMPBEN_bp = 5                   ; Compare B enable bit position
                                 .equ TCD_CMPC_bm = 0x04                  ; Compare C value bit mask
                                 .equ TCD_CMPC_bp = 2                     ; Compare C value bit position
                                 .equ TCD_CMPCEN_bm = 0x40                ; Compare C enable bit mask
                                 .equ TCD_CMPCEN_bp = 6                   ; Compare C enable bit position
                                 .equ TCD_CMPD_bm = 0x08                  ; Compare D vaule bit mask
                                 .equ TCD_CMPD_bp = 3                     ; Compare D vaule bit position
                                 .equ TCD_CMPDEN_bm = 0x80                ; Compare D enable bit mask
                                 .equ TCD_CMPDEN_bp = 7                   ; Compare D enable bit position
                                 
                                 ; TCD_INPUTCTRLA masks
                                 .equ TCD_INPUTMODE_gm = 0x0F             ; Input mode group mask
                                 .equ TCD_INPUTMODE_gp = 0                ; Input mode group position
                                 .equ TCD_INPUTMODE0_bm = (1<<0)          ; Input mode bit 0 mask
                                 .equ TCD_INPUTMODE0_bp = 0               ; Input mode bit 0 position
                                 .equ TCD_INPUTMODE1_bm = (1<<1)          ; Input mode bit 1 mask
                                 .equ TCD_INPUTMODE1_bp = 1               ; Input mode bit 1 position
                                 .equ TCD_INPUTMODE2_bm = (1<<2)          ; Input mode bit 2 mask
                                 .equ TCD_INPUTMODE2_bp = 2               ; Input mode bit 2 position
                                 .equ TCD_INPUTMODE3_bm = (1<<3)          ; Input mode bit 3 mask
                                 .equ TCD_INPUTMODE3_bp = 3               ; Input mode bit 3 position
                                 
                                 ; TCD_INPUTCTRLB masks
                                 ; Masks for TCD_INPUTMODE already defined
                                 
                                 ; TCD_INTCTRL masks
                                 .equ TCD_OVF_bm = 0x01                   ; Overflow interrupt enable bit mask
                                 .equ TCD_OVF_bp = 0                      ; Overflow interrupt enable bit position
                                 .equ TCD_TRIGA_bm = 0x04                 ; Trigger A interrupt enable bit mask
                                 .equ TCD_TRIGA_bp = 2                    ; Trigger A interrupt enable bit position
                                 .equ TCD_TRIGB_bm = 0x08                 ; Trigger B interrupt enable bit mask
                                 .equ TCD_TRIGB_bp = 3                    ; Trigger B interrupt enable bit position
                                 
                                 ; TCD_INTFLAGS masks
                                 ; Masks for TCD_OVF already defined
                                 ; Masks for TCD_TRIGA already defined
                                 ; Masks for TCD_TRIGB already defined
                                 
                                 ; TCD_STATUS masks
                                 .equ TCD_CMDRDY_bm = 0x02                ; Command ready bit mask
                                 .equ TCD_CMDRDY_bp = 1                   ; Command ready bit position
                                 .equ TCD_ENRDY_bm = 0x01                 ; Enable ready bit mask
                                 .equ TCD_ENRDY_bp = 0                    ; Enable ready bit position
                                 .equ TCD_PWMACTA_bm = 0x40               ; PWM activity on A bit mask
                                 .equ TCD_PWMACTA_bp = 6                  ; PWM activity on A bit position
                                 .equ TCD_PWMACTB_bm = 0x80               ; PWM activity on B bit mask
                                 .equ TCD_PWMACTB_bp = 7                  ; PWM activity on B bit position
                                 
                                 ; clock select select
                                 .equ TCD_CLKSEL_OSCHF_gc = (0x00<<5)     ; Internal High-Frequency oscillator
                                 .equ TCD_CLKSEL_PLL_gc = (0x01<<5)       ; PLL
                                 .equ TCD_CLKSEL_EXTCLK_gc = (0x02<<5)    ; External Clock
                                 .equ TCD_CLKSEL_CLKPER_gc = (0x03<<5)    ; Peripheral clock
                                 
                                 ; counter prescaler select
                                 .equ TCD_CNTPRES_DIV1_gc = (0x00<<3)     ; Sync clock divided by 1
                                 .equ TCD_CNTPRES_DIV4_gc = (0x01<<3)     ; Sync clock divided by 4
                                 .equ TCD_CNTPRES_DIV32_gc = (0x02<<3)    ; Sync clock divided by 32
                                 
                                 ; Synchronization prescaler select
                                 .equ TCD_SYNCPRES_DIV1_gc = (0x00<<1)    ; Selected clock source divided by 1
                                 .equ TCD_SYNCPRES_DIV2_gc = (0x01<<1)    ; Selected clock source divided by 2
                                 .equ TCD_SYNCPRES_DIV4_gc = (0x02<<1)    ; Selected clock source divided by 4
                                 .equ TCD_SYNCPRES_DIV8_gc = (0x03<<1)    ; Selected clock source divided by 8
                                 
                                 ; Waveform generation mode select
                                 .equ TCD_WGMODE_ONERAMP_gc = (0x00<<0)   ; One ramp mode
                                 .equ TCD_WGMODE_TWORAMP_gc = (0x01<<0)   ; Two ramp mode
                                 .equ TCD_WGMODE_FOURRAMP_gc = (0x02<<0)  ; Four ramp mode
                                 .equ TCD_WGMODE_DS_gc = (0x03<<0)        ; Dual slope mode
                                 
                                 ; Compare C output select select
                                 .equ TCD_CMPCSEL_PWMA_gc = (0x00<<6)     ; PWM A output
                                 .equ TCD_CMPCSEL_PWMB_gc = (0x01<<6)     ; PWM B output
                                 
                                 ; Compare D output select select
                                 .equ TCD_CMPDSEL_PWMA_gc = (0x00<<7)     ; PWM A output
                                 .equ TCD_CMPDSEL_PWMB_gc = (0x01<<7)     ; PWM B output
                                 
                                 ; dither select select
                                 .equ TCD_DITHERSEL_ONTIMEB_gc = (0x00<<0) ; On-time ramp B
                                 .equ TCD_DITHERSEL_ONTIMEAB_gc = (0x01<<0) ; On-time ramp A and B
                                 .equ TCD_DITHERSEL_DEADTIMEB_gc = (0x02<<0) ; Dead-time rampB
                                 .equ TCD_DITHERSEL_DEADTIMEAB_gc = (0x03<<0) ; Dead-time ramp A and B
                                 
                                 ; Delay prescaler select
                                 .equ TCD_DLYPRESC_DIV1_gc = (0x00<<4)    ; No prescaling
                                 .equ TCD_DLYPRESC_DIV2_gc = (0x01<<4)    ; Prescale with 2
                                 .equ TCD_DLYPRESC_DIV4_gc = (0x02<<4)    ; Prescale with 4
                                 .equ TCD_DLYPRESC_DIV8_gc = (0x03<<4)    ; Prescale with 8
                                 
                                 ; Delay select select
                                 .equ TCD_DLYSEL_OFF_gc = (0x00<<0)       ; No delay
                                 .equ TCD_DLYSEL_INBLANK_gc = (0x01<<0)   ; Input blanking enabled
                                 .equ TCD_DLYSEL_EVENT_gc = (0x02<<0)     ; Event delay enabled
                                 
                                 ; Delay trigger select
                                 .equ TCD_DLYTRIG_CMPASET_gc = (0x00<<2)  ; Compare A set
                                 .equ TCD_DLYTRIG_CMPACLR_gc = (0x01<<2)  ; Compare A clear
                                 .equ TCD_DLYTRIG_CMPBSET_gc = (0x02<<2)  ; Compare B set
                                 .equ TCD_DLYTRIG_CMPBCLR_gc = (0x03<<2)  ; Compare B clear
                                 
                                 ; event action select
                                 .equ TCD_ACTION_FAULT_gc = (0x00<<2)     ; Event trigger a fault
                                 .equ TCD_ACTION_CAPTURE_gc = (0x01<<2)   ; Event trigger a fault and capture
                                 
                                 ; event config select
                                 .equ TCD_CFG_NEITHER_gc = (0x00<<6)      ; Neither Filter nor Asynchronous Event is enabled
                                 .equ TCD_CFG_FILTER_gc = (0x01<<6)       ; Input Capture Noise Cancellation Filter enabled
                                 .equ TCD_CFG_ASYNC_gc = (0x02<<6)        ; Asynchronous Event output qualification enabled
                                 
                                 ; edge select select
                                 .equ TCD_EDGE_FALL_LOW_gc = (0x00<<4)    ; The falling edge or low level of event generates retrigger or fault action
                                 .equ TCD_EDGE_RISE_HIGH_gc = (0x01<<4)   ; The rising edge or high level of event generates retrigger or fault action
                                 
                                 ; Input mode select
                                 .equ TCD_INPUTMODE_NONE_gc = (0x00<<0)   ; Input has no actions
                                 .equ TCD_INPUTMODE_JMPWAIT_gc = (0x01<<0) ; Stop output, jump to opposite compare cycle and wait
                                 .equ TCD_INPUTMODE_EXECWAIT_gc = (0x02<<0) ; Stop output, execute opposite compare cycle and wait
                                 .equ TCD_INPUTMODE_EXECFAULT_gc = (0x03<<0) ; stop output, execute opposite compare cycle while fault active
                                 .equ TCD_INPUTMODE_FREQ_gc = (0x04<<0)   ; Stop all outputs, maintain frequency
                                 .equ TCD_INPUTMODE_EXECDT_gc = (0x05<<0) ; Stop all outputs, execute dead time while fault active
                                 .equ TCD_INPUTMODE_WAIT_gc = (0x06<<0)   ; Stop all outputs, jump to next compare cycle and wait
                                 .equ TCD_INPUTMODE_WAITSW_gc = (0x07<<0) ; Stop all outputs, wait for software action
                                 .equ TCD_INPUTMODE_EDGETRIG_gc = (0x08<<0) ; Stop output on edge, jump to next compare cycle
                                 .equ TCD_INPUTMODE_EDGETRIGFREQ_gc = (0x09<<0) ; Stop output on edge, maintain frequency
                                 .equ TCD_INPUTMODE_LVLTRIGFREQ_gc = (0x0A<<0) ; Stop output at level, maintain frequency
                                 
                                 
                                 ;*************************************************************************
                                 ;** TWI - Two-Wire Interface
                                 ;*************************************************************************
                                 
                                 ; TWI_CTRLA masks
                                 .equ TWI_FMPEN_bm = 0x02                 ; FM Plus Enable bit mask
                                 .equ TWI_FMPEN_bp = 1                    ; FM Plus Enable bit position
                                 .equ TWI_INPUTLVL_bm = 0x40              ; Input Voltage Transition Level bit mask
                                 .equ TWI_INPUTLVL_bp = 6                 ; Input Voltage Transition Level bit position
                                 .equ TWI_SDAHOLD_gm = 0x0C               ; SDA Hold Time group mask
                                 .equ TWI_SDAHOLD_gp = 2                  ; SDA Hold Time group position
                                 .equ TWI_SDAHOLD0_bm = (1<<2)            ; SDA Hold Time bit 0 mask
                                 .equ TWI_SDAHOLD0_bp = 2                 ; SDA Hold Time bit 0 position
                                 .equ TWI_SDAHOLD1_bm = (1<<3)            ; SDA Hold Time bit 1 mask
                                 .equ TWI_SDAHOLD1_bp = 3                 ; SDA Hold Time bit 1 position
                                 .equ TWI_SDASETUP_bm = 0x10              ; SDA Setup Time bit mask
                                 .equ TWI_SDASETUP_bp = 4                 ; SDA Setup Time bit position
                                 
                                 ; TWI_DBGCTRL masks
                                 .equ TWI_DBGRUN_bm = 0x01                ; Debug Run bit mask
                                 .equ TWI_DBGRUN_bp = 0                   ; Debug Run bit position
                                 
                                 ; TWI_DUALCTRL masks
                                 .equ TWI_ENABLE_bm = 0x01                ; Dual Control Enable bit mask
                                 .equ TWI_ENABLE_bp = 0                   ; Dual Control Enable bit position
                                 ; Masks for TWI_FMPEN already defined
                                 ; Masks for TWI_INPUTLVL already defined
                                 ; Masks for TWI_SDAHOLD already defined
                                 
                                 ; TWI_MCTRLA masks
                                 ; Masks for TWI_ENABLE already defined
                                 .equ TWI_QCEN_bm = 0x10                  ; Quick Command Enable bit mask
                                 .equ TWI_QCEN_bp = 4                     ; Quick Command Enable bit position
                                 .equ TWI_RIEN_bm = 0x80                  ; Read Interrupt Enable bit mask
                                 .equ TWI_RIEN_bp = 7                     ; Read Interrupt Enable bit position
                                 .equ TWI_SMEN_bm = 0x02                  ; Smart Mode Enable bit mask
                                 .equ TWI_SMEN_bp = 1                     ; Smart Mode Enable bit position
                                 .equ TWI_TIMEOUT_gm = 0x0C               ; Inactive Bus Timeout group mask
                                 .equ TWI_TIMEOUT_gp = 2                  ; Inactive Bus Timeout group position
                                 .equ TWI_TIMEOUT0_bm = (1<<2)            ; Inactive Bus Timeout bit 0 mask
                                 .equ TWI_TIMEOUT0_bp = 2                 ; Inactive Bus Timeout bit 0 position
                                 .equ TWI_TIMEOUT1_bm = (1<<3)            ; Inactive Bus Timeout bit 1 mask
                                 .equ TWI_TIMEOUT1_bp = 3                 ; Inactive Bus Timeout bit 1 position
                                 .equ TWI_WIEN_bm = 0x40                  ; Write Interrupt Enable bit mask
                                 .equ TWI_WIEN_bp = 6                     ; Write Interrupt Enable bit position
                                 
                                 ; TWI_MCTRLB masks
                                 .equ TWI_ACKACT_bm = 0x04                ; Acknowledge Action bit mask
                                 .equ TWI_ACKACT_bp = 2                   ; Acknowledge Action bit position
                                 .equ TWI_FLUSH_bm = 0x08                 ; Flush bit mask
                                 .equ TWI_FLUSH_bp = 3                    ; Flush bit position
                                 .equ TWI_MCMD_gm = 0x03                  ; Command group mask
                                 .equ TWI_MCMD_gp = 0                     ; Command group position
                                 .equ TWI_MCMD0_bm = (1<<0)               ; Command bit 0 mask
                                 .equ TWI_MCMD0_bp = 0                    ; Command bit 0 position
                                 .equ TWI_MCMD1_bm = (1<<1)               ; Command bit 1 mask
                                 .equ TWI_MCMD1_bp = 1                    ; Command bit 1 position
                                 
                                 ; TWI_MSTATUS masks
                                 .equ TWI_ARBLOST_bm = 0x08               ; Arbitration Lost bit mask
                                 .equ TWI_ARBLOST_bp = 3                  ; Arbitration Lost bit position
                                 .equ TWI_BUSERR_bm = 0x04                ; Bus Error bit mask
                                 .equ TWI_BUSERR_bp = 2                   ; Bus Error bit position
                                 .equ TWI_BUSSTATE_gm = 0x03              ; Bus State group mask
                                 .equ TWI_BUSSTATE_gp = 0                 ; Bus State group position
                                 .equ TWI_BUSSTATE0_bm = (1<<0)           ; Bus State bit 0 mask
                                 .equ TWI_BUSSTATE0_bp = 0                ; Bus State bit 0 position
                                 .equ TWI_BUSSTATE1_bm = (1<<1)           ; Bus State bit 1 mask
                                 .equ TWI_BUSSTATE1_bp = 1                ; Bus State bit 1 position
                                 .equ TWI_CLKHOLD_bm = 0x20               ; Clock Hold bit mask
                                 .equ TWI_CLKHOLD_bp = 5                  ; Clock Hold bit position
                                 .equ TWI_RIF_bm = 0x80                   ; Read Interrupt Flag bit mask
                                 .equ TWI_RIF_bp = 7                      ; Read Interrupt Flag bit position
                                 .equ TWI_RXACK_bm = 0x10                 ; Received Acknowledge bit mask
                                 .equ TWI_RXACK_bp = 4                    ; Received Acknowledge bit position
                                 .equ TWI_WIF_bm = 0x40                   ; Write Interrupt Flag bit mask
                                 .equ TWI_WIF_bp = 6                      ; Write Interrupt Flag bit position
                                 
                                 ; TWI_SADDRMASK masks
                                 .equ TWI_ADDREN_bm = 0x01                ; Address Enable bit mask
                                 .equ TWI_ADDREN_bp = 0                   ; Address Enable bit position
                                 .equ TWI_ADDRMASK_gm = 0xFE              ; Address Mask group mask
                                 .equ TWI_ADDRMASK_gp = 1                 ; Address Mask group position
                                 .equ TWI_ADDRMASK0_bm = (1<<1)           ; Address Mask bit 0 mask
                                 .equ TWI_ADDRMASK0_bp = 1                ; Address Mask bit 0 position
                                 .equ TWI_ADDRMASK1_bm = (1<<2)           ; Address Mask bit 1 mask
                                 .equ TWI_ADDRMASK1_bp = 2                ; Address Mask bit 1 position
                                 .equ TWI_ADDRMASK2_bm = (1<<3)           ; Address Mask bit 2 mask
                                 .equ TWI_ADDRMASK2_bp = 3                ; Address Mask bit 2 position
                                 .equ TWI_ADDRMASK3_bm = (1<<4)           ; Address Mask bit 3 mask
                                 .equ TWI_ADDRMASK3_bp = 4                ; Address Mask bit 3 position
                                 .equ TWI_ADDRMASK4_bm = (1<<5)           ; Address Mask bit 4 mask
                                 .equ TWI_ADDRMASK4_bp = 5                ; Address Mask bit 4 position
                                 .equ TWI_ADDRMASK5_bm = (1<<6)           ; Address Mask bit 5 mask
                                 .equ TWI_ADDRMASK5_bp = 6                ; Address Mask bit 5 position
                                 .equ TWI_ADDRMASK6_bm = (1<<7)           ; Address Mask bit 6 mask
                                 .equ TWI_ADDRMASK6_bp = 7                ; Address Mask bit 6 position
                                 
                                 ; TWI_SCTRLA masks
                                 .equ TWI_APIEN_bm = 0x40                 ; Address/Stop Interrupt Enable bit mask
                                 .equ TWI_APIEN_bp = 6                    ; Address/Stop Interrupt Enable bit position
                                 .equ TWI_DIEN_bm = 0x80                  ; Data Interrupt Enable bit mask
                                 .equ TWI_DIEN_bp = 7                     ; Data Interrupt Enable bit position
                                 ; Masks for TWI_ENABLE already defined
                                 .equ TWI_PIEN_bm = 0x20                  ; Stop Interrupt Enable bit mask
                                 .equ TWI_PIEN_bp = 5                     ; Stop Interrupt Enable bit position
                                 .equ TWI_PMEN_bm = 0x04                  ; Promiscuous Mode Enable bit mask
                                 .equ TWI_PMEN_bp = 2                     ; Promiscuous Mode Enable bit position
                                 ; Masks for TWI_SMEN already defined
                                 
                                 ; TWI_SCTRLB masks
                                 ; Masks for TWI_ACKACT already defined
                                 .equ TWI_SCMD_gm = 0x03                  ; Command group mask
                                 .equ TWI_SCMD_gp = 0                     ; Command group position
                                 .equ TWI_SCMD0_bm = (1<<0)               ; Command bit 0 mask
                                 .equ TWI_SCMD0_bp = 0                    ; Command bit 0 position
                                 .equ TWI_SCMD1_bm = (1<<1)               ; Command bit 1 mask
                                 .equ TWI_SCMD1_bp = 1                    ; Command bit 1 position
                                 
                                 ; TWI_SSTATUS masks
                                 .equ TWI_AP_bm = 0x01                    ; Client Address or Stop bit mask
                                 .equ TWI_AP_bp = 0                       ; Client Address or Stop bit position
                                 .equ TWI_APIF_bm = 0x40                  ; Address/Stop Interrupt Flag bit mask
                                 .equ TWI_APIF_bp = 6                     ; Address/Stop Interrupt Flag bit position
                                 ; Masks for TWI_BUSERR already defined
                                 ; Masks for TWI_CLKHOLD already defined
                                 .equ TWI_COLL_bm = 0x08                  ; Collision bit mask
                                 .equ TWI_COLL_bp = 3                     ; Collision bit position
                                 .equ TWI_DIF_bm = 0x80                   ; Data Interrupt Flag bit mask
                                 .equ TWI_DIF_bp = 7                      ; Data Interrupt Flag bit position
                                 .equ TWI_DIR_bm = 0x02                   ; Read/Write Direction bit mask
                                 .equ TWI_DIR_bp = 1                      ; Read/Write Direction bit position
                                 ; Masks for TWI_RXACK already defined
                                 
                                 ; Input Voltage Transition Level select
                                 .equ TWI_DEFAULT_INPUTLVL_I2C_gc = (0x00<<6) ; I2C input voltage transition level
                                 .equ TWI_DEFAULT_INPUTLVL_SMBUS_gc = (0x01<<6) ; SMBus 3.0 input voltage transition level
                                 
                                 ; SDA Hold Time select
                                 .equ TWI_DEFAULT_SDAHOLD_OFF_gc = (0x00<<2) ; SDA hold time off
                                 .equ TWI_DEFAULT_SDAHOLD_50NS_gc = (0x01<<2) ; Typical 50ns hold time
                                 .equ TWI_DEFAULT_SDAHOLD_300NS_gc = (0x02<<2) ; Typical 300ns hold time
                                 .equ TWI_DEFAULT_SDAHOLD_500NS_gc = (0x03<<2) ; Typical 500ns hold time
                                 
                                 ; SDA Setup Time select
                                 .equ TWI_DEFAULT_SDASETUP_4CYC_gc = (0x00<<4) ; SDA setup time is 4 clock cycles
                                 .equ TWI_DEFAULT_SDASETUP_8CYC_gc = (0x01<<4) ; SDA setup time is 8 clock cycles
                                 
                                 ; Inactive Bus Timeout select
                                 .equ TWI_TIMEOUT_DISABLED_gc = (0x00<<2) ; Bus Timeout Disabled
                                 .equ TWI_TIMEOUT_50US_gc = (0x01<<2)     ; 50 Microseconds
                                 .equ TWI_TIMEOUT_100US_gc = (0x02<<2)    ; 100 Microseconds
                                 .equ TWI_TIMEOUT_200US_gc = (0x03<<2)    ; 200 Microseconds
                                 
                                 ; Acknowledge Action select
                                 .equ TWI_ACKACT_ACK_gc = (0x00<<2)       ; Send ACK
                                 .equ TWI_ACKACT_NACK_gc = (0x01<<2)      ; Send NACK
                                 
                                 ; Command select
                                 .equ TWI_MCMD_NOACT_gc = (0x00<<0)       ; No Action
                                 .equ TWI_MCMD_REPSTART_gc = (0x01<<0)    ; Issue Repeated Start Condition
                                 .equ TWI_MCMD_RECVTRANS_gc = (0x02<<0)   ; Receive or Transmit Data, depending on DIR
                                 .equ TWI_MCMD_STOP_gc = (0x03<<0)        ; Issue Stop Condition
                                 
                                 ; Bus State select
                                 .equ TWI_BUSSTATE_UNKNOWN_gc = (0x00<<0) ; Unknown Bus State
                                 .equ TWI_BUSSTATE_IDLE_gc = (0x01<<0)    ; Bus is Idle
                                 .equ TWI_BUSSTATE_OWNER_gc = (0x02<<0)   ; This Module Controls The Bus
                                 .equ TWI_BUSSTATE_BUSY_gc = (0x03<<0)    ; The Bus is Busy
                                 
                                 ; Command select
                                 .equ TWI_SCMD_NOACT_gc = (0x00<<0)       ; No Action
                                 .equ TWI_SCMD_COMPTRANS_gc = (0x02<<0)   ; Used To Complete a Transaction
                                 .equ TWI_SCMD_RESPONSE_gc = (0x03<<0)    ; Used in Response to Address/Data Interrupt
                                 
                                 ; Client Address or Stop select
                                 .equ TWI_AP_STOP_gc = (0x00<<0)          ; Stop condition generated APIF
                                 .equ TWI_AP_ADR_gc = (0x01<<0)           ; Address detection generated APIF
                                 
                                 
                                 ;*************************************************************************
                                 ;** USART - Universal Synchronous and Asynchronous Receiver and Transmitter
                                 ;*************************************************************************
                                 
                                 ; USART_CTRLA masks
                                 .equ USART_ABEIE_bm = 0x04               ; Auto-baud Error Interrupt Enable bit mask
                                 .equ USART_ABEIE_bp = 2                  ; Auto-baud Error Interrupt Enable bit position
                                 .equ USART_DREIE_bm = 0x20               ; Data Register Empty Interrupt Enable bit mask
                                 .equ USART_DREIE_bp = 5                  ; Data Register Empty Interrupt Enable bit position
                                 .equ USART_LBME_bm = 0x08                ; Loop-back Mode Enable bit mask
                                 .equ USART_LBME_bp = 3                   ; Loop-back Mode Enable bit position
                                 .equ USART_RS485_bm = 0x01               ; RS485 Mode internal transmitter bit mask
                                 .equ USART_RS485_bp = 0                  ; RS485 Mode internal transmitter bit position
                                 .equ USART_RXCIE_bm = 0x80               ; Receive Complete Interrupt Enable bit mask
                                 .equ USART_RXCIE_bp = 7                  ; Receive Complete Interrupt Enable bit position
                                 .equ USART_RXSIE_bm = 0x10               ; Receiver Start Frame Interrupt Enable bit mask
                                 .equ USART_RXSIE_bp = 4                  ; Receiver Start Frame Interrupt Enable bit position
                                 .equ USART_TXCIE_bm = 0x40               ; Transmit Complete Interrupt Enable bit mask
                                 .equ USART_TXCIE_bp = 6                  ; Transmit Complete Interrupt Enable bit position
                                 
                                 ; USART_CTRLB masks
                                 .equ USART_MPCM_bm = 0x01                ; Multi-processor Communication Mode bit mask
                                 .equ USART_MPCM_bp = 0                   ; Multi-processor Communication Mode bit position
                                 .equ USART_ODME_bm = 0x08                ; Open Drain Mode Enable bit mask
                                 .equ USART_ODME_bp = 3                   ; Open Drain Mode Enable bit position
                                 .equ USART_RXEN_bm = 0x80                ; Reciever enable bit mask
                                 .equ USART_RXEN_bp = 7                   ; Reciever enable bit position
                                 .equ USART_RXMODE_gm = 0x06              ; Receiver Mode group mask
                                 .equ USART_RXMODE_gp = 1                 ; Receiver Mode group position
                                 .equ USART_RXMODE0_bm = (1<<1)           ; Receiver Mode bit 0 mask
                                 .equ USART_RXMODE0_bp = 1                ; Receiver Mode bit 0 position
                                 .equ USART_RXMODE1_bm = (1<<2)           ; Receiver Mode bit 1 mask
                                 .equ USART_RXMODE1_bp = 2                ; Receiver Mode bit 1 position
                                 .equ USART_SFDEN_bm = 0x10               ; Start Frame Detection Enable bit mask
                                 .equ USART_SFDEN_bp = 4                  ; Start Frame Detection Enable bit position
                                 .equ USART_TXEN_bm = 0x40                ; Transmitter Enable bit mask
                                 .equ USART_TXEN_bp = 6                   ; Transmitter Enable bit position
                                 
                                 ; USART_CTRLC masks
                                 .equ USART_CMODE_gm = 0xC0               ; Communication Mode group mask
                                 .equ USART_CMODE_gp = 6                  ; Communication Mode group position
                                 .equ USART_CMODE0_bm = (1<<6)            ; Communication Mode bit 0 mask
                                 .equ USART_CMODE0_bp = 6                 ; Communication Mode bit 0 position
                                 .equ USART_CMODE1_bm = (1<<7)            ; Communication Mode bit 1 mask
                                 .equ USART_CMODE1_bp = 7                 ; Communication Mode bit 1 position
                                 .equ USART_UCPHA_bm = 0x02               ; SPI Host Mode, Clock Phase bit mask
                                 .equ USART_UCPHA_bp = 1                  ; SPI Host Mode, Clock Phase bit position
                                 .equ USART_UDORD_bm = 0x04               ; SPI Host Mode, Data Order bit mask
                                 .equ USART_UDORD_bp = 2                  ; SPI Host Mode, Data Order bit position
                                 .equ USART_CHSIZE_gm = 0x07              ; Character Size group mask
                                 .equ USART_CHSIZE_gp = 0                 ; Character Size group position
                                 .equ USART_CHSIZE0_bm = (1<<0)           ; Character Size bit 0 mask
                                 .equ USART_CHSIZE0_bp = 0                ; Character Size bit 0 position
                                 .equ USART_CHSIZE1_bm = (1<<1)           ; Character Size bit 1 mask
                                 .equ USART_CHSIZE1_bp = 1                ; Character Size bit 1 position
                                 .equ USART_CHSIZE2_bm = (1<<2)           ; Character Size bit 2 mask
                                 .equ USART_CHSIZE2_bp = 2                ; Character Size bit 2 position
                                 ; Masks for USART_CMODE already defined
                                 .equ USART_PMODE_gm = 0x30               ; Parity Mode group mask
                                 .equ USART_PMODE_gp = 4                  ; Parity Mode group position
                                 .equ USART_PMODE0_bm = (1<<4)            ; Parity Mode bit 0 mask
                                 .equ USART_PMODE0_bp = 4                 ; Parity Mode bit 0 position
                                 .equ USART_PMODE1_bm = (1<<5)            ; Parity Mode bit 1 mask
                                 .equ USART_PMODE1_bp = 5                 ; Parity Mode bit 1 position
                                 .equ USART_SBMODE_bm = 0x08              ; Stop Bit Mode bit mask
                                 .equ USART_SBMODE_bp = 3                 ; Stop Bit Mode bit position
                                 
                                 ; USART_CTRLD masks
                                 .equ USART_ABW_gm = 0xC0                 ; Auto Baud Window group mask
                                 .equ USART_ABW_gp = 6                    ; Auto Baud Window group position
                                 .equ USART_ABW0_bm = (1<<6)              ; Auto Baud Window bit 0 mask
                                 .equ USART_ABW0_bp = 6                   ; Auto Baud Window bit 0 position
                                 .equ USART_ABW1_bm = (1<<7)              ; Auto Baud Window bit 1 mask
                                 .equ USART_ABW1_bp = 7                   ; Auto Baud Window bit 1 position
                                 
                                 ; USART_DBGCTRL masks
                                 .equ USART_DBGRUN_bm = 0x01              ; Debug Run bit mask
                                 .equ USART_DBGRUN_bp = 0                 ; Debug Run bit position
                                 
                                 ; USART_EVCTRL masks
                                 .equ USART_IREI_bm = 0x01                ; IrDA Event Input Enable bit mask
                                 .equ USART_IREI_bp = 0                   ; IrDA Event Input Enable bit position
                                 
                                 ; USART_RXDATAH masks
                                 .equ USART_BUFOVF_bm = 0x40              ; Buffer Overflow bit mask
                                 .equ USART_BUFOVF_bp = 6                 ; Buffer Overflow bit position
                                 .equ USART_DATA8_bm = 0x01               ; Receiver Data Register bit mask
                                 .equ USART_DATA8_bp = 0                  ; Receiver Data Register bit position
                                 .equ USART_FERR_bm = 0x04                ; Frame Error bit mask
                                 .equ USART_FERR_bp = 2                   ; Frame Error bit position
                                 .equ USART_PERR_bm = 0x02                ; Parity Error bit mask
                                 .equ USART_PERR_bp = 1                   ; Parity Error bit position
                                 .equ USART_RXCIF_bm = 0x80               ; Receive Complete Interrupt Flag bit mask
                                 .equ USART_RXCIF_bp = 7                  ; Receive Complete Interrupt Flag bit position
                                 
                                 ; USART_RXDATAL masks
                                 .equ USART_DATA_gm = 0xFF                ; RX Data group mask
                                 .equ USART_DATA_gp = 0                   ; RX Data group position
                                 .equ USART_DATA0_bm = (1<<0)             ; RX Data bit 0 mask
                                 .equ USART_DATA0_bp = 0                  ; RX Data bit 0 position
                                 .equ USART_DATA1_bm = (1<<1)             ; RX Data bit 1 mask
                                 .equ USART_DATA1_bp = 1                  ; RX Data bit 1 position
                                 .equ USART_DATA2_bm = (1<<2)             ; RX Data bit 2 mask
                                 .equ USART_DATA2_bp = 2                  ; RX Data bit 2 position
                                 .equ USART_DATA3_bm = (1<<3)             ; RX Data bit 3 mask
                                 .equ USART_DATA3_bp = 3                  ; RX Data bit 3 position
                                 .equ USART_DATA4_bm = (1<<4)             ; RX Data bit 4 mask
                                 .equ USART_DATA4_bp = 4                  ; RX Data bit 4 position
                                 .equ USART_DATA5_bm = (1<<5)             ; RX Data bit 5 mask
                                 .equ USART_DATA5_bp = 5                  ; RX Data bit 5 position
                                 .equ USART_DATA6_bm = (1<<6)             ; RX Data bit 6 mask
                                 .equ USART_DATA6_bp = 6                  ; RX Data bit 6 position
                                 .equ USART_DATA7_bm = (1<<7)             ; RX Data bit 7 mask
                                 .equ USART_DATA7_bp = 7                  ; RX Data bit 7 position
                                 
                                 ; USART_RXPLCTRL masks
                                 .equ USART_RXPL_gm = 0x7F                ; Receiver Pulse Lenght group mask
                                 .equ USART_RXPL_gp = 0                   ; Receiver Pulse Lenght group position
                                 .equ USART_RXPL0_bm = (1<<0)             ; Receiver Pulse Lenght bit 0 mask
                                 .equ USART_RXPL0_bp = 0                  ; Receiver Pulse Lenght bit 0 position
                                 .equ USART_RXPL1_bm = (1<<1)             ; Receiver Pulse Lenght bit 1 mask
                                 .equ USART_RXPL1_bp = 1                  ; Receiver Pulse Lenght bit 1 position
                                 .equ USART_RXPL2_bm = (1<<2)             ; Receiver Pulse Lenght bit 2 mask
                                 .equ USART_RXPL2_bp = 2                  ; Receiver Pulse Lenght bit 2 position
                                 .equ USART_RXPL3_bm = (1<<3)             ; Receiver Pulse Lenght bit 3 mask
                                 .equ USART_RXPL3_bp = 3                  ; Receiver Pulse Lenght bit 3 position
                                 .equ USART_RXPL4_bm = (1<<4)             ; Receiver Pulse Lenght bit 4 mask
                                 .equ USART_RXPL4_bp = 4                  ; Receiver Pulse Lenght bit 4 position
                                 .equ USART_RXPL5_bm = (1<<5)             ; Receiver Pulse Lenght bit 5 mask
                                 .equ USART_RXPL5_bp = 5                  ; Receiver Pulse Lenght bit 5 position
                                 .equ USART_RXPL6_bm = (1<<6)             ; Receiver Pulse Lenght bit 6 mask
                                 .equ USART_RXPL6_bp = 6                  ; Receiver Pulse Lenght bit 6 position
                                 
                                 ; USART_STATUS masks
                                 .equ USART_BDF_bm = 0x02                 ; Break Detected Flag bit mask
                                 .equ USART_BDF_bp = 1                    ; Break Detected Flag bit position
                                 .equ USART_DREIF_bm = 0x20               ; Data Register Empty Flag bit mask
                                 .equ USART_DREIF_bp = 5                  ; Data Register Empty Flag bit position
                                 .equ USART_ISFIF_bm = 0x08               ; Inconsistent Sync Field Interrupt Flag bit mask
                                 .equ USART_ISFIF_bp = 3                  ; Inconsistent Sync Field Interrupt Flag bit position
                                 ; Masks for USART_RXCIF already defined
                                 .equ USART_RXSIF_bm = 0x10               ; Receive Start Interrupt bit mask
                                 .equ USART_RXSIF_bp = 4                  ; Receive Start Interrupt bit position
                                 .equ USART_TXCIF_bm = 0x40               ; Transmit Interrupt Flag bit mask
                                 .equ USART_TXCIF_bp = 6                  ; Transmit Interrupt Flag bit position
                                 .equ USART_WFB_bm = 0x01                 ; Wait For Break bit mask
                                 .equ USART_WFB_bp = 0                    ; Wait For Break bit position
                                 
                                 ; USART_TXDATAH masks
                                 ; Masks for USART_DATA8 already defined
                                 
                                 ; USART_TXDATAL masks
                                 ; Masks for USART_DATA already defined
                                 
                                 ; USART_TXPLCTRL masks
                                 .equ USART_TXPL_gm = 0xFF                ; Transmit pulse length group mask
                                 .equ USART_TXPL_gp = 0                   ; Transmit pulse length group position
                                 .equ USART_TXPL0_bm = (1<<0)             ; Transmit pulse length bit 0 mask
                                 .equ USART_TXPL0_bp = 0                  ; Transmit pulse length bit 0 position
                                 .equ USART_TXPL1_bm = (1<<1)             ; Transmit pulse length bit 1 mask
                                 .equ USART_TXPL1_bp = 1                  ; Transmit pulse length bit 1 position
                                 .equ USART_TXPL2_bm = (1<<2)             ; Transmit pulse length bit 2 mask
                                 .equ USART_TXPL2_bp = 2                  ; Transmit pulse length bit 2 position
                                 .equ USART_TXPL3_bm = (1<<3)             ; Transmit pulse length bit 3 mask
                                 .equ USART_TXPL3_bp = 3                  ; Transmit pulse length bit 3 position
                                 .equ USART_TXPL4_bm = (1<<4)             ; Transmit pulse length bit 4 mask
                                 .equ USART_TXPL4_bp = 4                  ; Transmit pulse length bit 4 position
                                 .equ USART_TXPL5_bm = (1<<5)             ; Transmit pulse length bit 5 mask
                                 .equ USART_TXPL5_bp = 5                  ; Transmit pulse length bit 5 position
                                 .equ USART_TXPL6_bm = (1<<6)             ; Transmit pulse length bit 6 mask
                                 .equ USART_TXPL6_bp = 6                  ; Transmit pulse length bit 6 position
                                 .equ USART_TXPL7_bm = (1<<7)             ; Transmit pulse length bit 7 mask
                                 .equ USART_TXPL7_bp = 7                  ; Transmit pulse length bit 7 position
                                 
                                 ; RS485 Mode internal transmitter select
                                 .equ USART_RS485_DISABLE_gc = (0x00<<0)  ; RS485 Mode disabled
                                 .equ USART_RS485_ENABLE_gc = (0x01<<0)   ; RS485 Mode enabled
                                 
                                 ; Receiver Mode select
                                 .equ USART_RXMODE_NORMAL_gc = (0x00<<1)  ; Normal mode
                                 .equ USART_RXMODE_CLK2X_gc = (0x01<<1)   ; CLK2x mode
                                 .equ USART_RXMODE_GENAUTO_gc = (0x02<<1) ; Generic autobaud mode
                                 .equ USART_RXMODE_LINAUTO_gc = (0x03<<1) ; LIN constrained autobaud mode
                                 
                                 ; Communication Mode select
                                 .equ USART_MSPI_CMODE_ASYNCHRONOUS_gc = (0x00<<6) ; Asynchronous Mode
                                 .equ USART_MSPI_CMODE_SYNCHRONOUS_gc = (0x01<<6) ; Synchronous Mode
                                 .equ USART_MSPI_CMODE_IRCOM_gc = (0x02<<6) ; Infrared Communication
                                 .equ USART_MSPI_CMODE_MSPI_gc = (0x03<<6) ; SPI Host Mode
                                 
                                 ; Character Size select
                                 .equ USART_NORMAL_CHSIZE_5BIT_gc = (0x00<<0) ; Character size: 5 bit
                                 .equ USART_NORMAL_CHSIZE_6BIT_gc = (0x01<<0) ; Character size: 6 bit
                                 .equ USART_NORMAL_CHSIZE_7BIT_gc = (0x02<<0) ; Character size: 7 bit
                                 .equ USART_NORMAL_CHSIZE_8BIT_gc = (0x03<<0) ; Character size: 8 bit
                                 .equ USART_NORMAL_CHSIZE_9BITL_gc = (0x06<<0) ; Character size: 9 bit read low byte first
                                 .equ USART_NORMAL_CHSIZE_9BITH_gc = (0x07<<0) ; Character size: 9 bit read high byte first
                                 
                                 ; Communication Mode select
                                 .equ USART_NORMAL_CMODE_ASYNCHRONOUS_gc = (0x00<<6) ; Asynchronous Mode
                                 .equ USART_NORMAL_CMODE_SYNCHRONOUS_gc = (0x01<<6) ; Synchronous Mode
                                 .equ USART_NORMAL_CMODE_IRCOM_gc = (0x02<<6) ; Infrared Communication
                                 .equ USART_NORMAL_CMODE_MSPI_gc = (0x03<<6) ; SPI Host Mode
                                 
                                 ; Parity Mode select
                                 .equ USART_NORMAL_PMODE_DISABLED_gc = (0x00<<4) ; No Parity
                                 .equ USART_NORMAL_PMODE_EVEN_gc = (0x02<<4) ; Even Parity
                                 .equ USART_NORMAL_PMODE_ODD_gc = (0x03<<4) ; Odd Parity
                                 
                                 ; Stop Bit Mode select
                                 .equ USART_NORMAL_SBMODE_1BIT_gc = (0x00<<3) ; 1 stop bit
                                 .equ USART_NORMAL_SBMODE_2BIT_gc = (0x01<<3) ; 2 stop bits
                                 
                                 ; Auto Baud Window select
                                 .equ USART_ABW_WDW0_gc = (0x00<<6)       ; 18% tolerance
                                 .equ USART_ABW_WDW1_gc = (0x01<<6)       ; 15% tolerance
                                 .equ USART_ABW_WDW2_gc = (0x02<<6)       ; 21% tolerance
                                 .equ USART_ABW_WDW3_gc = (0x03<<6)       ; 25% tolerance
                                 
                                 
                                 ;*************************************************************************
                                 ;** USERROW - User Row
                                 ;*************************************************************************
                                 
                                 
                                 ;*************************************************************************
                                 ;** VPORT - Virtual Ports
                                 ;*************************************************************************
                                 
                                 ; VPORT_INTFLAGS masks
                                 .equ VPORT_INT_gm = 0xFF                 ; Pin Interrupt group mask
                                 .equ VPORT_INT_gp = 0                    ; Pin Interrupt group position
                                 .equ VPORT_INT0_bm = (1<<0)              ; Pin Interrupt bit 0 mask
                                 .equ VPORT_INT0_bp = 0                   ; Pin Interrupt bit 0 position
                                 .equ VPORT_INT1_bm = (1<<1)              ; Pin Interrupt bit 1 mask
                                 .equ VPORT_INT1_bp = 1                   ; Pin Interrupt bit 1 position
                                 .equ VPORT_INT2_bm = (1<<2)              ; Pin Interrupt bit 2 mask
                                 .equ VPORT_INT2_bp = 2                   ; Pin Interrupt bit 2 position
                                 .equ VPORT_INT3_bm = (1<<3)              ; Pin Interrupt bit 3 mask
                                 .equ VPORT_INT3_bp = 3                   ; Pin Interrupt bit 3 position
                                 .equ VPORT_INT4_bm = (1<<4)              ; Pin Interrupt bit 4 mask
                                 .equ VPORT_INT4_bp = 4                   ; Pin Interrupt bit 4 position
                                 .equ VPORT_INT5_bm = (1<<5)              ; Pin Interrupt bit 5 mask
                                 .equ VPORT_INT5_bp = 5                   ; Pin Interrupt bit 5 position
                                 .equ VPORT_INT6_bm = (1<<6)              ; Pin Interrupt bit 6 mask
                                 .equ VPORT_INT6_bp = 6                   ; Pin Interrupt bit 6 position
                                 .equ VPORT_INT7_bm = (1<<7)              ; Pin Interrupt bit 7 mask
                                 .equ VPORT_INT7_bp = 7                   ; Pin Interrupt bit 7 position
                                 
                                 
                                 ;*************************************************************************
                                 ;** VREF - Voltage reference
                                 ;*************************************************************************
                                 
                                 ; VREF_ACREF masks
                                 .equ VREF_ALWAYSON_bm = 0x80             ; Always on bit mask
                                 .equ VREF_ALWAYSON_bp = 7                ; Always on bit position
                                 .equ VREF_REFSEL_gm = 0x07               ; Reference select group mask
                                 .equ VREF_REFSEL_gp = 0                  ; Reference select group position
                                 .equ VREF_REFSEL0_bm = (1<<0)            ; Reference select bit 0 mask
                                 .equ VREF_REFSEL0_bp = 0                 ; Reference select bit 0 position
                                 .equ VREF_REFSEL1_bm = (1<<1)            ; Reference select bit 1 mask
                                 .equ VREF_REFSEL1_bp = 1                 ; Reference select bit 1 position
                                 .equ VREF_REFSEL2_bm = (1<<2)            ; Reference select bit 2 mask
                                 .equ VREF_REFSEL2_bp = 2                 ; Reference select bit 2 position
                                 
                                 ; VREF_ADC0REF masks
                                 ; Masks for VREF_ALWAYSON already defined
                                 ; Masks for VREF_REFSEL already defined
                                 
                                 ; VREF_DAC0REF masks
                                 ; Masks for VREF_ALWAYSON already defined
                                 ; Masks for VREF_REFSEL already defined
                                 
                                 ; Reference select select
                                 .equ VREF_REFSEL_1V024_gc = (0x00<<0)    ; Internal 1.024V reference
                                 .equ VREF_REFSEL_2V048_gc = (0x01<<0)    ; Internal 2.048V reference
                                 .equ VREF_REFSEL_4V096_gc = (0x02<<0)    ; Internal 4.096V reference
                                 .equ VREF_REFSEL_2V500_gc = (0x03<<0)    ; Internal 2.500V reference
                                 .equ VREF_REFSEL_VDD_gc = (0x05<<0)      ; VDD as reference
                                 .equ VREF_REFSEL_VREFA_gc = (0x06<<0)    ; External reference on VREFA pin
                                 
                                 
                                 ;*************************************************************************
                                 ;** WDT - Watch-Dog Timer
                                 ;*************************************************************************
                                 
                                 ; WDT_CTRLA masks
                                 .equ WDT_PERIOD_gm = 0x0F                ; Period group mask
                                 .equ WDT_PERIOD_gp = 0                   ; Period group position
                                 .equ WDT_PERIOD0_bm = (1<<0)             ; Period bit 0 mask
                                 .equ WDT_PERIOD0_bp = 0                  ; Period bit 0 position
                                 .equ WDT_PERIOD1_bm = (1<<1)             ; Period bit 1 mask
                                 .equ WDT_PERIOD1_bp = 1                  ; Period bit 1 position
                                 .equ WDT_PERIOD2_bm = (1<<2)             ; Period bit 2 mask
                                 .equ WDT_PERIOD2_bp = 2                  ; Period bit 2 position
                                 .equ WDT_PERIOD3_bm = (1<<3)             ; Period bit 3 mask
                                 .equ WDT_PERIOD3_bp = 3                  ; Period bit 3 position
                                 .equ WDT_WINDOW_gm = 0xF0                ; Window group mask
                                 .equ WDT_WINDOW_gp = 4                   ; Window group position
                                 .equ WDT_WINDOW0_bm = (1<<4)             ; Window bit 0 mask
                                 .equ WDT_WINDOW0_bp = 4                  ; Window bit 0 position
                                 .equ WDT_WINDOW1_bm = (1<<5)             ; Window bit 1 mask
                                 .equ WDT_WINDOW1_bp = 5                  ; Window bit 1 position
                                 .equ WDT_WINDOW2_bm = (1<<6)             ; Window bit 2 mask
                                 .equ WDT_WINDOW2_bp = 6                  ; Window bit 2 position
                                 .equ WDT_WINDOW3_bm = (1<<7)             ; Window bit 3 mask
                                 .equ WDT_WINDOW3_bp = 7                  ; Window bit 3 position
                                 
                                 ; WDT_STATUS masks
                                 .equ WDT_LOCK_bm = 0x80                  ; Lock enable bit mask
                                 .equ WDT_LOCK_bp = 7                     ; Lock enable bit position
                                 .equ WDT_SYNCBUSY_bm = 0x01              ; Syncronization busy bit mask
                                 .equ WDT_SYNCBUSY_bp = 0                 ; Syncronization busy bit position
                                 
                                 ; Period select
                                 .equ WDT_PERIOD_OFF_gc = (0x00<<0)       ; Off
                                 .equ WDT_PERIOD_8CLK_gc = (0x01<<0)      ; 8 cycles (8ms)
                                 .equ WDT_PERIOD_16CLK_gc = (0x02<<0)     ; 16 cycles (16ms)
                                 .equ WDT_PERIOD_32CLK_gc = (0x03<<0)     ; 32 cycles (32ms)
                                 .equ WDT_PERIOD_64CLK_gc = (0x04<<0)     ; 64 cycles (64ms)
                                 .equ WDT_PERIOD_128CLK_gc = (0x05<<0)    ; 128 cycles (0.128s)
                                 .equ WDT_PERIOD_256CLK_gc = (0x06<<0)    ; 256 cycles (0.256s)
                                 .equ WDT_PERIOD_512CLK_gc = (0x07<<0)    ; 512 cycles (0.512s)
                                 .equ WDT_PERIOD_1KCLK_gc = (0x08<<0)     ; 1K cycles (1.0s)
                                 .equ WDT_PERIOD_2KCLK_gc = (0x09<<0)     ; 2K cycles (2.0s)
                                 .equ WDT_PERIOD_4KCLK_gc = (0x0A<<0)     ; 4K cycles (4.1s)
                                 .equ WDT_PERIOD_8KCLK_gc = (0x0B<<0)     ; 8K cycles (8.2s)
                                 
                                 ; Window select
                                 .equ WDT_WINDOW_OFF_gc = (0x00<<4)       ; Off
                                 .equ WDT_WINDOW_8CLK_gc = (0x01<<4)      ; 8 cycles (8ms)
                                 .equ WDT_WINDOW_16CLK_gc = (0x02<<4)     ; 16 cycles (16ms)
                                 .equ WDT_WINDOW_32CLK_gc = (0x03<<4)     ; 32 cycles (32ms)
                                 .equ WDT_WINDOW_64CLK_gc = (0x04<<4)     ; 64 cycles (64ms)
                                 .equ WDT_WINDOW_128CLK_gc = (0x05<<4)    ; 128 cycles (0.128s)
                                 .equ WDT_WINDOW_256CLK_gc = (0x06<<4)    ; 256 cycles (0.256s)
                                 .equ WDT_WINDOW_512CLK_gc = (0x07<<4)    ; 512 cycles (0.512s)
                                 .equ WDT_WINDOW_1KCLK_gc = (0x08<<4)     ; 1K cycles (1.0s)
                                 .equ WDT_WINDOW_2KCLK_gc = (0x09<<4)     ; 2K cycles (2.0s)
                                 .equ WDT_WINDOW_4KCLK_gc = (0x0A<<4)     ; 4K cycles (4.1s)
                                 .equ WDT_WINDOW_8KCLK_gc = (0x0B<<4)     ; 8K cycles (8.2s)
                                 
                                 
                                 ;*************************************************************************
                                 ;** ZCD - Zero Cross Detect
                                 ;*************************************************************************
                                 
                                 ; ZCD_CTRLA masks
                                 .equ ZCD_ENABLE_bm = 0x01                ; Enable bit mask
                                 .equ ZCD_ENABLE_bp = 0                   ; Enable bit position
                                 .equ ZCD_INVERT_bm = 0x08                ; Invert signal from pin bit mask
                                 .equ ZCD_INVERT_bp = 3                   ; Invert signal from pin bit position
                                 .equ ZCD_OUTEN_bm = 0x40                 ; Output Pad Enable bit mask
                                 .equ ZCD_OUTEN_bp = 6                    ; Output Pad Enable bit position
                                 .equ ZCD_RUNSTDBY_bm = 0x80              ; Run in Standby Mode bit mask
                                 .equ ZCD_RUNSTDBY_bp = 7                 ; Run in Standby Mode bit position
                                 
                                 ; ZCD_INTCTRL masks
                                 .equ ZCD_INTMODE_gm = 0x03               ; Interrupt Mode group mask
                                 .equ ZCD_INTMODE_gp = 0                  ; Interrupt Mode group position
                                 .equ ZCD_INTMODE0_bm = (1<<0)            ; Interrupt Mode bit 0 mask
                                 .equ ZCD_INTMODE0_bp = 0                 ; Interrupt Mode bit 0 position
                                 .equ ZCD_INTMODE1_bm = (1<<1)            ; Interrupt Mode bit 1 mask
                                 .equ ZCD_INTMODE1_bp = 1                 ; Interrupt Mode bit 1 position
                                 
                                 ; ZCD_STATUS masks
                                 .equ ZCD_CROSSIF_bm = 0x01               ; ZCD Interrupt Flag bit mask
                                 .equ ZCD_CROSSIF_bp = 0                  ; ZCD Interrupt Flag bit position
                                 .equ ZCD_STATE_bm = 0x10                 ; ZCD State bit mask
                                 .equ ZCD_STATE_bp = 4                    ; ZCD State bit position
                                 
                                 ; Interrupt Mode select
                                 .equ ZCD_INTMODE_NONE_gc = (0x00<<0)     ; No interrupt
                                 .equ ZCD_INTMODE_RISING_gc = (0x01<<0)   ; Interrupt on rising input signal
                                 .equ ZCD_INTMODE_FALLING_gc = (0x02<<0)  ; Interrupt on falling input signal
                                 .equ ZCD_INTMODE_BOTH_gc = (0x03<<0)     ; Interrupt on both rising and falling input signal
                                 
                                 ; ZCD State select
                                 .equ ZCD_STATE_LOW_gc = (0x00<<4)        ; Output is 0
                                 .equ ZCD_STATE_HIGH_gc = (0x01<<4)       ; Output is 1
                                 
                                 
                                 
                                 
                                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                                 .def	XH	= r27
                                 .def	XL	= r26
                                 .def	YH	= r29
                                 .def	YL	= r28
                                 .def	ZH	= r31
                                 .def	ZL	= r30
                                 
                                 
                                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                                 
                                 
                                 #define DATAMEM_START 0x0000
                                 #define DATAMEM_SIZE 0x10000
                                 #define DATAMEM_END (0x0000 + 0x10000 - 1)
                                 
                                 #define EEPROM_START 0x1400
                                 #define EEPROM_SIZE 0x0200
                                 #define EEPROM_END (0x1400 + 0x0200 - 1)
                                 #define EEPROM_PAGE_SIZE 0x01
                                 
                                 #define FUSES_START 0x1050
                                 #define FUSES_SIZE 0x0010
                                 #define FUSES_END (0x1050 + 0x0010 - 1)
                                 #define FUSES_PAGE_SIZE 0x01
                                 
                                 #define INTERNAL_SRAM_START 0x6000
                                 #define INTERNAL_SRAM_SIZE 0x2000
                                 #define INTERNAL_SRAM_END (0x6000 + 0x2000 - 1)
                                 
                                 #define IO_START 0x0000
                                 #define IO_SIZE 0x103F
                                 #define IO_END (0x0000 + 0x103F - 1)
                                 
                                 #define LOCKBITS_START 0x1040
                                 #define LOCKBITS_SIZE 0x0004
                                 #define LOCKBITS_END (0x1040 + 0x0004 - 1)
                                 #define LOCKBITS_PAGE_SIZE 0x01
                                 
                                 #define MAPPED_PROGMEM_START 0x8000
                                 #define MAPPED_PROGMEM_SIZE 0x8000
                                 #define MAPPED_PROGMEM_END (0x8000 + 0x8000 - 1)
                                 #define MAPPED_PROGMEM_PAGE_SIZE 0x200
                                 
                                 #define PROD_SIGNATURES_START 0x1103
                                 #define PROD_SIGNATURES_SIZE 0x007D
                                 #define PROD_SIGNATURES_END (0x1103 + 0x007D - 1)
                                 #define PROD_SIGNATURES_PAGE_SIZE 0x80
                                 
                                 #define SIGNATURES_START 0x1100
                                 #define SIGNATURES_SIZE 0x0003
                                 #define SIGNATURES_END (0x1100 + 0x0003 - 1)
                                 #define SIGNATURES_PAGE_SIZE 0x80
                                 
                                 #define USER_SIGNATURES_START 0x1080
                                 #define USER_SIGNATURES_SIZE 0x0020
                                 #define USER_SIGNATURES_END (0x1080 + 0x0020 - 1)
                                 #define USER_SIGNATURES_PAGE_SIZE 0x20
                                 
                                 #define PROGMEM_START 0x0000
                                 #define PROGMEM_SIZE 0x10000
                                 #define PROGMEM_END (0x0000 + 0x10000 - 1)
                                 #define PROGMEM_PAGE_SIZE 0x200
                                 
                                 
                                 ; Legacy definitions
                                 .equ    FLASHSTART    = (PROGMEM_START / 2) ; Note: Word address
                                 .equ    FLASHEND      = (PROGMEM_END / 2) ; Note: Word address
                                 .equ    IOEND         = IO_END
                                 .equ    SRAM_START    = INTERNAL_SRAM_START
                                 .equ    SRAM_SIZE     = INTERNAL_SRAM_SIZE
                                 .equ    RAMEND        = INTERNAL_SRAM_END
                                 .equ    E2END         = EEPROM_END
                                 .equ    EEPROMEND     = EEPROM_END
                                 
                                 
                                 ; Definitions used by the assembler
                                 #pragma AVRPART MEMORY PROG_FLASH 0x10000
                                 #pragma AVRPART MEMORY EEPROM 0x0200
                                 #pragma AVRPART MEMORY INT_SRAM SIZE 0x2000
                                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x6000
                                 
                                 ; ***** INTERRUPT VECTORS, ABSOLUTE ADDRESSES ****************************
                                 ; NMI interrupt vectors
                                 .equ NMI_vect = 0x0002                   ; 
                                 
                                 ; BOD interrupt vectors
                                 .equ BOD_VLM_vect = 0x0004               ; 
                                 
                                 ; CLKCTRL interrupt vectors
                                 .equ CLKCTRL_CFD_vect = 0x0006           ; 
                                 
                                 ; MVIO interrupt vectors
                                 .equ MVIO_MVIO_vect = 0x0008             ; 
                                 
                                 ; RTC interrupt vectors
                                 .equ RTC_CNT_vect = 0x000A               ; 
                                 .equ RTC_PIT_vect = 0x000C               ; 
                                 
                                 ; CCL interrupt vectors
                                 .equ CCL_CCL_vect = 0x000E               ; 
                                 
                                 ; PORTA interrupt vectors
                                 .equ PORTA_PORT_vect = 0x0010            ; 
                                 
                                 ; TCA0 interrupt vectors
                                 .equ TCA0_LUNF_vect = 0x0012             ; 
                                 .equ TCA0_OVF_vect = 0x0012              ; 
                                 .equ TCA0_HUNF_vect = 0x0014             ; 
                                 .equ TCA0_CMP0_vect = 0x0016             ; 
                                 .equ TCA0_LCMP0_vect = 0x0016            ; 
                                 .equ TCA0_CMP1_vect = 0x0018             ; 
                                 .equ TCA0_LCMP1_vect = 0x0018            ; 
                                 .equ TCA0_CMP2_vect = 0x001A             ; 
                                 .equ TCA0_LCMP2_vect = 0x001A            ; 
                                 
                                 ; TCB0 interrupt vectors
                                 .equ TCB0_INT_vect = 0x001C              ; 
                                 
                                 ; TCB1 interrupt vectors
                                 .equ TCB1_INT_vect = 0x001E              ; 
                                 
                                 ; TCD0 interrupt vectors
                                 .equ TCD0_OVF_vect = 0x0020              ; 
                                 .equ TCD0_TRIG_vect = 0x0022             ; 
                                 
                                 ; TWI0 interrupt vectors
                                 .equ TWI0_TWIS_vect = 0x0024             ; 
                                 .equ TWI0_TWIM_vect = 0x0026             ; 
                                 
                                 ; SPI0 interrupt vectors
                                 .equ SPI0_INT_vect = 0x0028              ; 
                                 
                                 ; USART0 interrupt vectors
                                 .equ USART0_RXC_vect = 0x002A            ; 
                                 .equ USART0_DRE_vect = 0x002C            ; 
                                 .equ USART0_TXC_vect = 0x002E            ; 
                                 
                                 ; PORTD interrupt vectors
                                 .equ PORTD_PORT_vect = 0x0030            ; 
                                 
                                 ; AC0 interrupt vectors
                                 .equ AC0_AC_vect = 0x0032                ; 
                                 
                                 ; ADC0 interrupt vectors
                                 .equ ADC0_RESRDY_vect = 0x0034           ; 
                                 .equ ADC0_WCMP_vect = 0x0036             ; 
                                 
                                 ; ZCD0 interrupt vectors
                                 .equ ZCD0_ZCD_vect = 0x0038              ; 
                                 
                                 ; AC1 interrupt vectors
                                 .equ AC1_AC_vect = 0x003A                ; 
                                 
                                 ; PORTC interrupt vectors
                                 .equ PORTC_PORT_vect = 0x003C            ; 
                                 
                                 ; TCB2 interrupt vectors
                                 .equ TCB2_INT_vect = 0x003E              ; 
                                 
                                 ; USART1 interrupt vectors
                                 .equ USART1_RXC_vect = 0x0040            ; 
                                 .equ USART1_DRE_vect = 0x0042            ; 
                                 .equ USART1_TXC_vect = 0x0044            ; 
                                 
                                 ; PORTF interrupt vectors
                                 .equ PORTF_PORT_vect = 0x0046            ; 
                                 
                                 ; NVMCTRL interrupt vectors
                                 .equ NVMCTRL_EE_vect = 0x0048            ; 
                                 
                                 ; SPI1 interrupt vectors
                                 .equ SPI1_INT_vect = 0x004A              ; 
                                 
                                 ; USART2 interrupt vectors
                                 .equ USART2_RXC_vect = 0x004C            ; 
                                 .equ USART2_DRE_vect = 0x004E            ; 
                                 .equ USART2_TXC_vect = 0x0050            ; 
                                 
                                 ; AC2 interrupt vectors
                                 .equ AC2_AC_vect = 0x0052                ; 
                                 
                                 ; TWI1 interrupt vectors
                                 .equ TWI1_TWIS_vect = 0x0054             ; 
                                 .equ TWI1_TWIM_vect = 0x0056             ; 
                                 
                                 ; TCB3 interrupt vectors
                                 .equ TCB3_INT_vect = 0x0058              ; 
                                 
                                 ; PORTB interrupt vectors
                                 .equ PORTB_PORT_vect = 0x005A            ; 
                                 
                                 ; PORTE interrupt vectors
                                 .equ PORTE_PORT_vect = 0x005C            ; 
                                 
                                 ; TCA1 interrupt vectors
                                 .equ TCA1_LUNF_vect = 0x005E             ; 
                                 .equ TCA1_OVF_vect = 0x005E              ; 
                                 .equ TCA1_HUNF_vect = 0x0060             ; 
                                 .equ TCA1_CMP0_vect = 0x0062             ; 
                                 .equ TCA1_LCMP0_vect = 0x0062            ; 
                                 .equ TCA1_CMP1_vect = 0x0064             ; 
                                 .equ TCA1_LCMP1_vect = 0x0064            ; 
                                 .equ TCA1_CMP2_vect = 0x0066             ; 
                                 .equ TCA1_LCMP2_vect = 0x0066            ; 
                                 
                                 ; ZCD1 interrupt vectors
                                 .equ ZCD1_ZCD_vect = 0x0068              ; 
                                 
                                 ; USART3 interrupt vectors
                                 .equ USART3_RXC_vect = 0x006A            ; 
                                 .equ USART3_DRE_vect = 0x006C            ; 
                                 .equ USART3_TXC_vect = 0x006E            ; 
                                 
                                 ; USART4 interrupt vectors
                                 .equ USART4_RXC_vect = 0x0070            ; 
                                 .equ USART4_DRE_vect = 0x0072            ; 
                                 .equ USART4_TXC_vect = 0x0074            ; 
                                 
                                 ; PORTG interrupt vectors
                                 .equ PORTG_PORT_vect = 0x0076            ; 
                                 
                                 ; ZCD2 interrupt vectors
                                 .equ ZCD2_ZCD_vect = 0x0078              ; 
                                 
                                 ; TCB4 interrupt vectors
                                 .equ TCB4_INT_vect = 0x007A              ; 
                                 
                                 ; USART5 interrupt vectors
                                 .equ USART5_RXC_vect = 0x007C            ; 
                                 .equ USART5_DRE_vect = 0x007E            ; 
                                 .equ USART5_TXC_vect = 0x0080            ; 
                                 
                                 
                                 
                                 ; ***** INTERRUPT VECTORS, MODULE BASES **********************************
                                 
                                 .equ NMI_vbase = 0x0002
                                 .equ BOD_vbase = 0x0004
                                 .equ CLKCTRL_vbase = 0x0006
                                 .equ MVIO_vbase = 0x0008
                                 .equ RTC_vbase = 0x000A
                                 .equ CCL_vbase = 0x000E
                                 .equ PORTA_vbase = 0x0010
                                 .equ TCA0_vbase = 0x0012
                                 .equ TCB0_vbase = 0x001C
                                 .equ TCB1_vbase = 0x001E
                                 .equ TCD0_vbase = 0x0020
                                 .equ TWI0_vbase = 0x0024
                                 .equ SPI0_vbase = 0x0028
                                 .equ USART0_vbase = 0x002A
                                 .equ PORTD_vbase = 0x0030
                                 .equ AC0_vbase = 0x0032
                                 .equ ADC0_vbase = 0x0034
                                 .equ ZCD0_vbase = 0x0038
                                 .equ AC1_vbase = 0x003A
                                 .equ PORTC_vbase = 0x003C
                                 .equ TCB2_vbase = 0x003E
                                 .equ USART1_vbase = 0x0040
                                 .equ PORTF_vbase = 0x0046
                                 .equ NVMCTRL_vbase = 0x0048
                                 .equ SPI1_vbase = 0x004A
                                 .equ USART2_vbase = 0x004C
                                 .equ AC2_vbase = 0x0052
                                 .equ TWI1_vbase = 0x0054
                                 .equ TCB3_vbase = 0x0058
                                 .equ PORTB_vbase = 0x005A
                                 .equ PORTE_vbase = 0x005C
                                 .equ TCA1_vbase = 0x005E
                                 .equ ZCD1_vbase = 0x0068
                                 .equ USART3_vbase = 0x006A
                                 .equ USART4_vbase = 0x0070
                                 .equ PORTG_vbase = 0x0076
                                 .equ ZCD2_vbase = 0x0078
                                 .equ TCB4_vbase = 0x007A
                                 .equ USART5_vbase = 0x007C
                                 
                                 
                                 ; ***** INTERRUPT VECTORS, VECTOR OFFSETS ********************************
                                 
                                 ; NMI interrupt vector offsets
                                 
                                 .equ NMI_voffset = 0
                                 
                                 ; BOD interrupt vector offsets
                                 
                                 .equ BOD_VLM_voffset = 0
                                 
                                 ; CLKCTRL interrupt vector offsets
                                 
                                 .equ CLKCTRL_CFD_voffset = 0
                                 
                                 ; MVIO interrupt vector offsets
                                 
                                 .equ MVIO_MVIO_voffset = 0
                                 
                                 ; RTC interrupt vector offsets
                                 
                                 .equ RTC_CNT_voffset = 0
                                 .equ RTC_PIT_voffset = 2
                                 
                                 ; CCL interrupt vector offsets
                                 
                                 .equ CCL_CCL_voffset = 0
                                 
                                 ; PORTA interrupt vector offsets
                                 
                                 .equ PORTA_PORT_voffset = 0
                                 
                                 ; TCA0 interrupt vector offsets
                                 
                                 .equ TCA0_LUNF_voffset = 0
                                 .equ TCA0_OVF_voffset = 0
                                 .equ TCA0_HUNF_voffset = 2
                                 .equ TCA0_CMP0_voffset = 4
                                 .equ TCA0_LCMP0_voffset = 4
                                 .equ TCA0_CMP1_voffset = 6
                                 .equ TCA0_LCMP1_voffset = 6
                                 .equ TCA0_CMP2_voffset = 8
                                 .equ TCA0_LCMP2_voffset = 8
                                 
                                 ; TCB0 interrupt vector offsets
                                 
                                 .equ TCB0_INT_voffset = 0
                                 
                                 ; TCB1 interrupt vector offsets
                                 
                                 .equ TCB1_INT_voffset = 0
                                 
                                 ; TCD0 interrupt vector offsets
                                 
                                 .equ TCD0_OVF_voffset = 0
                                 .equ TCD0_TRIG_voffset = 2
                                 
                                 ; TWI0 interrupt vector offsets
                                 
                                 .equ TWI0_TWIS_voffset = 0
                                 .equ TWI0_TWIM_voffset = 2
                                 
                                 ; SPI0 interrupt vector offsets
                                 
                                 .equ SPI0_INT_voffset = 0
                                 
                                 ; USART0 interrupt vector offsets
                                 
                                 .equ USART0_RXC_voffset = 0
                                 .equ USART0_DRE_voffset = 2
                                 .equ USART0_TXC_voffset = 4
                                 
                                 ; PORTD interrupt vector offsets
                                 
                                 .equ PORTD_PORT_voffset = 0
                                 
                                 ; AC0 interrupt vector offsets
                                 
                                 .equ AC0_AC_voffset = 0
                                 
                                 ; ADC0 interrupt vector offsets
                                 
                                 .equ ADC0_RESRDY_voffset = 0
                                 .equ ADC0_WCMP_voffset = 2
                                 
                                 ; ZCD0 interrupt vector offsets
                                 
                                 .equ ZCD0_ZCD_voffset = 0
                                 
                                 ; AC1 interrupt vector offsets
                                 
                                 .equ AC1_AC_voffset = 0
                                 
                                 ; PORTC interrupt vector offsets
                                 
                                 .equ PORTC_PORT_voffset = 0
                                 
                                 ; TCB2 interrupt vector offsets
                                 
                                 .equ TCB2_INT_voffset = 0
                                 
                                 ; USART1 interrupt vector offsets
                                 
                                 .equ USART1_RXC_voffset = 0
                                 .equ USART1_DRE_voffset = 2
                                 .equ USART1_TXC_voffset = 4
                                 
                                 ; PORTF interrupt vector offsets
                                 
                                 .equ PORTF_PORT_voffset = 0
                                 
                                 ; NVMCTRL interrupt vector offsets
                                 
                                 .equ NVMCTRL_EE_voffset = 0
                                 
                                 ; SPI1 interrupt vector offsets
                                 
                                 .equ SPI1_INT_voffset = 0
                                 
                                 ; USART2 interrupt vector offsets
                                 
                                 .equ USART2_RXC_voffset = 0
                                 .equ USART2_DRE_voffset = 2
                                 .equ USART2_TXC_voffset = 4
                                 
                                 ; AC2 interrupt vector offsets
                                 
                                 .equ AC2_AC_voffset = 0
                                 
                                 ; TWI1 interrupt vector offsets
                                 
                                 .equ TWI1_TWIS_voffset = 0
                                 .equ TWI1_TWIM_voffset = 2
                                 
                                 ; TCB3 interrupt vector offsets
                                 
                                 .equ TCB3_INT_voffset = 0
                                 
                                 ; PORTB interrupt vector offsets
                                 
                                 .equ PORTB_PORT_voffset = 0
                                 
                                 ; PORTE interrupt vector offsets
                                 
                                 .equ PORTE_PORT_voffset = 0
                                 
                                 ; TCA1 interrupt vector offsets
                                 
                                 .equ TCA1_LUNF_voffset = 0
                                 .equ TCA1_OVF_voffset = 0
                                 .equ TCA1_HUNF_voffset = 2
                                 .equ TCA1_CMP0_voffset = 4
                                 .equ TCA1_LCMP0_voffset = 4
                                 .equ TCA1_CMP1_voffset = 6
                                 .equ TCA1_LCMP1_voffset = 6
                                 .equ TCA1_CMP2_voffset = 8
                                 .equ TCA1_LCMP2_voffset = 8
                                 
                                 ; ZCD1 interrupt vector offsets
                                 
                                 .equ ZCD1_ZCD_voffset = 0
                                 
                                 ; USART3 interrupt vector offsets
                                 
                                 .equ USART3_RXC_voffset = 0
                                 .equ USART3_DRE_voffset = 2
                                 .equ USART3_TXC_voffset = 4
                                 
                                 ; USART4 interrupt vector offsets
                                 
                                 .equ USART4_RXC_voffset = 0
                                 .equ USART4_DRE_voffset = 2
                                 .equ USART4_TXC_voffset = 4
                                 
                                 ; PORTG interrupt vector offsets
                                 
                                 .equ PORTG_PORT_voffset = 0
                                 
                                 ; ZCD2 interrupt vector offsets
                                 
                                 .equ ZCD2_ZCD_voffset = 0
                                 
                                 ; TCB4 interrupt vector offsets
                                 
                                 .equ TCB4_INT_voffset = 0
                                 
                                 ; USART5 interrupt vector offsets
                                 
                                 .equ USART5_RXC_voffset = 0
                                 .equ USART5_DRE_voffset = 2
                                 .equ USART5_TXC_voffset = 4
                                 
                                 
                                 
                                 .equ INT_VECTORS_SIZE = 130 ; size in words
                                 
                                 
                                 #endif /* _AVR64DB64DEF_INC_ */
                                 
                                 ; ***** END OF FILE ******************************************************
                                 
                                 
                                 
                                 
                                 ;Select the "LPT Adapter" or "Terminal Adapter" Solution configuration depending on hardware
                                 
                                 ;##########################################################################################################################
                                 ;Fuse configuration:
                                 ;Bootsize: 0x02 / Bootloader size 1024 bytes
                                 ;WDTCFG:   0x09 / Watchdog 2 seconds
                                 
                                 ;##########################################################################################################################
                                 .equ	Clock		= 24000000
                                 .equ	Baud		= 1000000
                                 .equ	USB_In		= USART0_RXDATAL
                                 .equ	USB_Out		= USART0_TXDATAL
                                 .equ	USB_State	= USART0_STATUS
                                 .equ	USB_Baud	= USART0_BAUD
                                 .equ	USB_CB		= USART0_CTRLB
                                 .equ	USB_CC		= USART0_CTRLC
                                 .equ	USB_Mux		= PORTMUX_USARTROUTEA
                                 .equ	USB_Dir		= PORTA_DIRSET
                                 .equ	USB_TX_Pin	= 4
                                 ;						  R0		;Reserved for SPM
                                 ;						  R1		;Reserved for SPM
                                 .def	T1				= R16		;Multi purpose temporary register 1
                                 .def	T2				= R17		;Multi purpose temporary register 2
                                 .def	Count			= R18		;Counter register
                                 .def	MEM_Page		= R19		;Current memory page
                                 .def	R_Zero			= R20		;Constant 0 Value
                                 .def	R_CCP			= R21		;Constant CPU_CCP_IOREG_GC Value
                                 
                                 .include "Macros.asm"
                                 
                                 ;LXW		LOAD  X		REGISTER WITH	WORD VALUE
                                 ;LZW		LOAD  Z		REGISTER WITH	WORD VALUE
                                 
                                 ;WR			WRITE		REGISTER TO		IO / MEM BYTE
                                 ;WV			WRITE BYTE	VALUE	 TO		IO / MEM BYTE
                                 ;WW			WRITE WORD	VALUE	 TO		IO / MEM WORD
                                 
                                 ;CCP_WRITE	WRITE BYTE VALUE TO A CONFIGURATION CHANGE PROTECTED REGISTER
                                 ;SPM_WRITE	WRITE BYTE VALUE TO THE PROTECTED NVM CONTROLLER REGISTER
                                 
                                 ;Wait_BIT_SET	WAIT FOR BIT IN IO TO SET
                                 ;Wait_BIT_CLR	WAIT FOR BIT IN IO TO CLEAR
                                 
                                 .MACRO LR				
                                 	.if @1 < 0x40
                                 		IN	@0,@1
                                 	.else
                                 		LDS	@0,@1
                                 	.endif
                                 .ENDMACRO
                                 
                                 .MACRO LXW
                                 		LDI    XL, LOW(@0)
                                         LDI    XH, HIGH(@0)		         
                                 .ENDMACRO
                                 
                                 .MACRO LZW 
                                 		LDI    ZL, LOW(@0)
                                         LDI    ZH, HIGH(@0)		         
                                 .ENDMACRO
                                 
                                 .MACRO WR
                                 	.if @0 < 0x40
                                 		OUT	@0,@1
                                 	.else
                                 		STS	@0,@1
                                 	.endif
                                 .ENDMACRO
                                 
                                 .MACRO WV
                                 		LDI T1,@1
                                 		WR	@0,T1
                                 .ENDMACRO
                                 
                                 .MACRO WW
                                 		WV @0,   LOW(@1)
                                 		WV @0+1,HIGH(@1)
                                 .ENDMACRO
                                 
                                 
                                 .MACRO CCP_WRITE
                                 	WR		CPU_CCP,R_CCP
                                 	LDI		T1,@1					
                                 	WR		@0,T1
                                 .ENDMACRO
                                 
                                 .MACRO Wait_BIT_SET
                                 	WBS:	LR		T1,@0
                                 			SBRS	T1,@1
                                 			RJMP	 WBS
                                 .ENDMACRO
                                 
                                 .MACRO Wait_BIT_CLR
                                 	WBC:	LR		T1,@0
                                 			SBRC	T1,@1
                                 			RJMP	WBC
                                 
                                 ;Reset 13.07.24##########################################################################################################################
                                 RESET:
000000 94f8                      	CLI												;Disable interrupts
000001 ef0f
000002 bf0d
000003 e70f
000004 bf0e                      	WW		CPU_SPL,RAMEND							;Set stack pointer
000005 e040                      	LDI		R_Zero,0								;Load 0 Constant to R_Zero
000006 ed58                      	LDI		R_CCP,CPU_CCP_IOREG_GC					;Load CPU_CCP_IOREG_GC Constant to R_CCP
                                 
                                 ;Init Clock 13.07.24##########################################################################################################################
000007 9100 1401                 	LR		T1,EEPROM_START+1										;Should we try to start the external oscillator? Load EEProm clock configuration byte @EEPROM_START+1.
000009 3f0f
00000a f089                      	CPI		T1,255 BREQ OSC_INT_CLK									;If 255 (default value of unwritten EEProm cells) skip external clock startup and go to internal clock startup (e.g. in case other things than an oscillator are connected to the XTAL pins)
                                 
00000b bf54
00000c eb09
00000d 9300 0080                 			CCP_Write CLKCTRL_XOSCHFCTRLA,0b10111001				;Enable external HF oscillator
00000f e0a0
000010 e0b8                      			LXW 2048												;Set timeout in X Register pair to 2048 tries
000011 9711
000012 f049                      OSC_W_X24:	SBIW X,1 BREQ OSC_INT_CLK								;If timeout passed then no external clock available -> go to internal clock startup		
000013 9100 0065                 			LR T1,CLKCTRL_MCLKSTATUS								;Test if clock is stabilized
000015 ff04
000016 cffa                      			SBRS T1,4	RJMP OSC_W_X24								;No? Keep looping
                                 
000017 bf54
000018 e003
000019 9300 0060                 			CCP_Write CLKCTRL_MCLKCTRLA,CLKCTRL_CLKSEL_EXTCLK_GC	;Switch to external HF oscillator / No need to wait for the switch to complete - makes no difference if the next instructions still execute on the old clock
00001b c00c                      			RJMP OSC_INIT_END
                                 
                                 OSC_INT_CLK:												;In case no external HF oscillator is availabe switch to the internal 24MHz clock
00001c bf54
00001d ea04
00001e 9300 0068                 	CCP_Write		CLKCTRL_OSCHFCTRLA,0b10100100			;Set internal OSC to 24MHz
000020 9100 0065
000022 ff01
000023 cffc                      	Wait_BIT_SET	CLKCTRL_MCLKSTATUS,1					;Wait for OSC stabilization
000024 bf54
000025 e000
000026 9300 0060                 	CCP_Write		CLKCTRL_MCLKCTRLA,0						;Switch to internal OSC / No need to wait for the switch to complete
                                 
                                 OSC_INIT_END:
                                 
                                 ;Init USART 13.07.24##########################################################################################################################
000028 e001
000029 9300 05e2                 	WV USB_MUX,		0b00000001								;Alternative pin location USART0 PA4/PA5
00002b e600
00002c 9300 0808
00002e e000
00002f 9300 0809                 	WW USB_BAUD,	(64*Clock)/(16*Baud)					;Baudrate...
000031 e003
000032 9300 0807                 	WV USB_CC,		0b00000011								;8 Bit / 1 Stopbit...
000034 e100
000035 9300 0401                 	WV USB_DIR,		(1<<USB_TX_Pin)							;TX Pin as output....
000037 ec00
000038 9300 0806                 	WV USB_CB,		0b11000000								;Enable transmitter and receiver
                                 
                                 ;Main Loop 13.07.24##########################################################################################################################
                                 Main:
00003a d067                      	RCALL		RX_Wait	
00003b 3004
00003c f7e8                      	CPI			T1,4	BRSH Main			;Check if command is valid - if not go back to main loop
00003d e4e1
00003e e0f0                      	LZW			JT							;Load Jump table address to Z
00003f 0fe0                      	ADD			ZL,T1						;Add command to address / Ignore carry - no risk of segment crossing here
000040 9409                      	IJMP 									;Jump into table
000041 c1be                      JT:	RJMP		0x0200						;0 Jump to App Section / leave bootloader
000042 c002                      	RJMP		Identify					;1 Jump to Identify command
000043 c008                      	RJMP		Write_Page					;2 Jump to Write Page command
000044 c045                      	RJMP		Read_Page					;3 Jump to Read Page command
                                 
                                 ;##########################################################################################################################
                                 Identify:									;Send identification string
000045 e6ec
000046 e0f1                      				LZW		ID_Start*2	
000047 9115                      IL:				LPM		T2,Z+ 	
000048 d061                      				RCALL	TX_Wait		
000049 38ec
00004a f7e1                      				CPI		ZL,Low(ID_End*2)	BRNE IL	
00004b cfee                      RJMP Main
                                 
                                 ;##########################################################################################################################
                                 Write_Page:
00004c e6ec
00004d e0f1                      	LZW		ID_Start*2							;Protect against accidential writes by verifying against identification string
00004e 9115                      VL:	LPM		T2,Z+ 	
00004f d052                      	RCALL	RX_Wait	
000050 1701
000051 f741                      	CP		T1,T2 BRNE Main						;Back to main loop if ID not matching
000052 38ec
000053 f7d1                      	CPI		ZL,Low(ID_End*2) BRNE VL
                                 
000054 d03c                      	RCALL	Get_Z_Addr							;Receive the page to write and calculate Z pointer address
                                 	
000055 3030
000056 f419                      	CPI		MEM_Page,0	BRNE WFL				;EEprom or Flash?
                                 
000057 e113
000058 d058                      WEE:	LDI	T2,0x13	RCALL SPM_Write				;Page = 0 -> EEProm -> Erase and write command
000059 c00b                      		RJMP	RB
                                 
00005a e018
00005b d055                      WFL:	LDI	T2,0x08	RCALL SPM_Write				;Page <> 0 -> Flash -> Page erase Command								
00005c 95e8                      		SPM										;Page Erase Execute
00005d 9100 1002
00005f fd00
000060 cffc                      		Wait_BIT_CLR NVMCTRL_Status,0			;Wait completion
000061 e010
000062 d04e                      		LDI	T2,0x00	RCALL SPM_Write				;NOP Command
000063 e012
000064 d04c                      		LDI	T2,0x02	RCALL SPM_Write				;Page Write Command
                                 	
000065 e001
000066 9300 0802                 RB:	WV		USB_Out,1							;Signal ready to receive
000068 e020                      	LDI		Count,0								;Read 256 x 2 bytes...
000069 e0a0
00006a e6b0                      	LXW	Buffer									;AVR64DB programs slowly - data arrives faster than programming is possible -> read data first, then program
00006b d036
00006c 930d                      LB:		RCALL	RX_Wait	ST X+,T1					
00006d d034
00006e 930d                      		RCALL	RX_Wait	ST X+,T1
00006f 952a
000070 f7d1                      		DEC		Count	BRNE LB
                                 
000071 e020                      	LDI		Count,0								;Program 256 x 2 bytes...
000072 e0a0
000073 e6b0                      	LXW		Buffer
000074 95a8                      WL:		WDR										;Write Loop / EEProm programming takes about 5 seconds - prevent the watchdog from triggering in the meantime.
000075 900d                      		LD		R0,X+							;Load from Buffer to R0 and R1
000076 901d                      		LD		R1,X+
000077 3030
000078 f019                      		CPI		MEM_Page,0 BREQ PEE				;Flash or EEProm?
000079 95e8                      PFL:		SPM									;Store to Flash
00007a 9632                      			ADIW	Z,2							;Inc Z
00007b c002                      			RJMP PN
00007c 9201                      PEE:		ST	Z+,R0							;Store to EEProm
00007d 9211                      			ST	Z+,R1
00007e 952a
00007f f7a1                      PN:	DEC Count BRNE WL
                                 			
000080 9100 1002
000082 fd00
000083 cffc                      	Wait_BIT_CLR NVMCTRL_Status,0				;Wait till complete
000084 e010
000085 d02b                      	LDI	T2,0x00	RCALL SPM_Write					;Send NOP command				
000086 e002
000087 9300 0802                 	WV	USB_Out,2								;Signal ready for next command
000089 cfb0                      RJMP Main
                                 
                                 ;##########################################################################################################################
                                 Read_Page:
00008a d006                      	RCALL	Get_Z_Addr							;Receive the page to read and calculate Z pointer address			
00008b e020                      	LDI		Count,0		
00008c d00f                      RL:		RCALL CMS
00008d d00e                      		RCALL CMS
00008e 952a
00008f f7e1                      	DEC Count BRNE RL
000090 cfa9                      RJMP Main
                                 
                                 ;##########################################################################################################################
                                 Get_Z_Addr:
000091 d010                      	RCALL	RX_Wait							;Receive the page to read
000092 2f30                      	MOV		MEM_Page,T1						;Save page to MEM_Page register
000093 e0e0                      	LDI		ZL,0							;ZL is always 0
                                 		
000094 e1f0                      		LDI		ZH,0x10						;Assume Sigrow should be targeted (Mem_Page = 1)
000095 3031                      		CPI		MEM_Page,1					;Was the assumption correct?
000096 f021                      		BREQ	GE							;Goto End
                                 
000097 e1f4                      		LDI		ZH,High(EEPROM_START)		;Assume EEProm should be targeted (Mem_Page = 0)
000098 f010                      		BRLO	GE							;Was the assumption correct? Goto End
                                 
000099 2ff3                      		MOV		ZH,MEM_Page					;Target Flash ZH= MEM_Page * 2
00009a 0fff                      		LSL		ZH							;Multiply by left shifting		
00009b 9508                      GE:	RET
                                 
                                 ;##########################################################################################################################
                                 CMS:	;Conditional Memory Send / Sends one EEProm or Sigrow byte if MEM_Page is 0 or 1, otherwise one Flash byte
00009c 9111                      		LD		T2,Z+						;Assume EEProm or Sigrow should be read
00009d 3032                      		CPI		MEM_Page,2					;Was the assumption correct?
00009e f008                      		BRLO    CS							;Goto Send
00009f 9115                      		LPM		T2,Z+						;Else Load Flash
0000a0 d009                      CS:		RCALL TX_Wait						;Send the byte in T2
0000a1 9508                      RET
                                 
                                 ;##########################################################################################################################
                                 RX_Wait:		;Received byte in T1
0000a2 95a8                      	WDR							;Reset Watchdog
0000a3 9100 0804                 	LR		T1,USB_State		;Read USB Status Register
0000a5 ff07
0000a6 cffb                      	SBRS	T1,7 RJMP RX_Wait	;Continue loop until Receive Flag set
0000a7 9100 0800                 	LR		T1,USB_In	
0000a9 9508                      RET
                                 
                                 ;##########################################################################################################################
                                 TX_Wait:		;Byte to send in T2 / Register T1 is changed
0000aa 9100 0804
0000ac ff05
0000ad cffc                      	Wait_BIT_SET	USB_State,5
0000ae 9310 0802                 	WR	USB_Out,T2
0000b0 9508                      RET
                                 
                                 ;##########################################################################################################################
                                 ;Performs a write to the configuration change protected NVMCTRL_CTRLA register
                                 ;T2 = Value to write
                                 ;T1 is changed
                                 SPM_WRITE:
0000b1 e90d                      	LDI		T1,CPU_CCP_SPM_GC		
0000b2 bf04                      	WR		CPU_CCP,T1
0000b3 9310 1000                 	WR		NVMCTRL_CTRLA,T2
0000b5 9508                      RET
                                 
                                 ;##########################################################################################################################
                                 #ifdef LPT
0000b6 7345
0000b7 6c74
0000b8 425f
0000b9 6f6f
0000ba 2074
0000bb 2e31
0000bc 3130
0000bd 4c20
0000be 5450
0000bf 4120
0000c0 6164
0000c1 7470
0000c2 7265
0000c3 3020
0000c4 3030
0000c5 3530                      	ID_Start:	.db "Estl_Boot 1.01 LPT Adapter 00005"	ID_End:
                                 #else
                                 #endif
                                 
                                 ;##########################################################################################################################
                                 .dseg
006000                           Buffer:		.byte 512	;Buffer to temporarily store 1 memory page


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"AVR64DB64" register use summary:
x  :   5 y  :   0 z  :   7 r0 :   2 r1 :   2 r2 :   0 r3 :   0 r4 :   0 
r5 :   0 r6 :   0 r7 :   0 r8 :   0 r9 :   0 r10:   0 r11:   0 r12:   0 
r13:   0 r14:   0 r15:   0 r16:  51 r17:  12 r18:   6 r19:   6 r20:   1 
r21:   5 r22:   0 r23:   0 r24:   0 r25:   0 r26:   3 r27:   3 r28:   0 
r29:   0 r30:   7 r31:   7 
Registers used: 14 out of 35 (40.0%)

"AVR64DB64" instruction use summary:
.lds  :   0 .sts  :   0 adc   :   0 add   :   1 adiw  :   1 and   :   0 
andi  :   0 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   0 brcs  :   0 break :   0 breq  :   4 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   2 brlt  :   0 brmi  :   0 
brne  :   7 brpl  :   0 brsh  :   1 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :   0 cbi   :   0 cbr   :   0 
clc   :   0 clh   :   0 cli   :   1 cln   :   0 clr   :   0 cls   :   0 
clt   :   0 clv   :   0 clz   :   0 com   :   0 cp    :   1 cpc   :   0 
cpi   :   8 cpse  :   0 dec   :   3 eor   :   0 fmul  :   0 fmuls :   0 
fmulsu:   0 icall :   0 ijmp  :   1 in    :   0 inc   :   0 jmp   :   0 
ld    :   3 ldd   :   0 ldi   :  40 lds   :   8 lpm   :   3 lsl   :   1 
lsr   :   0 mov   :   2 movw  :   0 mul   :   0 muls  :   0 mulsu :   0 
neg   :   0 nop   :   0 or    :   0 ori   :   0 out   :   7 pop   :   0 
push  :   0 rcall :  16 ret   :   5 reti  :   0 rjmp  :  16 rol   :   0 
ror   :   0 sbc   :   0 sbci  :   0 sbi   :   0 sbic  :   0 sbis  :   0 
sbiw  :   1 sbr   :   0 sbrc  :   2 sbrs  :   4 sec   :   0 seh   :   0 
sei   :   0 sen   :   0 ser   :   0 ses   :   0 set   :   0 sev   :   0 
sez   :   0 sleep :   0 spm   :   4 st    :   4 std   :   0 sts   :  14 
sub   :   0 subi  :   0 swap  :   0 tst   :   0 wdr   :   2 
Instructions used: 28 out of 113 (24.8%)

"AVR64DB64" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x00018c    364     32    396   65536   0.6%
[.dseg] 0x006000 0x006200      0    512    512    8192   6.3%
[.eseg] 0x000000 0x000000      0      0      0     512   0.0%

Assembly complete, 0 errors, 0 warnings
